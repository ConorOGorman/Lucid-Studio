var B = (t) => {
  throw TypeError(t);
};
var O = (t, e, r) => e.has(t) || B("Cannot " + r);
var u = (t, e, r) => (O(t, e, "read from private field"), r ? r.call(t) : e.get(t)), y = (t, e, r) => e.has(t) ? B("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, r), w = (t, e, r, s) => (O(t, e, "write to private field"), s ? s.call(t, r) : e.set(t, r), r), f = (t, e, r) => (O(t, e, "access private method"), r);
import "@php-wasm/node-polyfills";
import { logger } from "@php-wasm/logger";
import { dirname, joinPaths, Semaphore, createSpawnHandler, basename, normalizePath, AcquireTimeoutError, splitShellCommand } from "@php-wasm/util";
import { parse, stringify } from "ini";
import { StreamedFile } from "@php-wasm/stream-compression";
class ErrnoError extends Error {
  constructor(e, r, s) {
    super(r, s), this.name = "ErrnoError", this.errno = e;
  }
}
const FileErrorCodes = {
  0: "No error occurred. System call completed successfully.",
  1: "Argument list too long.",
  2: "Permission denied.",
  3: "Address in use.",
  4: "Address not available.",
  5: "Address family not supported.",
  6: "Resource unavailable, or operation would block.",
  7: "Connection already in progress.",
  8: "Bad file descriptor.",
  9: "Bad message.",
  10: "Device or resource busy.",
  11: "Operation canceled.",
  12: "No child processes.",
  13: "Connection aborted.",
  14: "Connection refused.",
  15: "Connection reset.",
  16: "Resource deadlock would occur.",
  17: "Destination address required.",
  18: "Mathematics argument out of domain of function.",
  19: "Reserved.",
  20: "File exists.",
  21: "Bad address.",
  22: "File too large.",
  23: "Host is unreachable.",
  24: "Identifier removed.",
  25: "Illegal byte sequence.",
  26: "Operation in progress.",
  27: "Interrupted function.",
  28: "Invalid argument.",
  29: "I/O error.",
  30: "Socket is connected.",
  31: "There is a directory under that path.",
  32: "Too many levels of symbolic links.",
  33: "File descriptor value too large.",
  34: "Too many links.",
  35: "Message too large.",
  36: "Reserved.",
  37: "Filename too long.",
  38: "Network is down.",
  39: "Connection aborted by network.",
  40: "Network unreachable.",
  41: "Too many files open in system.",
  42: "No buffer space available.",
  43: "No such device.",
  44: "There is no such file or directory OR the parent directory does not exist.",
  45: "Executable file format error.",
  46: "No locks available.",
  47: "Reserved.",
  48: "Not enough space.",
  49: "No message of the desired type.",
  50: "Protocol not available.",
  51: "No space left on device.",
  52: "Function not supported.",
  53: "The socket is not connected.",
  54: "Not a directory or a symbolic link to a directory.",
  55: "Directory not empty.",
  56: "State not recoverable.",
  57: "Not a socket.",
  58: "Not supported, or operation not supported on socket.",
  59: "Inappropriate I/O control operation.",
  60: "No such device or address.",
  61: "Value too large to be stored in data type.",
  62: "Previous owner died.",
  63: "Operation not permitted.",
  64: "Broken pipe.",
  65: "Protocol error.",
  66: "Protocol not supported.",
  67: "Protocol wrong type for socket.",
  68: "Result too large.",
  69: "Read-only file system.",
  70: "Invalid seek.",
  71: "No such process.",
  72: "Reserved.",
  73: "Connection timed out.",
  74: "Text file busy.",
  75: "Cross-device link.",
  76: "Extension: Capabilities insufficient."
};
function getEmscriptenFsError(t) {
  const e = typeof t == "object" ? t == null ? void 0 : t.errno : null;
  if (e in FileErrorCodes)
    return FileErrorCodes[e];
}
function rethrowFileSystemError(t = "") {
  return function(r) {
    return function(...s) {
      try {
        return r.apply(this, s);
      } catch (n) {
        const i = typeof n == "object" ? n == null ? void 0 : n.errno : null;
        if (i in FileErrorCodes) {
          const o = FileErrorCodes[i], a = typeof s[1] == "string" ? s[1] : null, c = a !== null ? t.replaceAll("{path}", a) : t;
          throw new ErrnoError(
            i,
            `${c}: ${o}`,
            {
              cause: n
            }
          );
        }
        throw n;
      }
    };
  };
}
class FSHelpers {
  /**
   * Reads a file from the PHP filesystem and returns it as a string.
   *
   * @throws {@link @php-wasm/universal:ErrnoError} – If the file doesn't exist.
   * @param FS
   * @param  path - The file path to read.
   * @returns The file contents.
   */
  static readFileAsText(e, r) {
    return new TextDecoder().decode(FSHelpers.readFileAsBuffer(e, r));
  }
  /**
   * Reads a file from the PHP filesystem and returns it as an array buffer.
   *
   * @throws {@link @php-wasm/universal:ErrnoError} – If the file doesn't exist.
   * @param FS
   * @param  path - The file path to read.
   * @returns The file contents.
   */
  static readFileAsBuffer(e, r) {
    return e.readFile(r);
  }
  /**
   * Overwrites data in a file in the PHP filesystem.
   * Creates a new file if one doesn't exist yet.
   *
   * @param FS
   * @param  path - The file path to write to.
   * @param  data - The data to write to the file.
   */
  static writeFile(e, r, s) {
    e.writeFile(r, s);
  }
  /**
   * Removes a file from the PHP filesystem.
   *
   * @throws {@link @php-wasm/universal:ErrnoError} – If the file doesn't exist.
   * @param FS
   * @param  path - The file path to remove.
   */
  static unlink(e, r) {
    e.unlink(r);
  }
  /**
   * Moves a file or directory in the PHP filesystem to a
   * new location.
   *
   * @param FS
   * @param fromPath The path to rename.
   * @param toPath The new path.
   */
  static mv(e, r, s) {
    try {
      const n = e.lookupPath(r).node.mount, i = FSHelpers.fileExists(e, s) ? e.lookupPath(s).node.mount : e.lookupPath(dirname(s)).node.mount;
      n.mountpoint !== i.mountpoint ? (FSHelpers.copyRecursive(e, r, s), FSHelpers.isDir(e, r) ? FSHelpers.rmdir(e, r, { recursive: !0 }) : e.unlink(r)) : e.rename(r, s);
    } catch (n) {
      const i = getEmscriptenFsError(n);
      throw i ? new Error(
        `Could not move ${r} to ${s}: ${i}`,
        {
          cause: n
        }
      ) : n;
    }
  }
  /**
   * Removes a directory from the PHP filesystem.
   *
   * @param FS
   * @param path The directory path to remove.
   * @param options Options for the removal.
   */
  static rmdir(e, r, s = { recursive: !0 }) {
    const n = e.lookupPath(r, { follow: !1 });
    if ((n == null ? void 0 : n.node.mount.mountpoint) === r)
      throw new ErrnoError(10);
    s != null && s.recursive && FSHelpers.listFiles(e, r).forEach((i) => {
      const o = `${r}/${i}`;
      FSHelpers.isDir(e, o) ? FSHelpers.rmdir(e, o, s) : FSHelpers.unlink(e, o);
    }), e.getPath(e.lookupPath(r).node) === e.cwd() && e.chdir(joinPaths(e.cwd(), "..")), e.rmdir(r);
  }
  /**
   * Lists the files and directories in the given directory.
   *
   * @param FS
   * @param  path - The directory path to list.
   * @param  options - Options for the listing.
   * @returns The list of files and directories in the given directory.
   */
  static listFiles(e, r, s = { prependPath: !1 }) {
    if (!FSHelpers.fileExists(e, r))
      return [];
    try {
      const n = e.readdir(r).filter(
        (i) => i !== "." && i !== ".."
      );
      if (s.prependPath) {
        const i = r.replace(/\/$/, "");
        return n.map((o) => `${i}/${o}`);
      }
      return n;
    } catch (n) {
      return logger.error(n, { path: r }), [];
    }
  }
  /**
   * Checks if a directory exists in the PHP filesystem.
   *
   * @param FS
   * @param  path – The path to check.
   * @returns True if the path is a directory, false otherwise.
   */
  static isDir(e, r) {
    return FSHelpers.fileExists(e, r) ? e.isDir(e.lookupPath(r, { follow: !0 }).node.mode) : !1;
  }
  /**
   * Checks if a file exists in the PHP filesystem.
   *
   * @param FS
   * @param  path – The path to check.
   * @returns True if the path is a file, false otherwise.
   */
  static isFile(e, r) {
    return FSHelpers.fileExists(e, r) ? e.isFile(e.lookupPath(r, { follow: !0 }).node.mode) : !1;
  }
  /**
   * Creates a symlink in the PHP filesystem.
   *
   * @param FS
   * @param target
   * @param link
   */
  static symlink(e, r, s) {
    return e.symlink(r, s);
  }
  /**
   * Checks if a path is a symlink in the PHP filesystem.
   *
   * @param FS
   * @param path
   * @returns True if the path is a symlink, false otherwise.
   */
  static isSymlink(e, r) {
    return FSHelpers.fileExists(e, r) ? e.isLink(e.lookupPath(r).node.mode) : !1;
  }
  /**
   * Reads the target of a symlink in the PHP filesystem.
   * @param FS
   * @param path
   * @returns The target of the symlink.
   * @throws {@link @php-wasm/universal:ErrnoError} – If the path is not a symlink.
   */
  static readlink(e, r) {
    return e.readlink(r);
  }
  /**
   * Gets the real path of a file in the PHP filesystem.
   * @param FS
   * @param path
   *
   * @returns The real path of the file.
   */
  static realpath(e, r) {
    return e.lookupPath(r, { follow: !0 }).path;
  }
  /**
   * Checks if a file (or a directory) exists in the PHP filesystem.
   *
   * @param FS
   * @param  path - The file path to check.
   * @returns True if the file exists, false otherwise.
   */
  static fileExists(e, r) {
    try {
      return e.lookupPath(r), !0;
    } catch {
      return !1;
    }
  }
  /**
   * Recursively creates a directory with the given path in the PHP filesystem.
   * For example, if the path is `/root/php/data`, and `/root` already exists,
   * it will create the directories `/root/php` and `/root/php/data`.
   *
   * @param FS
   * @param  path - The directory path to create.
   */
  static mkdir(e, r) {
    e.mkdirTree(r);
  }
  static copyRecursive(e, r, s) {
    const n = e.lookupPath(r).node;
    if (e.isDir(n.mode)) {
      e.mkdirTree(s);
      const i = e.readdir(r).filter(
        (o) => o !== "." && o !== ".."
      );
      for (const o of i)
        FSHelpers.copyRecursive(
          e,
          joinPaths(r, o),
          joinPaths(s, o)
        );
    } else e.isLink(n.mode) ? e.symlink(e.readlink(r), s) : e.writeFile(s, e.readFile(r));
  }
}
FSHelpers.readFileAsText = rethrowFileSystemError('Could not read "{path}"')(
  FSHelpers.readFileAsText
);
FSHelpers.readFileAsBuffer = rethrowFileSystemError('Could not read "{path}"')(
  FSHelpers.readFileAsBuffer
);
FSHelpers.writeFile = rethrowFileSystemError('Could not write to "{path}"')(
  FSHelpers.writeFile
);
FSHelpers.unlink = rethrowFileSystemError('Could not unlink "{path}"')(
  FSHelpers.unlink
);
FSHelpers.rmdir = rethrowFileSystemError('Could not remove directory "{path}"')(
  FSHelpers.rmdir
);
FSHelpers.listFiles = rethrowFileSystemError(
  'Could not list files in "{path}"'
)(FSHelpers.listFiles);
FSHelpers.isDir = rethrowFileSystemError('Could not stat "{path}"')(
  FSHelpers.isDir
);
FSHelpers.isFile = rethrowFileSystemError('Could not stat "{path}"')(
  FSHelpers.isFile
);
FSHelpers.realpath = rethrowFileSystemError('Could not stat "{path}"')(
  FSHelpers.realpath
);
FSHelpers.fileExists = rethrowFileSystemError('Could not stat "{path}"')(
  FSHelpers.fileExists
);
FSHelpers.mkdir = rethrowFileSystemError('Could not create directory "{path}"')(
  FSHelpers.mkdir
);
FSHelpers.copyRecursive = rethrowFileSystemError(
  'Could not copy files from "{path}"'
)(FSHelpers.copyRecursive);
const _private = /* @__PURE__ */ new WeakMap();
var x;
class PHPWorker {
  /** @inheritDoc */
  constructor(e, r) {
    y(this, x);
    this.absoluteUrl = "", this.documentRoot = "", this.chroot = null, w(this, x, /* @__PURE__ */ new Map()), this.onMessageListeners = [], _private.set(this, {
      monitor: r
    }), e && this.__internal_setRequestHandler(e);
  }
  __internal_setRequestHandler(e) {
    this.absoluteUrl = e.absoluteUrl, this.documentRoot = e.documentRoot, this.chroot = this.documentRoot, _private.set(this, {
      ..._private.get(this),
      requestHandler: e
    });
  }
  /**
   * @internal
   * @deprecated
   * Do not use this method directly in the code consuming
   * the web API. It will change or even be removed without
   * a warning.
   */
  __internal_getPHP() {
    return _private.get(this).php;
  }
  /**
   * @internal
   * @deprecated
   * Do not use this method directly in the code consuming
   * the web API. It will change or even be removed without
   * a warning.
   */
  __internal_getRequestHandler() {
    return _private.get(this).requestHandler;
  }
  async setPrimaryPHP(e) {
    _private.set(this, {
      ..._private.get(this),
      php: e
    });
  }
  /** @inheritDoc @php-wasm/universal!PHPRequestHandler.pathToInternalUrl  */
  pathToInternalUrl(e) {
    return _private.get(this).requestHandler.pathToInternalUrl(e);
  }
  /** @inheritDoc @php-wasm/universal!PHPRequestHandler.internalUrlToPath  */
  internalUrlToPath(e) {
    return _private.get(this).requestHandler.internalUrlToPath(e);
  }
  /**
   * The onDownloadProgress event listener.
   */
  async onDownloadProgress(e) {
    var r;
    return (r = _private.get(this).monitor) == null ? void 0 : r.addEventListener("progress", e);
  }
  /** @inheritDoc @php-wasm/universal!PHP.mv  */
  async mv(e, r) {
    return _private.get(this).php.mv(e, r);
  }
  /** @inheritDoc @php-wasm/universal!PHP.rmdir  */
  async rmdir(e, r) {
    return _private.get(this).php.rmdir(e, r);
  }
  /** @inheritDoc @php-wasm/universal!PHPRequestHandler.request */
  async request(e) {
    return await _private.get(this).requestHandler.request(e);
  }
  /** @inheritDoc @php-wasm/universal!/PHP.run */
  async run(e) {
    const { php: r, reap: s } = await this.acquirePHPInstance();
    try {
      return await r.run(e);
    } finally {
      s();
    }
  }
  /** @inheritDoc @php-wasm/universal!/PHP.cli */
  async cli(e, r) {
    const { php: s, reap: n } = await this.acquirePHPInstance();
    let i;
    try {
      i = await s.cli(e, r);
    } catch (o) {
      throw n(), o;
    }
    return i.finished.finally(n), i;
  }
  /** @inheritDoc @php-wasm/universal!/PHP.chdir */
  chdir(e) {
    return this.chroot = e, _private.get(this).php.chdir(e);
  }
  /** @inheritDoc @php-wasm/universal!/PHP.chdir */
  cwd() {
    return _private.get(this).php.cwd();
  }
  /**
   * @returns A PHP instance with a consistent chroot.
   */
  async acquirePHPInstance() {
    const { php: e, reap: r } = await _private.get(this).requestHandler.instanceManager.acquirePHPInstance();
    return this.chroot !== null && e.chdir(this.chroot), this.registerWorkerListeners(e), { php: e, reap: r };
  }
  /** @inheritDoc @php-wasm/universal!/PHP.setSapiName */
  setSapiName(e) {
    _private.get(this).php.setSapiName(e);
  }
  /** @inheritDoc @php-wasm/universal!/PHP.mkdir */
  mkdir(e) {
    return _private.get(this).php.mkdir(e);
  }
  /** @inheritDoc @php-wasm/universal!/PHP.mkdirTree */
  mkdirTree(e) {
    return _private.get(this).php.mkdirTree(e);
  }
  /** @inheritDoc @php-wasm/universal!/PHP.readFileAsText */
  readFileAsText(e) {
    return _private.get(this).php.readFileAsText(e);
  }
  /** @inheritDoc @php-wasm/universal!/PHP.readFileAsBuffer */
  readFileAsBuffer(e) {
    return _private.get(this).php.readFileAsBuffer(e);
  }
  /** @inheritDoc @php-wasm/universal!/PHP.writeFile */
  writeFile(e, r) {
    return _private.get(this).php.writeFile(e, r);
  }
  /** @inheritDoc @php-wasm/universal!/PHP.unlink */
  unlink(e) {
    return _private.get(this).php.unlink(e);
  }
  /** @inheritDoc @php-wasm/universal!/PHP.listFiles */
  listFiles(e, r) {
    return _private.get(this).php.listFiles(e, r);
  }
  /** @inheritDoc @php-wasm/universal!/PHP.isDir */
  isDir(e) {
    return _private.get(this).php.isDir(e);
  }
  /** @inheritDoc @php-wasm/universal!/PHP.isFile */
  isFile(e) {
    return _private.get(this).php.isFile(e);
  }
  /** @inheritDoc @php-wasm/universal!/PHP.fileExists */
  fileExists(e) {
    return _private.get(this).php.fileExists(e);
  }
  /** @inheritDoc @php-wasm/universal!/PHP.onMessage */
  onMessage(e) {
    return this.onMessageListeners.push(e), async () => {
      this.onMessageListeners = this.onMessageListeners.filter(
        (r) => r !== e
      );
    };
  }
  /** @inheritDoc @php-wasm/universal!/PHP.defineConstant */
  defineConstant(e, r) {
    _private.get(this).php.defineConstant(e, r);
  }
  /** @inheritDoc @php-wasm/universal!/PHP.addEventListener */
  addEventListener(e, r) {
    u(this, x).has(e) || u(this, x).set(e, /* @__PURE__ */ new Set()), u(this, x).get(e).add(r);
  }
  /**
   * Removes an event listener for a PHP event.
   * @param eventType - The type of event to remove the listener from.
   * @param listener - The listener function to be removed.
   */
  removeEventListener(e, r) {
    var s;
    (s = u(this, x).get(e)) == null || s.delete(r);
  }
  dispatchEvent(e) {
    const r = u(this, x).get(e.type);
    if (r)
      for (const s of r)
        s(e);
  }
  registerWorkerListeners(e) {
    e.addEventListener("*", async (r) => {
      this.dispatchEvent(r);
    }), e.onMessage(async (r) => {
      for (const s of this.onMessageListeners) {
        const n = await s(r);
        if (n)
          return n;
      }
      return "";
    });
  }
  async [Symbol.asyncDispose]() {
    var e;
    await ((e = _private.get(this).requestHandler) == null ? void 0 : e[Symbol.asyncDispose]());
  }
}
x = new WeakMap();
function isExitCode(t) {
  return t instanceof Error ? (t == null ? void 0 : t.name) === "ExitStatus" && "status" in t : !1;
}
const RuntimeId = Symbol("RuntimeId"), loadedRuntimes = /* @__PURE__ */ new Map();
let lastRuntimeId = 0;
async function loadPHPRuntime(t, ...e) {
  const r = Object.assign({}, ...e), [s, n, i] = makePromise(), o = t.init(currentJsRuntime, {
    onAbort(c) {
      i(c), logger.error(c);
    },
    ENV: {},
    // Emscripten sometimes prepends a '/' to the path, which
    // breaks vite dev mode. An identity `locateFile` function
    // fixes it.
    locateFile: (c) => c,
    ...r,
    noInitialRun: !0,
    onRuntimeInitialized() {
      r.onRuntimeInitialized && r.onRuntimeInitialized(o), n();
    }
  });
  await s;
  const a = ++lastRuntimeId;
  return o.FS, o.id = a, o.originalExit = o._exit, o._exit = function(c) {
    return o.outboundNetworkProxyServer && (o.outboundNetworkProxyServer.close(), o.outboundNetworkProxyServer.closeAllConnections()), loadedRuntimes.delete(a), o.originalExit(c);
  }, o[RuntimeId] = a, loadedRuntimes.set(a, o), a;
}
function popLoadedRuntime(t, {
  dangerouslyKeepTheRuntimeInTheMap: e = !1
} = {}) {
  var s;
  const r = loadedRuntimes.get(t);
  if (!r)
    throw new Error(`Runtime with id ${t} not found`);
  if (e) {
    if (!((s = process == null ? void 0 : process.env) != null && s.TEST))
      throw new Error("Cannot pop runtime in non-test environment");
    return r;
  }
  return loadedRuntimes.delete(t), r;
}
const currentJsRuntime = function() {
  var t;
  return typeof process < "u" && ((t = process.release) == null ? void 0 : t.name) === "node" ? "NODE" : typeof window < "u" ? "WEB" : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? "WORKER" : "NODE";
}(), makePromise = () => {
  const t = [], e = new Promise((r, s) => {
    t.push(r, s);
  });
  return t.unshift(e), t;
}, responseTexts = {
  500: "Internal Server Error",
  502: "Bad Gateway",
  404: "Not Found",
  403: "Forbidden",
  401: "Unauthorized",
  400: "Bad Request",
  301: "Moved Permanently",
  302: "Found",
  307: "Temporary Redirect",
  308: "Permanent Redirect",
  204: "No Content",
  201: "Created",
  200: "OK"
};
class StreamedPHPResponse {
  constructor(e, r, s, n) {
    this.parsedHeaders = null, this.cachedStdoutBytes = null, this.cachedStderrText = null, this.headersStream = e, this.stdout = r, this.stderr = s, this.exitCode = n;
  }
  /**
   * True if the response is successful (HTTP status code 200-399),
   * false otherwise.
   */
  async ok() {
    try {
      const e = await this.httpStatusCode;
      return e >= 200 && e < 400;
    } catch {
      return !1;
    }
  }
  /**
   * Resolves when the response has finished processing – either successfully or not.
   */
  get finished() {
    return Promise.allSettled([this.exitCode.finally(() => {
    })]).then(
      () => {
      }
    );
  }
  /**
   * Resolves once HTTP headers are available.
   */
  get headers() {
    return this.getParsedHeaders().then((e) => e.headers);
  }
  /**
   * Resolves once HTTP status code is available.
   */
  get httpStatusCode() {
    return this.getParsedHeaders().then((e) => e.httpStatusCode).then((e) => e !== void 0 ? e : this.getParsedHeaders().then(
      (r) => r.httpStatusCode,
      () => 200
    )).catch(() => 500);
  }
  /**
   * Exposes the stdout bytes as they're produced by the PHP instance
   */
  get stdoutText() {
    return this.stdoutBytes.then(
      (e) => new TextDecoder().decode(e)
    );
  }
  /**
   * Exposes the stdout bytes as they're produced by the PHP instance
   */
  get stdoutBytes() {
    return this.cachedStdoutBytes || (this.cachedStdoutBytes = streamToBytes(this.stdout)), this.cachedStdoutBytes;
  }
  /**
   * Exposes the stderr bytes as they're produced by the PHP instance
   */
  get stderrText() {
    return this.cachedStderrText || (this.cachedStderrText = streamToText(this.stderr)), this.cachedStderrText;
  }
  async getParsedHeaders() {
    return this.parsedHeaders || (this.parsedHeaders = parseHeadersStream(this.headersStream)), await this.parsedHeaders;
  }
}
async function parseHeadersStream(t) {
  const e = await streamToText(t);
  let r;
  try {
    r = JSON.parse(e);
  } catch {
    return { headers: {}, httpStatusCode: 200 };
  }
  const s = {};
  for (const n of r.headers) {
    if (!n.includes(": "))
      continue;
    const i = n.indexOf(": "), o = n.substring(0, i).toLowerCase(), a = n.substring(i + 2);
    o in s || (s[o] = []), s[o].push(a);
  }
  return {
    headers: s,
    httpStatusCode: r.status
  };
}
async function streamToText(t) {
  const e = t.pipeThrough(new TextDecoderStream()).getReader(), r = [];
  for (; ; ) {
    const { done: s, value: n } = await e.read();
    if (s)
      return r.join("");
    n && r.push(n);
  }
}
async function streamToBytes(t) {
  const e = t.getReader(), r = [];
  for (; ; ) {
    const { done: s, value: n } = await e.read();
    if (s) {
      const i = r.reduce(
        (c, l) => c + l.byteLength,
        0
      ), o = new Uint8Array(i);
      let a = 0;
      for (const c of r)
        o.set(c, a), a += c.byteLength;
      return o;
    }
    n && r.push(n);
  }
}
class PHPResponse {
  constructor(e, r, s, n = "", i = 0) {
    this.httpStatusCode = e, this.headers = r, this.bytes = s, this.exitCode = i, this.errors = n;
  }
  static forHttpCode(e, r = "") {
    return new PHPResponse(
      e,
      {},
      new TextEncoder().encode(
        r || responseTexts[e] || ""
      )
    );
  }
  static fromRawData(e) {
    return new PHPResponse(
      e.httpStatusCode,
      e.headers,
      e.bytes,
      e.errors,
      e.exitCode
    );
  }
  static async fromStreamedResponse(e) {
    return await e.finished, new PHPResponse(
      await e.httpStatusCode,
      await e.headers,
      await e.stdoutBytes,
      await e.stderrText,
      await e.exitCode
    );
  }
  /**
   * True if the response is successful (HTTP status code 200-399),
   * false otherwise.
   */
  ok() {
    return this.httpStatusCode >= 200 && this.httpStatusCode < 400;
  }
  toRawData() {
    return {
      headers: this.headers,
      bytes: this.bytes,
      errors: this.errors,
      exitCode: this.exitCode,
      httpStatusCode: this.httpStatusCode
    };
  }
  /**
   * Response body as JSON.
   */
  get json() {
    return JSON.parse(this.text);
  }
  /**
   * Response body as text.
   */
  get text() {
    return new TextDecoder().decode(this.bytes);
  }
}
var _a;
const kError = Symbol("error"), kMessage = Symbol("message");
class ErrorEvent2 extends (_a = Event, _a) {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param type The name of the event
   * @param options A dictionary object that allows for setting
   *                  attributes via object members of the same name.
   */
  constructor(e, r = {}) {
    super(e), this[kError] = r.error === void 0 ? null : r.error, this[kMessage] = r.message === void 0 ? "" : r.message;
  }
  get error() {
    return this[kError];
  }
  get message() {
    return this[kMessage];
  }
}
Object.defineProperty(ErrorEvent2.prototype, "error", { enumerable: !0 });
Object.defineProperty(ErrorEvent2.prototype, "message", { enumerable: !0 });
const ErrorEvent = typeof globalThis.ErrorEvent == "function" ? globalThis.ErrorEvent : ErrorEvent2;
class UnhandledRejectionsTarget extends EventTarget {
  constructor() {
    super(...arguments), this.listenersCount = 0;
  }
  addEventListener(e, r, s) {
    ++this.listenersCount, super.addEventListener(
      e,
      r,
      s
    );
  }
  removeEventListener(e, r, s) {
    --this.listenersCount, super.removeEventListener(
      e,
      r,
      s
    );
  }
  hasListeners() {
    return this.listenersCount > 0;
  }
}
function improveWASMErrorReporting(t) {
  const e = new UnhandledRejectionsTarget();
  for (const r in t.wasmExports)
    if (typeof t.wasmExports[r] == "function") {
      const s = t.wasmExports[r];
      t.wasmExports[r] = function(...n) {
        var i;
        try {
          return s(...n);
        } catch (o) {
          if (!(o instanceof Error))
            throw o;
          t.lastAsyncifyStackSource && (o.cause = t.lastAsyncifyStackSource);
          const a = clarifyErrorMessage(
            o,
            (i = t.lastAsyncifyStackSource) == null ? void 0 : i.stack
          );
          if (e.hasListeners()) {
            o.message = a;
            const c = new ErrorEvent("error", { error: o });
            throw e.dispatchEvent(c), o;
          }
          throw (!isExitCode(o) || o.status !== 0) && showCriticalErrorBox(a), o;
        }
      };
    }
  return e;
}
let functionsMaybeMissingFromAsyncify = [];
function getFunctionsMaybeMissingFromAsyncify() {
  return functionsMaybeMissingFromAsyncify;
}
function clarifyErrorMessage(t, e) {
  if (t.message === "unreachable") {
    let r = UNREACHABLE_ERROR;
    e || (r += `

This stack trace is lacking. For a better one initialize 
the PHP runtime with debug: true, e.g. loadNodeRuntime('8.1', { emscriptenOptions: { debug: true } }).

`);
    const s = new Set(
      extractPHPFunctionsFromStack(e || "")
    );
    let n = t;
    do {
      for (const i of extractPHPFunctionsFromStack(
        n.stack || ""
      ))
        s.add(i);
      n = n.cause;
    } while (n);
    functionsMaybeMissingFromAsyncify = Array.from(s);
    for (const i of s)
      r += `    * ${i}
`;
    return r += `Original error message: ${t.message}
`, r;
  }
  return t.message;
}
const UNREACHABLE_ERROR = `
"unreachable" WASM instruction executed.

The typical reason is a PHP function missing from the ASYNCIFY_ONLY
list when building PHP.wasm.

You will need to file a new issue in the WordPress Playground repository
and paste this error message there:

https://github.com/WordPress/wordpress-playground/issues/new

If you're a core developer, the typical fix is to:

* Isolate a minimal reproduction of the error
* Add a reproduction of the error to php-asyncify.spec.ts in the WordPress Playground repository
* Run 'npm run fix-asyncify'
* Commit the changes, push to the repo, release updated NPM packages

Below is a list of all the PHP functions found in the stack trace to
help with the minimal reproduction. If they're all already listed in
the Dockerfile, you'll need to trigger this error again with long stack
traces enabled. In node.js, you can do it using the --stack-trace-limit=100
CLI option: 

`, redBg = "\x1B[41m", bold = "\x1B[1m", reset = "\x1B[0m", eol = "\x1B[K";
let logged = !1;
function showCriticalErrorBox(t) {
  if (!logged && (logged = !0, !(t != null && t.trim().startsWith("Program terminated with exit")))) {
    logger.log(`${redBg}
${eol}
${bold}  WASM ERROR${reset}${redBg}`);
    for (const e of t.split(`
`))
      logger.log(`${eol}  ${e} `);
    logger.log(`${reset}`);
  }
}
function extractPHPFunctionsFromStack(t) {
  try {
    const e = t.split(`
`).slice(1).map((r) => {
      const s = r.trim().substring(3).split(" ");
      return {
        fn: s.length >= 2 ? s[0] : "<unknown>",
        isWasm: r.includes("wasm:/")
      };
    }).filter(
      ({ fn: r, isWasm: s }) => s && !r.startsWith("dynCall_") && !r.startsWith("invoke_")
    ).map(({ fn: r }) => r);
    return Array.from(new Set(e));
  } catch {
    return [];
  }
}
const STRING = "string", NUMBER = "number", __private__dont__use = Symbol("__private__dont__use");
class PHPExecutionFailureError extends Error {
  constructor(e, r, s) {
    super(e), this.response = r, this.source = s;
  }
}
const PHP_INI_PATH = "/internal/shared/php.ini", AUTO_PREPEND_SCRIPT = "/internal/shared/auto_prepend_file.php", OPCACHE_FILE_FOLDER = "/internal/shared/opcache";
var M, H, T, v, F, k, _, h, z, $, V, G, J, Y, Q, K, U, X, q, j;
class PHP {
  /**
   * Initializes a PHP runtime.
   *
   * @internal
   * @param  PHPRuntime - Optional. PHP Runtime ID as initialized by loadPHPRuntime.
   * @param  requestHandlerOptions - Optional. Options for the PHPRequestHandler. If undefined, no request handler will be initialized.
   */
  constructor(t) {
    y(this, h);
    y(this, M);
    y(this, H, !1);
    y(this, T, null);
    y(this, v, /* @__PURE__ */ new Map([
      // Listen to all events
      ["*", /* @__PURE__ */ new Set()]
    ]));
    y(this, F, []);
    y(this, k, {});
    y(this, _, {
      enabled: !1,
      recreateRuntime: () => 0,
      needsRotating: !1,
      maxRequests: 400,
      requestsMade: 0
    });
    this.semaphore = new Semaphore({ concurrency: 1 }), t !== void 0 && this.initializeRuntime(t), this.addEventListener("request.error", (e) => {
      e.source === "php-wasm" && (u(this, _).needsRotating = !0);
    });
  }
  /**
   * Adds an event listener for a PHP event.
   * @param eventType - The type of event to listen for.
   * @param listener - The listener function to be called when the event is triggered.
   */
  addEventListener(t, e) {
    u(this, v).has(t) || u(this, v).set(t, /* @__PURE__ */ new Set()), u(this, v).get(t).add(e);
  }
  /**
   * Removes an event listener for a PHP event.
   * @param eventType - The type of event to remove the listener from.
   * @param listener - The listener function to be removed.
   */
  removeEventListener(t, e) {
    var r;
    (r = u(this, v).get(t)) == null || r.delete(e);
  }
  dispatchEvent(t) {
    const e = [
      ...u(this, v).get(t.type) || [],
      ...u(this, v).get("*") || []
    ];
    if (e)
      for (const r of e)
        r(t);
  }
  /**
   * Listens to message sent by the PHP code.
   *
   * To dispatch messages, call:
   *
   *     post_message_to_js(string $data)
   *
   *     Arguments:
   *         $data (string) – Data to pass to JavaScript.
   *
   * @example
   *
   * ```ts
   * const php = await PHP.load('8.0');
   *
   * php.onMessage(
   *     // The data is always passed as a string
   *     function (data: string) {
   *         // Let's decode and log the data:
   *         console.log(JSON.parse(data));
   *     }
   * );
   *
   * // Now that we have a listener in place, let's
   * // dispatch a message:
   * await php.run({
   *     code: `<?php
   *         post_message_to_js(
   *             json_encode([
   *                 'post_id' => '15',
   *                 'post_title' => 'This is a blog post!'
   *             ])
   *         ));
   *     `,
   * });
   * ```
   *
   * @param listener Callback function to handle the message.
   */
  onMessage(t) {
    return u(this, F).push(t), async () => {
      w(this, F, u(this, F).filter(
        (e) => e !== t
      ));
    };
  }
  async setSpawnHandler(handler) {
    typeof handler == "string" && (handler = createSpawnHandler(eval(handler))), this[__private__dont__use].spawnProcess = handler;
  }
  /** @deprecated Use PHPRequestHandler instead. */
  get absoluteUrl() {
    return this.requestHandler.absoluteUrl;
  }
  /** @deprecated Use PHPRequestHandler instead. */
  get documentRoot() {
    return this.requestHandler.documentRoot;
  }
  /** @deprecated Use PHPRequestHandler instead. */
  pathToInternalUrl(t) {
    return this.requestHandler.pathToInternalUrl(t);
  }
  /** @deprecated Use PHPRequestHandler instead. */
  internalUrlToPath(t) {
    return this.requestHandler.internalUrlToPath(t);
  }
  initializeRuntime(t) {
    if (this[__private__dont__use])
      throw new Error("PHP runtime already initialized.");
    const e = popLoadedRuntime(t);
    if (!e)
      throw new Error("Invalid PHP runtime id.");
    if (this[__private__dont__use] = e, this[__private__dont__use].ccall(
      "wasm_set_phpini_path",
      null,
      ["string"],
      [PHP_INI_PATH]
    ), !this.fileExists(PHP_INI_PATH)) {
      const r = [
        // OPCache
        "opcache.enable = 1",
        "opcache.enable_cli = 1",
        "opcache.jit = 0",
        "opcache.interned_strings_buffer = 8",
        "opcache.max_accelerated_files = 1000",
        "opcache.memory_consumption = 64",
        "opcache.max_wasted_percentage = 5",
        "opcache.file_cache = " + OPCACHE_FILE_FOLDER,
        // Always enable the file cache.
        "opcache.file_cache_only = 1",
        "opcache.file_cache_consistency_checks = 1"
      ];
      this.fileExists(OPCACHE_FILE_FOLDER) || this.mkdir(OPCACHE_FILE_FOLDER), this.writeFile(
        PHP_INI_PATH,
        [
          "auto_prepend_file=" + AUTO_PREPEND_SCRIPT,
          "memory_limit=256M",
          "ignore_repeated_errors = 1",
          "error_reporting = E_ALL",
          "display_errors = 1",
          "html_errors = 1",
          "display_startup_errors = On",
          "log_errors = 1",
          "always_populate_raw_post_data = -1",
          "upload_max_filesize = 2000M",
          "post_max_size = 2000M",
          "allow_url_fopen = On",
          "allow_url_include = Off",
          "session.save_path = /home/web_user",
          "implicit_flush = 1",
          "output_buffering = 0",
          "max_execution_time = 0",
          "max_input_time = -1",
          ...r
        ].join(`
`)
      );
    }
    this.fileExists(AUTO_PREPEND_SCRIPT) || this.writeFile(
      AUTO_PREPEND_SCRIPT,
      `<?php
				// Define constants set via defineConstant() calls
				if(file_exists('/internal/shared/consts.json')) {
					$consts = json_decode(file_get_contents('/internal/shared/consts.json'), true);
					foreach ($consts as $const => $value) {
						if (!defined($const) && is_scalar($value)) {
							define($const, $value);
						}
					}
				}
				// Preload all the files from /internal/shared/preload
				foreach (glob('/internal/shared/preload/*.php') as $file) {
					require_once $file;
				}
				`
    ), e.onMessage = async (r) => {
      for (const s of u(this, F)) {
        const n = await s(r);
        if (n)
          return n;
      }
      return "";
    }, w(this, T, improveWASMErrorReporting(e)), this.dispatchEvent({
      type: "runtime.initialized"
    });
  }
  /** @inheritDoc */
  async setSapiName(t) {
    if (this[__private__dont__use].ccall(
      "wasm_set_sapi_name",
      NUMBER,
      [STRING],
      [t]
    ) !== 0)
      throw new Error(
        "Could not set SAPI name. This can only be done before the PHP WASM module is initialized.Did you already dispatch any requests?"
      );
    w(this, M, t);
  }
  /**
   * Changes the current working directory in the PHP filesystem.
   * This is the directory that will be used as the base for relative paths.
   * For example, if the current working directory is `/root/php`, and the
   * path is `data`, the absolute path will be `/root/php/data`.
   *
   * @param  path - The new working directory.
   */
  chdir(t) {
    this[__private__dont__use].FS.chdir(t);
  }
  /**
   * Gets the current working directory in the PHP filesystem.
   *
   * @returns The current working directory.
   */
  cwd() {
    return this[__private__dont__use].FS.cwd();
  }
  /**
   * Changes the permissions of a file or directory.
   * @param path - The path to the file or directory.
   * @param mode - The new permissions.
   */
  chmod(t, e) {
    this[__private__dont__use].FS.chmod(t, e);
  }
  /**
   * Do not use. Use new PHPRequestHandler() instead.
   * @deprecated
   */
  async request(t) {
    if (logger.warn(
      "PHP.request() is deprecated. Please use new PHPRequestHandler() instead."
    ), !this.requestHandler)
      throw new Error("No request handler available.");
    return this.requestHandler.request(t);
  }
  /**
   * Runs PHP code.
   *
   * This low-level method directly interacts with the WebAssembly
   * PHP interpreter.
   *
   * Every time you call run(), it prepares the PHP
   * environment and:
   *
   * * Resets the internal PHP state
   * * Populates superglobals ($_SERVER, $_GET, etc.)
   * * Handles file uploads
   * * Populates input streams (stdin, argv, etc.)
   * * Sets the current working directory
   *
   * You can use run() in two primary modes:
   *
   * ### Code snippet mode
   *
   * In this mode, you pass a string containing PHP code to run.
   *
   * ```ts
   * const result = await php.run({
   * 	code: `<?php echo "Hello world!";`
   * });
   * // result.text === "Hello world!"
   * ```
   *
   * In this mode, information like __DIR__ or __FILE__ isn't very
   * useful because the code is not associated with any file.
   *
   * Under the hood, the PHP snippet is passed to the `zend_eval_string`
   * C function.
   *
   * ### File mode
   *
   * In the file mode, you pass a scriptPath and PHP executes a file
   * found at a that path:
   *
   * ```ts
   * php.writeFile(
   * 	"/www/index.php",
   * 	`<?php echo "Hello world!";"`
   * );
   * const result = await php.run({
   * 	scriptPath: "/www/index.php"
   * });
   * // result.text === "Hello world!"
   * ```
   *
   * In this mode, you can rely on path-related information like __DIR__
   * or __FILE__.
   *
   * Under the hood, the PHP file is executed with the `php_execute_script`
   * C function.
   *
   * The `run()` method cannot be used in conjunction with `cli()`.
   *
   * @example
   * ```js
   * const result = await php.run({
   * 	code: `<?php
   * 		$fp = fopen('php://stderr', 'w');
   * 		fwrite($fp, "Hello, world!");
   * 	`
   * });
   * // result.errors === "Hello, world!"
   * ```
   *
   * @deprecated Use stream() instead.
   * @param  request - PHP runtime options.
   */
  async run(t) {
    const e = await this.runStream(t), r = await PHPResponse.fromStreamedResponse(e);
    if (r.exitCode !== 0)
      throw new PHPExecutionFailureError(
        `PHP.run() failed with exit code ${r.exitCode}. 

=== Stdout ===
 ${r.text}

=== Stderr ===
 ${r.errors}`,
        r,
        "request"
      );
    return r;
  }
  /**
   * Runs PHP code and returns a StreamedPHPResponse object that can be used to
   * process the output incrementally.
   *
   * This low-level method directly interacts with the WebAssembly
   * PHP interpreter and provides streaming capabilities for processing
   * PHP output as it becomes available.
   *
   * Every time you call stream(), it prepares the PHP
   * environment and:
   *
   * * Resets the internal PHP state
   * * Populates superglobals ($_SERVER, $_GET, etc.)
   * * Handles file uploads
   * * Populates input streams (stdin, argv, etc.)
   * * Sets the current working directory
   *
   * You can use stream() in two primary modes:
   *
   * ### Code snippet mode
   *
   * In this mode, you pass a string containing PHP code to run.
   *
   * ```ts
   * const streamedResponse = await php.stream({
   * 	code: `<?php echo "Hello world!";`
   * });
   * // Process output incrementally
   * for await (const chunk of streamedResponse.text) {
   * 	console.log(chunk);
   * }
   * ```
   *
   * In this mode, information like __DIR__ or __FILE__ isn't very
   * useful because the code is not associated with any file.
   *
   * Under the hood, the PHP snippet is passed to the `zend_eval_string`
   * C function.
   *
   * ### File mode
   *
   * In the file mode, you pass a scriptPath and PHP executes a file
   * found at that path:
   *
   * ```ts
   * php.writeFile(
   * 	"/www/index.php",
   * 	`<?php echo "Hello world!";"`
   * );
   * const streamedResponse = await php.stream({
   * 	scriptPath: "/www/index.php"
   * });
   * // Process output incrementally
   * for await (const chunk of streamedResponse.text) {
   * 	console.log(chunk);
   * }
   * ```
   *
   * In this mode, you can rely on path-related information like __DIR__
   * or __FILE__.
   *
   * Under the hood, the PHP file is executed with the `php_execute_script`
   * C function.
   *
   * The `stream()` method cannot be used in conjunction with `cli()`.
   *
   * @example
   * ```js
   * const streamedResponse = await php.stream({
   * 	code: `<?php
   * 		for ($i = 0; $i < 5; $i++) {
   * 			echo "Line $i\n";
   * 			flush();
   * 		}
   * 	`
   * });
   *
   * // Process output as it becomes available
   * for await (const chunk of streamedResponse.text) {
   * 	console.log('Received:', chunk);
   * }
   *
   * // Get the final exit code
   * const exitCode = await streamedResponse.exitCode;
   * console.log('Exit code:', exitCode);
   * ```
   *
   * @see run() – a synchronous version of this method.
   * @param request - PHP runtime options.
   * @returns A StreamedPHPResponse object.
   */
  async runStream(t) {
    const e = await this.semaphore.acquire();
    let r;
    const s = f(this, h, j).call(this, async () => {
      if (u(this, H) || (await this[__private__dont__use].ccall(
        "php_wasm_init",
        null,
        [],
        [],
        {
          isAsync: !0
        }
      ), w(this, H, !0)), t.scriptPath && !this.fileExists(t.scriptPath))
        throw new Error(
          `The script path "${t.scriptPath}" does not exist.`
        );
      f(this, h, $).call(this, t.relativeUri || ""), f(this, h, Y).call(this, t.method || "GET");
      const i = normalizeHeaders(t.headers || {}), o = i.host || "example.com:443", a = f(this, h, J).call(this, o, t.protocol || "http");
      if (f(this, h, V).call(this, o), f(this, h, G).call(this, a), f(this, h, Q).call(this, i), t.body && (r = f(this, h, K).call(this, t.body)), typeof t.code == "string")
        this.writeFile("/internal/eval.php", t.code), f(this, h, U).call(this, "/internal/eval.php");
      else if (typeof t.scriptPath == "string")
        f(this, h, U).call(this, t.scriptPath || "");
      else
        throw new TypeError(
          "The request object must have either a `code` or a `scriptPath` property."
        );
      const c = f(this, h, z).call(this, t.$_SERVER, i, a);
      for (const p in c)
        f(this, h, X).call(this, p, c[p]);
      const l = t.env || {};
      for (const p in l)
        f(this, h, q).call(this, p, l[p]);
      return await this[__private__dont__use].ccall(
        "wasm_sapi_handle_request",
        NUMBER,
        [],
        [],
        { async: !0 }
      );
    }), n = () => {
      if (r)
        try {
          this[__private__dont__use].free(r);
        } catch (i) {
          logger.error(i);
        }
      e(), this.dispatchEvent({
        type: "request.end"
      });
    };
    return s.then(
      (i) => (i.finished.finally(n), i),
      (i) => {
        try {
          n();
        } catch {
        } finally {
          throw i;
        }
      }
    );
  }
  /**
   * Defines a constant in the PHP runtime.
   * @param key - The name of the constant.
   * @param value - The value of the constant.
   */
  defineConstant(t, e) {
    let r = {};
    try {
      r = JSON.parse(
        this.fileExists("/internal/shared/consts.json") && this.readFileAsText("/internal/shared/consts.json") || "{}"
      );
    } catch {
    }
    this.writeFile(
      "/internal/shared/consts.json",
      JSON.stringify({
        ...r,
        [t]: e
      })
    );
  }
  /**
   * Recursively creates a directory with the given path in the PHP filesystem.
   * For example, if the path is `/root/php/data`, and `/root` already exists,
   * it will create the directories `/root/php` and `/root/php/data`.
   *
   * @param  path - The directory path to create.
   */
  mkdir(t) {
    const e = FSHelpers.mkdir(this[__private__dont__use].FS, t);
    return this.dispatchEvent({ type: "filesystem.write" }), e;
  }
  /**
   * @deprecated Use mkdir instead.
   */
  mkdirTree(t) {
    return FSHelpers.mkdir(this[__private__dont__use].FS, t);
  }
  /**
   * Reads a file from the PHP filesystem and returns it as a string.
   *
   * @throws {@link @php-wasm/universal:ErrnoError} – If the file doesn't exist.
   * @param  path - The file path to read.
   * @returns The file contents.
   */
  readFileAsText(t) {
    return FSHelpers.readFileAsText(this[__private__dont__use].FS, t);
  }
  /**
   * Reads a file from the PHP filesystem and returns it as an array buffer.
   *
   * @throws {@link @php-wasm/universal:ErrnoError} – If the file doesn't exist.
   * @param  path - The file path to read.
   * @returns The file contents.
   */
  readFileAsBuffer(t) {
    return FSHelpers.readFileAsBuffer(this[__private__dont__use].FS, t);
  }
  /**
   * Overwrites data in a file in the PHP filesystem.
   * Creates a new file if one doesn't exist yet.
   *
   * @param  path - The file path to write to.
   * @param  data - The data to write to the file.
   */
  writeFile(t, e) {
    const r = FSHelpers.writeFile(
      this[__private__dont__use].FS,
      t,
      e
    );
    return this.dispatchEvent({ type: "filesystem.write" }), r;
  }
  /**
   * Removes a file from the PHP filesystem.
   *
   * @throws {@link @php-wasm/universal:ErrnoError} – If the file doesn't exist.
   * @param  path - The file path to remove.
   */
  unlink(t) {
    const e = FSHelpers.unlink(this[__private__dont__use].FS, t);
    return this.dispatchEvent({ type: "filesystem.write" }), e;
  }
  /**
   * Moves a file or directory in the PHP filesystem to a
   * new location.
   *
   * @param oldPath The path to rename.
   * @param newPath The new path.
   */
  mv(t, e) {
    const r = FSHelpers.mv(
      this[__private__dont__use].FS,
      t,
      e
    );
    return this.dispatchEvent({ type: "filesystem.write" }), r;
  }
  /**
   * Removes a directory from the PHP filesystem.
   *
   * @param path The directory path to remove.
   * @param options Options for the removal.
   */
  rmdir(t, e = { recursive: !0 }) {
    const r = FSHelpers.rmdir(
      this[__private__dont__use].FS,
      t,
      e
    );
    return this.dispatchEvent({ type: "filesystem.write" }), r;
  }
  /**
   * Lists the files and directories in the given directory.
   *
   * @param  path - The directory path to list.
   * @param  options - Options for the listing.
   * @returns The list of files and directories in the given directory.
   */
  listFiles(t, e = { prependPath: !1 }) {
    return FSHelpers.listFiles(
      this[__private__dont__use].FS,
      t,
      e
    );
  }
  /**
   * Checks if a directory exists in the PHP filesystem.
   *
   * @param  path – The path to check.
   * @returns True if the path is a directory, false otherwise.
   */
  isDir(t) {
    return FSHelpers.isDir(this[__private__dont__use].FS, t);
  }
  /**
   * Checks if a file exists in the PHP filesystem.
   *
   * @param  path – The path to check.
   * @returns True if the path is a file, false otherwise.
   */
  isFile(t) {
    return FSHelpers.isFile(this[__private__dont__use].FS, t);
  }
  /**
   * Creates a symlink in the PHP filesystem.
   * @param target
   * @param path
   */
  symlink(t, e) {
    return FSHelpers.symlink(this[__private__dont__use].FS, t, e);
  }
  /**
   * Checks if a path is a symlink in the PHP filesystem.
   *
   * @param path
   * @returns True if the path is a symlink, false otherwise.
   */
  isSymlink(t) {
    return FSHelpers.isSymlink(this[__private__dont__use].FS, t);
  }
  /**
   * Reads the target of a symlink in the PHP filesystem.
   *
   * @param path
   * @returns The target of the symlink.
   */
  readlink(t) {
    return FSHelpers.readlink(this[__private__dont__use].FS, t);
  }
  /**
   * Resolves the real path of a file in the PHP filesystem.
   * @param path
   * @returns The real path of the file.
   */
  realpath(t) {
    return FSHelpers.realpath(this[__private__dont__use].FS, t);
  }
  /**
   * Checks if a file (or a directory) exists in the PHP filesystem.
   *
   * @param  path - The file path to check.
   * @returns True if the file exists, false otherwise.
   */
  fileExists(t) {
    return FSHelpers.fileExists(this[__private__dont__use].FS, t);
  }
  /**
   * Enables inline PHP runtime rotation after a certain number of requests
   * or an internal crash.
   */
  enableRuntimeRotation(t) {
    w(this, _, {
      ...u(this, _),
      enabled: !0,
      recreateRuntime: t.recreateRuntime,
      maxRequests: t.maxRequests ?? 400
    });
  }
  async rotateRuntime() {
    if (!u(this, _).enabled)
      throw new Error(
        "Runtime rotation is not enabled. Call enableRuntimeRotation() first."
      );
    await this.hotSwapPHPRuntime(
      await u(this, _).recreateRuntime()
    ), u(this, _).requestsMade = 0, u(this, _).needsRotating = !1;
  }
  /**
   * Hot-swaps the PHP runtime for a new one without
   * interrupting the operations of this PHP instance.
   *
   * @param runtime
   */
  async hotSwapPHPRuntime(t) {
    const e = this[__private__dont__use].FS, r = this.listFiles("/").map((c) => `/${c}`), s = this[__private__dont__use].spawnProcess, n = e.cwd();
    e.chdir("/");
    const i = Object.entries(u(this, k)).map(
      ([c, l]) => ({
        mountHandler: l.mountHandler,
        vfsPath: c
      })
    ), o = Object.values(
      u(this, k)
    ).reverse();
    for (const c of o)
      await c.unmount();
    try {
      this.exit();
    } catch {
    }
    this.initializeRuntime(t), s && (this[__private__dont__use].spawnProcess = s), u(this, M) && this.setSapiName(u(this, M));
    const a = this[__private__dont__use].FS;
    for (const c of r)
      c && c !== "/request" && copyMEMFSNodes(e, a, c);
    for (const { mountHandler: c, vfsPath: l } of i)
      this.mkdir(l), await this.mount(l, c);
    try {
      a.chdir(n);
    } catch (c) {
      throw new Error(
        `Failed to restore CWD to ${n} after PHP runtime rotation.`,
        {
          cause: c
        }
      );
    }
  }
  /**
   * Mounts a filesystem to a given path in the PHP filesystem.
   *
   * @param  virtualFSPath - Where to mount it in the PHP virtual filesystem.
   * @param  mountHandler - The mount handler to use.
   * @return Unmount function to unmount the filesystem.
   */
  async mount(t, e) {
    const r = await e(
      this,
      this[__private__dont__use].FS,
      t
    ), s = {
      mountHandler: e,
      unmount: async () => {
        await r(), delete u(this, k)[t];
      }
    };
    return u(this, k)[t] = s, () => {
      s.unmount();
    };
  }
  /**
   * Starts a PHP CLI session with given arguments.
   *
   * This method can only be used when PHP was compiled with the CLI SAPI
   * and it cannot be used in conjunction with `run()`.
   *
   * Once this method finishes running, the PHP instance is no
   * longer usable and should be discarded. This is because PHP
   * internally cleans up all the resources and calls exit().
   *
   * @param  argv - The arguments to pass to the CLI.
   * @returns The exit code of the CLI session.
   */
  async cli(t, e = {}) {
    if (basename(t[0] ?? "") !== "php")
      return this.subProcess(t, e);
    u(this, H) && (u(this, _).needsRotating = !0);
    const r = await this.semaphore.acquire();
    return await f(this, h, j).call(this, () => {
      const s = e.env || {};
      for (const [n, i] of Object.entries(s))
        f(this, h, q).call(this, n, i);
      t = [t[0], "-c", PHP_INI_PATH, ...t.slice(1)];
      for (const n of t)
        this[__private__dont__use].ccall(
          "wasm_add_cli_arg",
          null,
          [STRING],
          [n]
        );
      return this[__private__dont__use].ccall("run_cli", null, [], [], {
        async: !0
      });
    }).then((s) => (s.exitCode.finally(r), s)).finally(() => {
      u(this, _).needsRotating = !0;
    });
  }
  /**
   * Runs an arbitrary CLI command using the spawn handler associated
   * with this PHP instance.
   *
   * @param argv
   * @param options
   * @returns StreamedPHPResponse.
   */
  async subProcess(t, e = {}) {
    const r = this[__private__dont__use].spawnProcess(
      t[0],
      t.slice(1),
      {
        env: e.env,
        cwd: e.cwd ?? this.cwd()
      }
    ), s = await createInvertedReadableStream();
    r.on("error", (i) => {
      s.controller.error(i);
    }), r.stderr.on("data", (i) => {
      s.controller.enqueue(i);
    });
    const n = await createInvertedReadableStream();
    return r.stdout.on("data", (i) => {
      n.controller.enqueue(i);
    }), r.on("exit", () => {
      setTimeout(() => {
        try {
          s.controller.close();
        } catch {
        }
        try {
          n.controller.close();
        } catch {
        }
      }, 0);
    }), new StreamedPHPResponse(
      // Headers stream
      new ReadableStream({
        start(i) {
          i.close();
        }
      }),
      n.stream,
      s.stream,
      // Exit code
      new Promise((i) => {
        r.on("exit", (o) => {
          i(o);
        });
      })
    );
  }
  setSkipShebang(t) {
    this[__private__dont__use].ccall(
      "wasm_set_skip_shebang",
      null,
      [NUMBER],
      [t ? 1 : 0]
    );
  }
  exit(t = 0) {
    this.dispatchEvent({
      type: "runtime.beforeExit"
    });
    try {
      this[__private__dont__use]._exit(t);
    } catch {
    }
    w(this, H, !1), w(this, T, null), this[__private__dont__use] && (delete this[__private__dont__use].onMessage, delete this[__private__dont__use]);
  }
  [Symbol.dispose]() {
    this.exit(0);
  }
}
M = new WeakMap(), H = new WeakMap(), T = new WeakMap(), v = new WeakMap(), F = new WeakMap(), k = new WeakMap(), _ = new WeakMap(), h = new WeakSet(), /**
 * Prepares the $_SERVER entries for the PHP runtime.
 *
 * @param defaults Default entries to include in $_SERVER.
 * @param headers HTTP headers to include in $_SERVER (as HTTP_ prefixed entries).
 * @param port HTTP port, used to determine infer $_SERVER['HTTPS'] value if none
 *             was provided.
 * @returns Computed $_SERVER entries.
 */
z = function(t, e, r) {
  const s = {
    ...t || {}
  };
  s.HTTPS = s.HTTPS || r === 443 ? "on" : "off";
  for (const n in e) {
    let i = "HTTP_";
    ["content-type", "content-length"].includes(n.toLowerCase()) && (i = ""), s[`${i}${n.toUpperCase().replace(/-/g, "_")}`] = e[n];
  }
  return s;
}, $ = function(t) {
  this[__private__dont__use].ccall(
    "wasm_set_request_uri",
    null,
    [STRING],
    [t]
  );
  let e = "";
  t.includes("?") && (e = t.substring(t.indexOf("?") + 1)), this[__private__dont__use].ccall(
    "wasm_set_query_string",
    null,
    [STRING],
    [e]
  );
}, V = function(t) {
  this[__private__dont__use].ccall(
    "wasm_set_request_host",
    null,
    [STRING],
    [t]
  );
}, G = function(t) {
  this[__private__dont__use].ccall(
    "wasm_set_request_port",
    null,
    [NUMBER],
    [t]
  );
}, J = function(t, e) {
  let r;
  try {
    r = parseInt(new URL(t).port, 10);
  } catch {
  }
  return (!r || isNaN(r) || r === 80) && (r = e === "https" ? 443 : 80), r;
}, Y = function(t) {
  this[__private__dont__use].ccall(
    "wasm_set_request_method",
    null,
    [STRING],
    [t]
  );
}, Q = function(t) {
  t.cookie && this[__private__dont__use].ccall(
    "wasm_set_cookies",
    null,
    [STRING],
    [t.cookie]
  ), t["content-type"] && this[__private__dont__use].ccall(
    "wasm_set_content_type",
    null,
    [STRING],
    [t["content-type"]]
  ), t["content-length"] && this[__private__dont__use].ccall(
    "wasm_set_content_length",
    null,
    [NUMBER],
    [parseInt(t["content-length"], 10)]
  );
}, K = function(t) {
  let e, r;
  typeof t == "string" ? (logger.warn(
    "Passing a string as the request body is deprecated. Please use a Uint8Array instead. See https://github.com/WordPress/wordpress-playground/issues/997 for more details"
  ), r = this[__private__dont__use].lengthBytesUTF8(t), e = r + 1) : (r = t.byteLength, e = t.byteLength);
  const s = this[__private__dont__use].malloc(e);
  if (!s)
    throw new Error("Could not allocate memory for the request body.");
  return typeof t == "string" ? this[__private__dont__use].stringToUTF8(
    t,
    s,
    e + 1
  ) : this[__private__dont__use].HEAPU8.set(t, s), this[__private__dont__use].ccall(
    "wasm_set_request_body",
    null,
    [NUMBER],
    [s]
  ), this[__private__dont__use].ccall(
    "wasm_set_content_length",
    null,
    [NUMBER],
    [r]
  ), s;
}, U = function(t) {
  this[__private__dont__use].ccall(
    "wasm_set_path_translated",
    null,
    [STRING],
    [t]
  );
}, X = function(t, e) {
  this[__private__dont__use].ccall(
    "wasm_add_SERVER_entry",
    null,
    [STRING, STRING],
    [t, e]
  );
}, q = function(t, e) {
  this[__private__dont__use].ccall(
    "wasm_add_ENV_entry",
    null,
    [STRING, STRING],
    [t, e]
  );
}, j = async function(t) {
  u(this, _).enabled && u(this, _).needsRotating && await this.rotateRuntime(), ++u(this, _).requestsMade, u(this, _).requestsMade >= u(this, _).maxRequests && (u(this, _).needsRotating = !0);
  const e = this[__private__dont__use], r = await createInvertedReadableStream();
  e.onHeaders = (d) => {
    a || s || r.controller.enqueue(d.slice());
  };
  let s = !1;
  const n = () => {
    s || (s = !0, r.controller.close());
  }, i = await createInvertedReadableStream();
  e.onStdout = (d) => {
    n(), !a && i.controller.enqueue(d.slice());
  };
  const o = await createInvertedReadableStream();
  e.onStderr = (d) => {
    a || o.controller.enqueue(d.slice());
  };
  let a = !1, c;
  const p = (async () => {
    var d;
    try {
      return await Promise.race([
        t(),
        new Promise((P, b) => {
          var D;
          c = (W) => {
            isExitCode(W.error) || b(W.error);
          }, (D = u(this, T)) == null || D.addEventListener(
            "error",
            c,
            { once: !0 }
          );
        })
      ]);
    } catch (m) {
      if (isExitCode(m))
        return m.status;
      i.controller.error(m), o.controller.error(m), r.controller.error(m), a = !0;
      for (const P in this)
        typeof this[P] == "function" && (this[P] = () => {
          throw new Error(
            "PHP runtime has crashed – see the earlier error for details."
          );
        });
      throw this.functionsMaybeMissingFromAsyncify = getFunctionsMaybeMissingFromAsyncify(), m;
    } finally {
      a || (i.controller.close(), o.controller.close(), n(), a = !0), (d = u(this, T)) == null || d.removeEventListener(
        "error",
        c
      );
    }
  })().then(
    (d) => (d !== 0 && this.dispatchEvent({
      type: "request.error",
      error: new Error(
        `PHP.run() failed with exit code ${d}.`
      ),
      // Distinguish between PHP request and PHP-wasm errors
      source: "php-wasm"
    }), d),
    (d) => {
      const m = d.source ?? "php-wasm";
      throw this.dispatchEvent({
        type: "request.error",
        error: d,
        source: m
      }), d;
    }
  );
  return new StreamedPHPResponse(
    r.stream,
    i.stream,
    o.stream,
    p
  );
};
function normalizeHeaders(t) {
  const e = {};
  for (const r in t)
    e[r.toLowerCase()] = t[r];
  return e;
}
function copyMEMFSNodes(t, e, r) {
  if (getNodeType(t, r) !== "memfs" || !["memfs", "missing"].includes(getNodeType(e, r)))
    return;
  const s = t.lookupPath(r);
  if (!t.isDir(s.node.mode)) {
    e.writeFile(r, t.readFile(r));
    return;
  }
  e.mkdirTree(r);
  const n = t.readdir(r).filter((i) => i !== "." && i !== "..");
  for (const i of n)
    copyMEMFSNodes(t, e, joinPaths(r, i));
}
async function createInvertedReadableStream(t = {}) {
  let e;
  const r = new Promise(
    (i) => {
      e = i;
    }
  ), s = new ReadableStream({
    ...t,
    start(i) {
      if (e(i), t.start)
        return t.start(i);
    }
  }), n = await r;
  return {
    stream: s,
    controller: n
  };
}
const getNodeType = (t, e) => {
  try {
    return "contents" in t.lookupPath(e, { follow: !0 }).node ? "memfs" : (
      /**
      * Could be NODEFS, PROXYFS, etc.
      */
      "not-memfs"
    );
  } catch {
    return "missing";
  }
};
async function getPhpIniEntries(t, e) {
  const r = parse(await t.readFileAsText(PHP_INI_PATH));
  if (e === void 0)
    return r;
  const s = {};
  for (const n of e)
    s[n] = r[n];
  return s;
}
async function setPhpIniEntries(t, e) {
  const r = parse(await t.readFileAsText(PHP_INI_PATH));
  for (const [s, n] of Object.entries(e))
    n == null ? delete r[s] : r[s] = n;
  await t.writeFile(PHP_INI_PATH, stringify(r));
}
async function withPHPIniValues(t, e, r) {
  const s = await t.readFileAsText(PHP_INI_PATH);
  try {
    return await setPhpIniEntries(t, e), await r();
  } finally {
    await t.writeFile(PHP_INI_PATH, s);
  }
}
async function printDebugDetails(t, e) {
  e && printResponseDebugDetails(
    await PHPResponse.fromStreamedResponse(e)
  ), await prettyPrintFullStackTrace(t);
}
async function prettyPrintFullStackTrace(t) {
  let e = t, r = !0;
  for (; e; )
    r || process.stderr.write(`
Caused by:

`), process.stderr.write(e.originalErrorClassName ?? e.name), process.stderr.write(": " + e.message + `
`), process.stderr.write(
      (e.stack + "").split(`
`).slice(1).join(`
`)
    ), process.stderr.write(`
`), e.response && printResponseDebugDetails(e.response), e.phpLogs && (process.stderr.write(`

==== PHP error log ====

`), process.stderr.write(e.phpLogs)), e = e.cause, r = !1;
  process.stderr.write(`
`);
}
function printResponseDebugDetails(t) {
  process.stderr.write(
    `
    exitCode=${t.exitCode} httpStatusCode=${t.httpStatusCode} `
  );
  const e = t.headers && Object.keys(t.headers).length > 0;
  e || process.stderr.write("responseHeaders=(empty) "), t.text || process.stderr.write("stdout=(empty) "), t.errors || process.stderr.write("stderr=(empty) "), process.stderr.write(`
`), e && process.stderr.write(
    `
==== PHP response headers ====

${JSON.stringify(
      t.headers,
      null,
      2
    )}

`
  ), t.text && (process.stderr.write(`
==== PHP stdout ====

`), process.stderr.write(t.text)), t.errors && (process.stderr.write(`
==== PHP stderr ====

`), process.stderr.write(t.errors)), process.stderr.write(`
`);
}
class HttpCookieStore {
  constructor() {
    this.cookies = {};
  }
  rememberCookiesFromResponseHeaders(e) {
    if (e != null && e["set-cookie"])
      for (const r of e["set-cookie"])
        try {
          if (!r.includes("="))
            continue;
          const s = r.indexOf("="), n = r.substring(0, s), i = r.substring(s + 1).split(";")[0];
          this.cookies[n] = i;
        } catch (s) {
          logger.error(s);
        }
  }
  getCookieRequestHeader() {
    const e = [];
    for (const r in this.cookies)
      e.push(`${r}=${this.cookies[r]}`);
    return e.join("; ");
  }
}
function streamReadFileFromPHP(t, e) {
  return new ReadableStream({
    async pull(r) {
      const s = await t.readFileAsBuffer(e);
      r.enqueue(s), r.close();
    }
  });
}
async function* iteratePhpFiles(t, e, {
  relativePaths: r = !0,
  pathPrefix: s,
  exceptPaths: n = []
} = {}) {
  e = normalizePath(e);
  const i = [e];
  for (; i.length; ) {
    const o = i.pop();
    if (!o)
      return;
    const a = await t.listFiles(o);
    for (const c of a) {
      const l = `${o}/${c}`;
      if (n.includes(l.substring(e.length + 1)))
        continue;
      await t.isDir(l) ? i.push(l) : yield new StreamedFile(
        streamReadFileFromPHP(t, l),
        r ? joinPaths(
          s || "",
          l.substring(e.length + 1)
        ) : l
      );
    }
  }
}
function writeFilesStreamToPhp(t, e) {
  return new WritableStream({
    async write(r) {
      const s = joinPaths(e, r.name);
      r.type === "directory" ? await t.mkdir(s) : (await t.mkdir(dirname(s)), await t.writeFile(
        s,
        new Uint8Array(await r.arrayBuffer())
      ));
    }
  });
}
class SinglePHPInstanceManager {
  constructor(e) {
    if (this.isAcquired = !1, !e.php && !e.phpFactory)
      throw new Error(
        "SinglePHPInstanceManager requires either php or phpFactory"
      );
    this.php = e.php, this.phpFactory = e.phpFactory;
  }
  async getPrimaryPhp() {
    return this.php ? this.php : (this.phpPromise || (this.phpPromise = this.phpFactory().then((e) => (this.php = e, this.phpPromise = void 0, e))), this.phpPromise);
  }
  async acquirePHPInstance() {
    if (this.isAcquired)
      throw new Error(
        "The PHP instance already acquired. SinglePHPInstanceManager cannot spawn another PHP instance since, by definition, it only manages a single PHP instance."
      );
    const e = await this.getPrimaryPhp();
    return this.isAcquired = !0, {
      php: e,
      reap: () => {
        this.isAcquired = !1;
      }
    };
  }
  async [Symbol.asyncDispose]() {
    this.php && this.php.exit();
  }
}
class MaxPhpInstancesError extends Error {
  constructor(e) {
    super(
      `Requested more concurrent PHP instances than the limit (${e}).`
    ), this.name = this.constructor.name;
  }
}
class PHPProcessManager {
  constructor(e) {
    this.primaryIdle = !0, this.nextInstance = null, this.allInstances = [], this.maxPhpInstances = (e == null ? void 0 : e.maxPhpInstances) ?? 5, this.phpFactory = e == null ? void 0 : e.phpFactory, this.primaryPhp = e == null ? void 0 : e.primaryPhp, this.semaphore = new Semaphore({
      concurrency: this.maxPhpInstances,
      /**
       * Wait up to 5 seconds for resources to become available
       * before assuming that all the PHP instances are deadlocked.
       */
      timeout: (e == null ? void 0 : e.timeout) || 5e3
    });
  }
  /**
   * Get the primary PHP instance.
   *
   * If the primary PHP instance is not set, it will be spawned
   * using the provided phpFactory.
   *
   * @throws {Error} when called twice before the first call is resolved.
   */
  async getPrimaryPhp() {
    if (!this.phpFactory && !this.primaryPhp)
      throw new Error(
        "phpFactory or primaryPhp must be set before calling getPrimaryPhp()."
      );
    return this.primaryPhp || (this.primaryPhpPromise || (this.primaryPhpPromise = this.spawn({ isPrimary: !0 })), this.primaryPhp = (await this.primaryPhpPromise).php, this.primaryPhpPromise = void 0), this.primaryPhp;
  }
  /**
   * Get a PHP instance.
   *
   * It could be either the primary PHP instance, an idle disposable PHP
   * instance, or a newly spawned PHP instance – depending on the resource
   * availability.
   *
   * @param considerPrimary - Whether to consider the primary PHP instance.
   *                          It matters because PHP.cli() sets the SAPI to CLI and
   *                          kills the entire process after it finishes running,
   *                          making the primary PHP instance non-reusable for
   *                          subsequent .run() calls. This is fine for one-off
   *                          child PHP instances, but not for the primary PHP
   *                          that's meant to continue working for the entire duration
   *                          of the ProcessManager lifetime. Therefore, we don't
   *                          consider the primary PHP instance by default unless
   *                          the caller explicitly requests it.
   *
   * @throws {MaxPhpInstancesError} when the maximum number of PHP instances is reached
   *                                and the waiting timeout is exceeded.
   */
  async acquirePHPInstance({
    considerPrimary: e = !1
  } = {}) {
    if (this.primaryPhp || await this.getPrimaryPhp(), this.primaryIdle && e)
      return this.primaryIdle = !1, {
        php: await this.getPrimaryPhp(),
        reap: () => {
          this.primaryIdle = !0;
        }
      };
    const r = this.nextInstance || this.spawn({ isPrimary: !1 });
    return this.semaphore.remaining > 0 ? this.nextInstance = this.spawn({ isPrimary: !1 }) : this.nextInstance = null, await r;
  }
  /**
   * Initiated spawning of a new PHP instance.
   * This function is synchronous on purpose – it needs to synchronously
   * add the spawn promise to the allInstances array without waiting
   * for PHP to spawn.
   */
  spawn(e) {
    if (e.isPrimary && this.allInstances.length > 0)
      throw new Error(
        "Requested spawning a primary PHP instance when another primary instance already started spawning."
      );
    const r = this.doSpawn(e);
    this.allInstances.push(r);
    const s = () => {
      this.allInstances = this.allInstances.filter(
        (n) => n !== r
      );
    };
    return r.catch((n) => {
      throw s(), n;
    }).then((n) => ({
      ...n,
      reap: () => {
        s(), n.reap();
      }
    }));
  }
  /**
   * Actually acquires the lock and spawns a new PHP instance.
   */
  async doSpawn(e) {
    let r;
    try {
      r = await this.semaphore.acquire();
    } catch (s) {
      throw s instanceof AcquireTimeoutError ? new MaxPhpInstancesError(this.maxPhpInstances) : s;
    }
    try {
      const s = await this.phpFactory(e);
      return {
        php: s,
        reap() {
          s.exit(), r();
        }
      };
    } catch (s) {
      throw r(), s;
    }
  }
  async [Symbol.asyncDispose]() {
    this.primaryPhp && this.primaryPhp.exit(), await Promise.all(
      this.allInstances.map(
        (e) => e.then(({ reap: r }) => r())
      )
    );
  }
}
const SupportedPHPVersions = [
  "8.5",
  "8.4",
  "8.3",
  "8.2",
  "8.1",
  "8.0",
  "7.4",
  "7.3",
  "7.2"
], LatestSupportedPHPVersion = SupportedPHPVersions[0], SupportedPHPVersionsList = SupportedPHPVersions, DEFAULT_BASE_URL = "http://example.com";
function toRelativeUrl(t) {
  return t.origin === "null" ? t.toString() : t.toString().substring(t.origin.length);
}
function removePathPrefix(t, e) {
  return !e || !t.startsWith(e) ? t : t.substring(e.length);
}
function ensurePathPrefix(t, e) {
  return !e || t.startsWith(e) ? t : e + t;
}
async function encodeAsMultipart(t) {
  const e = `----${Math.random().toString(36).slice(2)}`, r = `multipart/form-data; boundary=${e}`, s = new TextEncoder(), n = [];
  for (const [c, l] of Object.entries(t))
    n.push(`--${e}\r
`), n.push(`Content-Disposition: form-data; name="${c}"`), l instanceof File && n.push(`; filename="${l.name}"`), n.push(`\r
`), l instanceof File && (n.push("Content-Type: application/octet-stream"), n.push(`\r
`)), n.push(`\r
`), l instanceof File ? n.push(await fileToUint8Array(l)) : n.push(l), n.push(`\r
`);
  n.push(`--${e}--\r
`);
  const i = n.reduce((c, l) => c + l.length, 0), o = new Uint8Array(i);
  let a = 0;
  for (const c of n)
    o.set(
      typeof c == "string" ? s.encode(c) : c,
      a
    ), a += c.length;
  return { bytes: o, contentType: r };
}
function fileToUint8Array(t) {
  return t.arrayBuffer().then((e) => new Uint8Array(e));
}
const _default = "application/octet-stream", asx = "video/x-ms-asf", atom = "application/atom+xml", avi = "video/x-msvideo", avif = "image/avif", bin = "application/octet-stream", bmp = "image/x-ms-bmp", cco = "application/x-cocoa", css = "text/css", data = "application/octet-stream", deb = "application/octet-stream", der = "application/x-x509-ca-cert", dmg = "application/octet-stream", doc = "application/msword", docx = "application/vnd.openxmlformats-officedocument.wordprocessingml.document", eot = "application/vnd.ms-fontobject", flv = "video/x-flv", gif = "image/gif", gz = "application/gzip", hqx = "application/mac-binhex40", htc = "text/x-component", html = "text/html", ico = "image/x-icon", iso = "application/octet-stream", jad = "text/vnd.sun.j2me.app-descriptor", jar = "application/java-archive", jardiff = "application/x-java-archive-diff", jng = "image/x-jng", jnlp = "application/x-java-jnlp-file", jpg = "image/jpeg", jpeg = "image/jpeg", js = "application/javascript", json = "application/json", kml = "application/vnd.google-earth.kml+xml", kmz = "application/vnd.google-earth.kmz", m3u8 = "application/vnd.apple.mpegurl", m4a = "audio/x-m4a", m4v = "video/x-m4v", md = "text/plain", mid = "audio/midi", mml = "text/mathml", mng = "video/x-mng", mov = "video/quicktime", mp3 = "audio/mpeg", mp4 = "video/mp4", mpeg = "video/mpeg", msi = "application/octet-stream", odg = "application/vnd.oasis.opendocument.graphics", odp = "application/vnd.oasis.opendocument.presentation", ods = "application/vnd.oasis.opendocument.spreadsheet", odt = "application/vnd.oasis.opendocument.text", ogg = "audio/ogg", otf = "font/otf", pdf = "application/pdf", pl = "application/x-perl", png = "image/png", ppt = "application/vnd.ms-powerpoint", pptx = "application/vnd.openxmlformats-officedocument.presentationml.presentation", prc = "application/x-pilot", ps = "application/postscript", ra = "audio/x-realaudio", rar = "application/x-rar-compressed", rpm = "application/x-redhat-package-manager", rss = "application/rss+xml", rtf = "application/rtf", run = "application/x-makeself", sea = "application/x-sea", sit = "application/x-stuffit", svg = "image/svg+xml", swf = "application/x-shockwave-flash", tcl = "application/x-tcl", tar = "application/x-tar", tif = "image/tiff", ts = "video/mp2t", ttf = "font/ttf", txt = "text/plain", wasm = "application/wasm", wbmp = "image/vnd.wap.wbmp", webm = "video/webm", webp = "image/webp", wml = "text/vnd.wap.wml", wmlc = "application/vnd.wap.wmlc", wmv = "video/x-ms-wmv", woff = "font/woff", woff2 = "font/woff2", xhtml = "application/xhtml+xml", xls = "application/vnd.ms-excel", xlsx = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", xml = "text/xml", xpi = "application/x-xpinstall", xspf = "application/xspf+xml", zip = "application/zip", mimeTypes = {
  _default,
  "3gpp": "video/3gpp",
  "7z": "application/x-7z-compressed",
  asx,
  atom,
  avi,
  avif,
  bin,
  bmp,
  cco,
  css,
  data,
  deb,
  der,
  dmg,
  doc,
  docx,
  eot,
  flv,
  gif,
  gz,
  hqx,
  htc,
  html,
  ico,
  iso,
  jad,
  jar,
  jardiff,
  jng,
  jnlp,
  jpg,
  jpeg,
  js,
  json,
  kml,
  kmz,
  m3u8,
  m4a,
  m4v,
  md,
  mid,
  mml,
  mng,
  mov,
  mp3,
  mp4,
  mpeg,
  msi,
  odg,
  odp,
  ods,
  odt,
  ogg,
  otf,
  pdf,
  pl,
  png,
  ppt,
  pptx,
  prc,
  ps,
  ra,
  rar,
  rpm,
  rss,
  rtf,
  run,
  sea,
  sit,
  svg,
  swf,
  tcl,
  tar,
  tif,
  ts,
  ttf,
  txt,
  wasm,
  wbmp,
  webm,
  webp,
  wml,
  wmlc,
  wmv,
  woff,
  woff2,
  xhtml,
  xls,
  xlsx,
  xml,
  xpi,
  xspf,
  zip
};
var g, I, L, C, A, E, N, R, S, Z, ee, te, re;
class PHPRequestHandler {
  /**
   * The request handler needs to decide whether to serve a static asset or
   * run the PHP interpreter. For static assets it should just reuse the primary
   * PHP even if there's 50 concurrent requests to serve. However, for
   * dynamic PHP requests, it needs to grab an available interpreter.
   * Therefore, it cannot just accept PHP as an argument as serving requests
   * requires access to ProcessManager.
   *
   * @param  php    - The PHP instance.
   * @param  config - Request Handler configuration.
   */
  constructor(e) {
    y(this, S);
    y(this, g);
    y(this, I);
    y(this, L);
    y(this, C);
    y(this, A);
    y(this, E);
    y(this, N);
    y(this, R);
    const {
      documentRoot: r = "/www/",
      absoluteUrl: s = typeof location == "object" ? location.href : DEFAULT_BASE_URL,
      rewriteRules: n = [],
      getFileNotFoundAction: i = () => ({ type: "404" })
    } = e, o = (l) => {
      l.isDir(r) || l.mkdir(r), l.chdir(r), l.requestHandler = this;
    };
    if (e.php)
      o(e.php), this.instanceManager = new SinglePHPInstanceManager({
        php: e.php
      });
    else if (e.phpFactory)
      this.instanceManager = new PHPProcessManager({
        phpFactory: async (l) => {
          const p = await e.phpFactory({
            ...l,
            requestHandler: this
          });
          return o(p), p;
        },
        maxPhpInstances: e.maxPhpInstances
      });
    else
      throw new Error(
        "Either php or phpFactory must be provided in the configuration."
      );
    w(this, R, e.cookieStore === void 0 ? new HttpCookieStore() : e.cookieStore), w(this, g, r);
    const a = new URL(s);
    w(this, L, a.hostname), w(this, C, a.port ? Number(a.port) : a.protocol === "https:" ? 443 : 80), w(this, I, (a.protocol || "").replace(":", ""));
    const c = u(this, C) !== 443 && u(this, C) !== 80;
    w(this, A, [
      u(this, L),
      c ? `:${u(this, C)}` : ""
    ].join("")), w(this, E, a.pathname.replace(/\/+$/, "")), w(this, N, [
      `${u(this, I)}://`,
      u(this, A),
      u(this, E)
    ].join("")), this.rewriteRules = n, this.getFileNotFoundAction = i;
  }
  async getPrimaryPhp() {
    return await this.instanceManager.getPrimaryPhp();
  }
  /**
   * Converts a path to an absolute URL based at the PHPRequestHandler
   * root.
   *
   * @param  path The server path to convert to an absolute URL.
   * @returns The absolute URL.
   */
  pathToInternalUrl(e) {
    return e.startsWith("/") || (e = `/${e}`), `${this.absoluteUrl}${e}`;
  }
  /**
   * Converts an absolute URL based at the PHPRequestHandler to a relative path
   * without the server pathname and scope.
   *
   * @param  internalUrl An absolute URL based at the PHPRequestHandler root.
   * @returns The relative path.
   */
  internalUrlToPath(e) {
    const r = new URL(e, "https://playground.internal");
    return r.pathname.startsWith(u(this, E)) && (r.pathname = r.pathname.slice(u(this, E).length)), toRelativeUrl(r);
  }
  /**
   * The absolute URL of this PHPRequestHandler instance.
   */
  get absoluteUrl() {
    return u(this, N);
  }
  /**
   * The directory in the PHP filesystem where the server will look
   * for the files to serve. Default: `/var/www`.
   */
  get documentRoot() {
    return u(this, g);
  }
  /**
   * Serves the request – either by serving a static file, or by
   * dispatching it to the PHP runtime.
   *
   * The request() method mode behaves like a web server and only works if
   * the PHP was initialized with a `requestHandler` option (which the online
   * version of WordPress Playground does by default).
   *
   * In the request mode, you pass an object containing the request information
   * (method, headers, body, etc.) and the path to the PHP file to run:
   *
   * ```ts
   * const php = PHP.load('7.4', {
   * 	requestHandler: {
   * 		documentRoot: "/www"
   * 	}
   * })
   * php.writeFile("/www/index.php", `<?php echo file_get_contents("php://input");`);
   * const result = await php.request({
   * 	method: "GET",
   * 	headers: {
   * 		"Content-Type": "text/plain"
   * 	},
   * 	body: "Hello world!",
   * 	path: "/www/index.php"
   * });
   * // result.text === "Hello world!"
   * ```
   *
   * The `request()` method cannot be used in conjunction with `cli()`.
   *
   * @example
   * ```js
   * const output = await php.request({
   * 	method: 'GET',
   * 	url: '/index.php',
   * 	headers: {
   * 		'X-foo': 'bar',
   * 	},
   * 	body: {
   * 		foo: 'bar',
   * 	},
   * });
   * console.log(output.stdout); // "Hello world!"
   * ```
   *
   * @param  request - PHP Request data.
   */
  async request(e) {
    const r = looksLikeAbsoluteUrl(e.url), s = new URL(
      // Remove the hash part of the URL as it's not meant for the server.
      e.url.split("#")[0],
      r ? void 0 : DEFAULT_BASE_URL
    ), n = f(this, S, Z).call(this, s), i = await this.getPrimaryPhp();
    let o = joinPaths(
      u(this, g),
      /**
       * Turn a URL such as `https://playground/scope:my-site/wp-admin/index.php`
       * into a site-relative path, such as `/wp-admin/index.php`.
       */
      removePathPrefix(
        /**
         * URL.pathname returns a URL-encoded path. We need to decode it
         * before using it as a filesystem path.
         */
        decodeURIComponent(n.pathname),
        u(this, E)
      )
    );
    if (i.isDir(o)) {
      if (!o.endsWith("/"))
        return new PHPResponse(
          301,
          { Location: [`${n.pathname}/`] },
          new Uint8Array(0)
        );
      for (const a of ["index.php", "index.html"]) {
        const c = joinPaths(o, a);
        if (i.isFile(c)) {
          o = c, n.pathname = joinPaths(
            n.pathname,
            a
          );
          break;
        }
      }
    }
    if (!i.isFile(o)) {
      let a = n.pathname;
      for (; a.startsWith("/") && a !== dirname(a); ) {
        a = dirname(a);
        const c = joinPaths(u(this, g), a);
        if (i.isFile(c) && // Only run partial path resolution for PHP files.
        c.endsWith(".php")) {
          o = joinPaths(u(this, g), a);
          break;
        }
      }
    }
    if (!i.isFile(o)) {
      const a = this.getFileNotFoundAction(
        n.pathname
      );
      switch (a.type) {
        case "response":
          return a.response;
        case "internal-redirect":
          o = joinPaths(u(this, g), a.uri);
          break;
        case "404":
          return PHPResponse.forHttpCode(404);
        default:
          throw new Error(
            `Unsupported file-not-found action type: '${a.type}'`
          );
      }
    }
    if (i.isFile(o))
      if (o.endsWith(".php")) {
        const a = await f(this, S, te).call(this, e, s, n, o);
        return a.ok() && a.exitCode !== 0 ? new PHPResponse(
          500,
          a.headers,
          a.bytes,
          a.errors,
          a.exitCode
        ) : a;
      } else
        return f(this, S, ee).call(this, i, o);
    else
      return PHPResponse.forHttpCode(404);
  }
  /**
   * Computes the essential $_SERVER entries for a request.
   *
   * php_wasm.c sets some defaults, assuming it runs as a CLI script.
   * This function overrides them with the values correct in the request
   * context.
   *
   * @TODO: Consolidate the $_SERVER setting logic into a single place instead
   *        of splitting it between the C SAPI and the TypeScript code. The PHP
   *        class has a `.cli()` method that could take care of the CLI-specific
   *        $_SERVER values.
   *
   * Path and URL-related $_SERVER entries are theoretically documented
   * at https://www.php.net/manual/en/reserved.variables.server.php,
   * but that page is not very helpful in practice. Here are tables derived
   * by interacting with PHP servers:
   *
   * ## PHP Dev Server
   *
   * Setup:
   *   – `/home/adam/subdir/script.php` file contains `<?php phpinfo(); ?>`
   *   – `php -S 127.0.0.1:8041` running in `/home/adam` directory
   *   – A request is sent to `http://127.0.0.1:8041/subdir/script.php/b.php/c.php`
   *
   * Results:
   *
   * $_SERVER['REQUEST_URI']    | `/subdir/script.php/b.php/c.php`
   * $_SERVER['SCRIPT_NAME']    | `/subdir/script.php`
   * $_SERVER['SCRIPT_FILENAME']| `/home/adam/subdir/script.php`
   * $_SERVER['PATH_INFO']      | `/b.php/c.php`
   * $_SERVER['PHP_SELF']       | `/subdir/script.php/b.php/c.php`
   *
   * ## Apache – rewriting rules
   *
   * Setup:
   *   – `/var/www/html/subdir/script.php` file contains `<?php phpinfo(); ?>`
   *   – Apache is listening on port 8041
   *   – The document root is `/var/www/html`
   *   – A request is sent to `http://127.0.0.1:8041/api/v1/user/123`
   *
   * .htaccess file:
   *
   * ```apache
   * RewriteEngine On
   * RewriteRule ^api/v1/user/([0-9]+)$ /subdir/script.php?endpoint=user&id=$1 [L,QSA]
   * ```
   *
   * Results:
   *
   * ```
   * $_SERVER['REQUEST_URI']             | /api/v1/user/123
   * $_SERVER['SCRIPT_NAME']             | /subdir/script.php
   * $_SERVER['SCRIPT_FILENAME']         | /var/www/html/subdir/script.php
   * $_SERVER['PATH_INFO']               | (key not set)
   * $_SERVER['PHP_SELF']                | /subdir/script.php
   * $_SERVER['QUERY_STRING']            | endpoint=user&id=123
   * $_SERVER['REDIRECT_STATUS']         | 200
   * $_SERVER['REDIRECT_URL']            | /api/v1/user/123
   * $_SERVER['REDIRECT_QUERY_STRING']   | endpoint=user&id=123
   * === $_GET Variables ===
   * $_GET['endpoint']                   | user
   * $_GET['id']                         | 123
   * ```
   *
   * ## Apache – vanilla request
   *
   * Setup:
   *    – The same as above.
   *    – A request sent http://localhost:8041/subdir/script.php?param=value
   *
   * Results:
   *
   * ```
   * $_SERVER['REQUEST_URI']     | /subdir/script.php?param=value
   * $_SERVER['SCRIPT_NAME']     | /subdir/script.php
   * $_SERVER['SCRIPT_FILENAME'] | /var/www/html/subdir/script.php
   * $_SERVER['PATH_INFO']       | (key not set)
   * $_SERVER['PHP_SELF']        | /subdir/script.php
   * $_SERVER['REDIRECT_URL']    | (key not set)
   * $_SERVER['REDIRECT_STATUS'] | (key not set)
   * $_SERVER['QUERY_STRING']    | param=value
   * $_SERVER['REQUEST_METHOD']  | GET
   * $_SERVER['DOCUMENT_ROOT']   | /var/www/html
   *
   * === $_GET Variables ===
   * $_GET['param']              | value
   * ```
   */
  prepare_$_SERVER_superglobal(e, r, s) {
    const n = {
      REMOTE_ADDR: "127.0.0.1",
      DOCUMENT_ROOT: u(this, g),
      HTTPS: u(this, N).startsWith("https://") ? "on" : ""
    };
    return n.REQUEST_URI = e.pathname + e.search, s.startsWith(u(this, g)) && (n.SCRIPT_NAME = s.substring(
      u(this, g).length
    ), n.PHP_SELF = r.pathname, n.REQUEST_URI.startsWith(n.SCRIPT_NAME) && (n.PATH_INFO = n.REQUEST_URI.substring(
      n.SCRIPT_NAME.length
    ), n.PATH_INFO.includes("?") && (n.PATH_INFO = n.PATH_INFO.substring(
      0,
      n.PATH_INFO.indexOf("?")
    )))), n.QUERY_STRING = r.search.substring(1), n;
  }
  async [Symbol.asyncDispose]() {
    await this.instanceManager[Symbol.asyncDispose]();
  }
}
g = new WeakMap(), I = new WeakMap(), L = new WeakMap(), C = new WeakMap(), A = new WeakMap(), E = new WeakMap(), N = new WeakMap(), R = new WeakMap(), S = new WeakSet(), /**
 * Apply the rewrite rules to the original request URL.
 *
 * @param originalRequestUrl - The original request URL.
 * @returns The rewritten request URL.
 */
Z = function(e) {
  const r = removePathPrefix(
    decodeURIComponent(e.pathname),
    u(this, E)
  ), s = applyRewriteRules(
    r,
    this.rewriteRules
  ), n = new URL(
    joinPaths(u(this, E), s),
    e.toString()
  );
  for (const [i, o] of e.searchParams.entries())
    n.searchParams.append(i, o);
  return n;
}, /**
 * Serves a static file from the PHP filesystem.
 *
 * @param  fsPath - Absolute path of the static file to serve.
 * @returns The response.
 */
ee = function(e, r) {
  const s = e.readFileAsBuffer(r);
  return new PHPResponse(
    200,
    {
      "content-length": [`${s.byteLength}`],
      // @TODO: Infer the content-type from the arrayBuffer instead of the
      // file path. The code below won't return the correct mime-type if the
      // extension was tampered with.
      "content-type": [inferMimeType(r)],
      "accept-ranges": ["bytes"],
      "cache-control": ["public, max-age=0"]
    },
    s
  );
}, te = async function(e, r, s, n) {
  let i;
  try {
    i = await this.instanceManager.acquirePHPInstance({
      considerPrimary: !0
    });
  } catch (o) {
    return o instanceof MaxPhpInstancesError ? PHPResponse.forHttpCode(502) : PHPResponse.forHttpCode(500);
  }
  try {
    return await f(this, S, re).call(this, i.php, e, r, s, n);
  } finally {
    i.reap();
  }
}, re = async function(e, r, s, n, i) {
  let o = "GET";
  const a = {
    host: u(this, A),
    ...normalizeHeaders(r.headers || {})
  };
  u(this, R) && (a.cookie = u(this, R).getCookieRequestHeader());
  let c = r.body;
  if (typeof c == "object" && !(c instanceof Uint8Array)) {
    o = "POST";
    const { bytes: l, contentType: p } = await encodeAsMultipart(c);
    c = l, a["content-type"] = p;
  }
  try {
    const l = await e.run({
      relativeUri: ensurePathPrefix(
        toRelativeUrl(new URL(n.toString())),
        u(this, E)
      ),
      protocol: u(this, I),
      method: r.method || o,
      $_SERVER: this.prepare_$_SERVER_superglobal(
        s,
        n,
        i
      ),
      body: c,
      scriptPath: i,
      headers: a
    });
    return u(this, R) && u(this, R).rememberCookiesFromResponseHeaders(
      l.headers
    ), l;
  } catch (l) {
    const p = l;
    if (p != null && p.response)
      return p.response;
    throw l;
  }
};
function inferMimeType(t) {
  const e = t.split(".").pop();
  return mimeTypes[e] || mimeTypes._default;
}
function applyRewriteRules(t, e) {
  for (const r of e)
    if (new RegExp(r.match).test(t)) {
      t = t.replace(r.match, r.replacement);
      break;
    }
  return t;
}
function looksLikeAbsoluteUrl(t) {
  try {
    return new URL(t), !0;
  } catch {
    return !1;
  }
}
function rotatePHPRuntime({
  php: t,
  recreateRuntime: e,
  maxRequests: r = 400
}) {
  return t.enableRuntimeRotation({
    recreateRuntime: e,
    maxRequests: r
  });
}
async function writeFiles(t, e, r, { rmRoot: s = !1 } = {}) {
  s && await t.isDir(e) && await t.rmdir(e, { recursive: !0 });
  for (const [n, i] of Object.entries(r)) {
    const o = joinPaths(e, n);
    await t.fileExists(dirname(o)) || await t.mkdir(dirname(o)), i instanceof Uint8Array || typeof i == "string" ? await t.writeFile(o, i) : await writeFiles(t, o, i);
  }
}
function proxyFileSystem(t, e, r) {
  const s = Object.getOwnPropertySymbols(t)[0];
  for (const n of r)
    e.fileExists(n) || e.mkdir(n), t.fileExists(n) || t.mkdir(n), e[s].FS.mount(
      // @ts-ignore
      e[s].PROXYFS,
      {
        root: n,
        // @ts-ignore
        fs: t[s].FS
      },
      n
    );
}
function isPathToSharedFS(t, e) {
  var i;
  const r = Object.getOwnPropertySymbols(t)[0], n = t[r].FS.lookupPath(e, { noent_okay: !0 });
  return ((i = n == null ? void 0 : n.node) == null ? void 0 : i.isSharedFS) ?? !1;
}
function sandboxedSpawnHandlerFactory(t) {
  return createSpawnHandler(async function(e, r, s) {
    r.notifySpawn(), (e == null ? void 0 : e[0]) === "/bin/sh" && (e == null ? void 0 : e[1]) === "-c" && typeof e[2] == "string" && (e = splitShellCommand(e[2])), e[0] === "exec" && e.shift(), (e[0].endsWith(".php") || e[0].endsWith(".phar")) && e.unshift("php");
    const n = e[0].split("/").pop();
    if (e[0] === "/usr/bin/env" && e[1] === "stty" && e[2] === "size")
      r.stdout("18 140"), r.exit(0);
    else if (n === "tput" && e[1] === "cols")
      r.stdout("140"), r.exit(0);
    else if (n === "less") {
      r.on("stdin", (a) => {
        r.stdout(a);
      }), await new Promise((a) => {
        r.childProcess.stdin.on("finish", () => {
          a(!0);
        });
      }), r.exit(0);
      return;
    }
    if (!["php", "ls", "pwd"].includes(n ?? "")) {
      r.exit(127);
      return;
    }
    if (!t) {
      logger.warn(
        "Tried to spawn a PHP subprocess, but the sandboxed spawn handler was created without a getPHPInstance function."
      ), r.exit(127);
      return;
    }
    const { php: i, reap: o } = await t();
    try {
      s.cwd && await i.chdir(s.cwd);
      const a = await i.cwd();
      switch (n) {
        case "php": {
          const c = await i.cli(e, {
            env: {
              ...s.env,
              SCRIPT_PATH: e[1],
              // Set SHELL_PIPE to 0 to ensure WP-CLI formats
              // the output as ASCII tables.
              // @see https://github.com/wp-cli/wp-cli/issues/1102
              SHELL_PIPE: "0"
            }
          });
          c.stdout.pipeTo(
            new WritableStream({
              write(l) {
                r.stdout(l);
              }
            })
          ), c.stderr.pipeTo(
            new WritableStream({
              write(l) {
                r.stderr(l);
              }
            })
          ), r.exit(await c.exitCode);
          break;
        }
        case "ls": {
          const c = await i.listFiles(e[1] ?? a);
          for (const l of c)
            r.stdout(l + `
`);
          await new Promise((l) => setTimeout(l, 10)), r.exit(0);
          break;
        }
        case "pwd": {
          r.stdout(a + `
`), await new Promise((c) => setTimeout(c, 10)), r.exit(0);
          break;
        }
      }
    } catch (a) {
      throw r.exit(1), a;
    } finally {
      o();
    }
  });
}
function exposeSync(t, e, r, s = ["*"]) {
  return expose(t, e, s, r.afterResponseSent);
}
function createSyncProxy(t, e = [], r) {
  return new Proxy(() => {
  }, {
    get(s, n) {
      return n === "then" && !e.length ? {
        then: (i, o) => o(createSyncProxy(t, [], r))
      } : createSyncProxy(t, [...e, n], r);
    },
    set(s, n, i) {
      const [o, a] = toWireValue(i);
      return r.send(
        t,
        {
          type: MessageType.SET,
          path: [...e, n].map(String),
          value: o
        },
        a
      ), !0;
    },
    apply(s, n, i) {
      if (e.at(-1) === "bind")
        return createSyncProxy(t, e.slice(0, -1), r);
      const [a, c] = processArguments(i), l = r.send(
        t,
        {
          type: MessageType.APPLY,
          path: e.map(String),
          argumentList: a
        },
        c
      );
      return fromWireValue(l);
    },
    construct(s, n) {
      const [i, o] = processArguments(n), a = r.send(
        t,
        {
          type: MessageType.CONSTRUCT,
          path: e.map(String),
          argumentList: i
        },
        o
      );
      return fromWireValue(a);
    }
  });
}
function wrapSync(t, e) {
  return createSyncProxy(t, [], e);
}
class NodeSABSyncReceiveMessageTransport {
  static async create() {
    if (!NodeSABSyncReceiveMessageTransport.receiveMessageOnPort)
      try {
        NodeSABSyncReceiveMessageTransport.receiveMessageOnPort = require("worker_threads").receiveMessageOnPort;
      } catch {
        NodeSABSyncReceiveMessageTransport.receiveMessageOnPort = await import("worker_threads").then(
          (e) => e.receiveMessageOnPort
        );
      }
    return new NodeSABSyncReceiveMessageTransport();
  }
  constructor() {
  }
  afterResponseSent(e) {
    const { notifyBuffer: r } = e.data;
    if (r) {
      const s = new Int32Array(r);
      s[0] = 1, Atomics.notify(s, 0);
    }
  }
  send(e, r, s) {
    var l;
    const n = new SharedArrayBuffer(4), i = new Int32Array(n);
    i[0] = 0;
    const o = generateUUID();
    if (e.postMessage(
      { ...r, id: o, notifyBuffer: n },
      s
    ), Atomics.wait(i, 0, 0, 5e3) === "timed-out")
      throw new Error("Timeout waiting for response");
    for (; ; ) {
      const p = NodeSABSyncReceiveMessageTransport.receiveMessageOnPort(e);
      if (((l = p.message) == null ? void 0 : l.id) === o)
        return p.message;
      if (!p)
        throw new Error("No response received");
    }
  }
}
/**
 * Original, unmodified Comlink library from Google:
 *
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const proxyMarker = Symbol("Comlink.proxy"), createEndpoint = Symbol("Comlink.endpoint"), releaseProxy = Symbol("Comlink.releaseProxy"), finalizer = Symbol("Comlink.finalizer"), throwMarker = Symbol("Comlink.thrown");
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const WireValueType = {
  RAW: "RAW",
  HANDLER: "HANDLER"
}, MessageType = {
  GET: "GET",
  SET: "SET",
  APPLY: "APPLY",
  CONSTRUCT: "CONSTRUCT",
  ENDPOINT: "ENDPOINT",
  RELEASE: "RELEASE"
}, isObject = (t) => typeof t == "object" && t !== null || typeof t == "function", proxyTransferHandler = {
  canHandle: (t) => isObject(t) && t[proxyMarker],
  serialize(t) {
    const { port1: e, port2: r } = new MessageChannel();
    return expose(t, e), [r, [r]];
  },
  deserialize(t) {
    return t.start(), wrap(t);
  }
}, throwTransferHandler$1 = {
  canHandle: (t) => isObject(t) && throwMarker in t,
  serialize({ value: t }) {
    let e;
    return t instanceof Error ? e = {
      isError: !0,
      value: {
        message: t.message,
        name: t.name,
        stack: t.stack
      }
    } : e = { isError: !1, value: t }, [e, []];
  },
  deserialize(t) {
    throw t.isError ? Object.assign(
      new Error(t.value.message),
      t.value
    ) : t.value;
  }
}, transferHandlers = /* @__PURE__ */ new Map([
  ["proxy", proxyTransferHandler],
  ["throw", throwTransferHandler$1]
]);
function isAllowedOrigin(t, e) {
  for (const r of t)
    if (e === r || r === "*" || r instanceof RegExp && r.test(e))
      return !0;
  return !1;
}
function expose(t, e = globalThis, r = ["*"], s) {
  e.addEventListener("message", function n(i) {
    if (!i || !i.data)
      return;
    if (!isAllowedOrigin(r, i.origin)) {
      console.warn(`Invalid origin '${i.origin}' for comlink proxy`);
      return;
    }
    const { id: o, type: a, path: c } = {
      path: [],
      ...i.data
    }, l = (i.data.argumentList || []).map(fromWireValue);
    let p;
    try {
      const d = c.slice(0, -1).reduce((P, b) => P[b], t), m = c.reduce((P, b) => P[b], t);
      switch (a) {
        case MessageType.GET:
          p = m;
          break;
        case MessageType.SET:
          d[c.slice(-1)[0]] = fromWireValue(
            i.data.value
          ), p = !0;
          break;
        case MessageType.APPLY:
          p = m.apply(d, l);
          break;
        case MessageType.CONSTRUCT:
          {
            const P = new m(...l);
            p = proxy(P);
          }
          break;
        case MessageType.ENDPOINT:
          {
            const { port1: P, port2: b } = new MessageChannel();
            expose(t, b), p = transfer(P, [P]);
          }
          break;
        case MessageType.RELEASE:
          p = void 0;
          break;
        default:
          return;
      }
    } catch (d) {
      p = { value: d, [throwMarker]: 0 };
    }
    Promise.resolve(p).catch((d) => ({ value: d, [throwMarker]: 0 })).then((d) => {
      const [m, P] = toWireValue(d);
      e.postMessage({ ...m, id: o }, P), a === MessageType.RELEASE && (e.removeEventListener("message", n), closeEndPoint(e), finalizer in t && typeof t[finalizer] == "function" && t[finalizer]());
    }).catch(() => {
      const [d, m] = toWireValue({
        value: new TypeError("Unserializable return value"),
        [throwMarker]: 0
      });
      e.postMessage({ ...d, id: o }, m);
    }).finally(() => {
      s == null || s(i);
    });
  }), e.start && e.start();
}
function isMessagePort(t) {
  return t.constructor.name === "MessagePort";
}
function closeEndPoint(t) {
  isMessagePort(t) && t.close();
}
function wrap(t, e) {
  const r = /* @__PURE__ */ new Map();
  return t.addEventListener("message", function(n) {
    const { data: i } = n;
    if (!i || !i.id)
      return;
    const o = r.get(i.id);
    if (o)
      try {
        o(i);
      } finally {
        r.delete(i.id);
      }
  }), createProxy(t, r, [], e);
}
function throwIfProxyReleased(t) {
  if (t)
    throw new Error("Proxy has been released and is not useable");
}
function releaseEndpoint(t) {
  return requestResponseMessage(t, /* @__PURE__ */ new Map(), {
    type: MessageType.RELEASE
  }).then(() => {
    closeEndPoint(t);
  });
}
const proxyCounter = /* @__PURE__ */ new WeakMap(), proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((t) => {
  const e = (proxyCounter.get(t) || 0) - 1;
  proxyCounter.set(t, e), e === 0 && releaseEndpoint(t);
});
function registerProxy(t, e) {
  const r = (proxyCounter.get(e) || 0) + 1;
  proxyCounter.set(e, r), proxyFinalizers && proxyFinalizers.register(t, e, t);
}
function unregisterProxy(t) {
  proxyFinalizers && proxyFinalizers.unregister(t);
}
function createProxy(t, e, r = [], s = function() {
}) {
  let n = !1;
  const i = new Proxy(s, {
    get(o, a) {
      if (throwIfProxyReleased(n), a === releaseProxy)
        return () => {
          unregisterProxy(i), releaseEndpoint(t), e.clear(), n = !0;
        };
      if (a === "then") {
        if (r.length === 0)
          return { then: () => i };
        const c = requestResponseMessage(t, e, {
          type: MessageType.GET,
          path: r.map((l) => l.toString())
        }).then(fromWireValue);
        return c.then.bind(c);
      }
      return createProxy(t, e, [...r, a]);
    },
    set(o, a, c) {
      throwIfProxyReleased(n);
      const [l, p] = toWireValue(c);
      return requestResponseMessage(
        t,
        e,
        {
          type: MessageType.SET,
          path: [...r, a].map((d) => d.toString()),
          value: l
        },
        p
      ).then(fromWireValue);
    },
    apply(o, a, c) {
      throwIfProxyReleased(n);
      const l = r[r.length - 1];
      if (l === createEndpoint)
        return requestResponseMessage(t, e, {
          type: MessageType.ENDPOINT
        }).then(fromWireValue);
      if (l === "bind")
        return createProxy(t, e, r.slice(0, -1));
      const [p, d] = processArguments(c);
      return requestResponseMessage(
        t,
        e,
        {
          type: MessageType.APPLY,
          path: r.map((m) => m.toString()),
          argumentList: p
        },
        d
      ).then(fromWireValue);
    },
    construct(o, a) {
      throwIfProxyReleased(n);
      const [c, l] = processArguments(a);
      return requestResponseMessage(
        t,
        e,
        {
          type: MessageType.CONSTRUCT,
          path: r.map((p) => p.toString()),
          argumentList: c
        },
        l
      ).then(fromWireValue);
    }
  });
  return registerProxy(i, t), i;
}
function myFlat(t) {
  return Array.prototype.concat.apply([], t);
}
function processArguments(t) {
  const e = t.map(toWireValue);
  return [e.map((r) => r[0]), myFlat(e.map((r) => r[1]))];
}
const transferCache = /* @__PURE__ */ new WeakMap();
function transfer(t, e) {
  return transferCache.set(t, e), t;
}
function proxy(t) {
  return Object.assign(t, { [proxyMarker]: !0 });
}
function windowEndpoint(t, e = globalThis, r = "*") {
  return {
    postMessage: (s, n) => t.postMessage(s, r, n),
    addEventListener: e.addEventListener.bind(e),
    removeEventListener: e.removeEventListener.bind(e)
  };
}
function toWireValue(t) {
  for (const [e, r] of transferHandlers)
    if (r.canHandle(t)) {
      const [s, n] = r.serialize(t);
      return [
        {
          type: WireValueType.HANDLER,
          name: e,
          value: s
        },
        n
      ];
    }
  return [
    {
      type: WireValueType.RAW,
      value: t
    },
    transferCache.get(t) || []
  ];
}
function fromWireValue(t) {
  switch (t.type) {
    case WireValueType.HANDLER:
      return transferHandlers.get(t.name).deserialize(t.value);
    case WireValueType.RAW:
      return t.value;
  }
}
function requestResponseMessage(t, e, r, s) {
  return new Promise((n) => {
    const i = generateUUID();
    e.set(i, n), t.start && t.start(), t.postMessage({ id: i, ...r }, s);
  });
}
function generateUUID() {
  return new Array(4).fill(0).map(
    () => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)
  ).join("-");
}
function nodeEndpoint(t) {
  const e = /* @__PURE__ */ new WeakMap();
  return {
    postMessage: t.postMessage.bind(t),
    addEventListener: (r, s) => {
      const n = (i) => {
        "handleEvent" in s ? s.handleEvent({ data: i }) : s({ data: i });
      };
      t.on("message", n), e.set(s, n);
    },
    removeEventListener: (r, s) => {
      const n = e.get(s);
      n && (t.off("message", n), e.delete(s));
    },
    start: t.start && t.start.bind(t)
  };
}
const list = [
  // Native ES errors https://262.ecma-international.org/12.0/#sec-well-known-intrinsic-objects
  Error,
  EvalError,
  RangeError,
  ReferenceError,
  SyntaxError,
  TypeError,
  URIError,
  AggregateError,
  // Built-in errors
  globalThis.DOMException,
  // Node-specific errors
  // https://nodejs.org/api/errors.html
  globalThis.AssertionError,
  globalThis.SystemError
].filter(Boolean).map((t) => [t.name, t]), errorConstructors = new Map(list);
class NonError extends Error {
  constructor(e) {
    super(NonError._prepareSuperMessage(e)), this.name = "NonError";
  }
  static _prepareSuperMessage(e) {
    try {
      return JSON.stringify(e);
    } catch {
      return String(e);
    }
  }
}
const errorProperties = [
  {
    property: "name",
    enumerable: !1
  },
  {
    property: "message",
    enumerable: !1
  },
  {
    property: "stack",
    enumerable: !1
  },
  {
    property: "code",
    enumerable: !0
  },
  {
    property: "cause",
    enumerable: !1
  },
  {
    property: "errors",
    enumerable: !1
  }
], toJsonWasCalled = /* @__PURE__ */ new WeakSet(), toJSON = (t) => {
  toJsonWasCalled.add(t);
  const e = t.toJSON();
  return toJsonWasCalled.delete(t), e;
}, newError = (t) => {
  const e = errorConstructors.get(t) ?? Error;
  return e === AggregateError ? new e([]) : new e();
}, destroyCircular = ({
  from: t,
  seen: e,
  to: r,
  forceEnumerable: s,
  maxDepth: n,
  depth: i,
  useToJSON: o,
  serialize: a
}) => {
  if (r || (Array.isArray(t) ? r = [] : !a && isErrorLike(t) ? r = newError(t.name) : r = {}), e.push(t), i >= n)
    return r;
  if (o && typeof t.toJSON == "function" && !toJsonWasCalled.has(t))
    return toJSON(t);
  const c = (l) => destroyCircular({
    from: l,
    seen: [...e],
    forceEnumerable: s,
    maxDepth: n,
    depth: i,
    useToJSON: o,
    serialize: a
  });
  for (const [l, p] of Object.entries(t)) {
    if (p && p instanceof Uint8Array && p.constructor.name === "Buffer") {
      r[l] = "[object Buffer]";
      continue;
    }
    if (p !== null && typeof p == "object" && typeof p.pipe == "function") {
      r[l] = "[object Stream]";
      continue;
    }
    if (typeof p != "function") {
      if (!p || typeof p != "object") {
        try {
          r[l] = p;
        } catch {
        }
        continue;
      }
      if (!e.includes(t[l])) {
        i++, r[l] = c(t[l]);
        continue;
      }
      r[l] = "[Circular]";
    }
  }
  if (a || r instanceof Error)
    for (const { property: l, enumerable: p } of errorProperties)
      t[l] !== void 0 && t[l] !== null && Object.defineProperty(r, l, {
        value: isErrorLike(t[l]) || Array.isArray(t[l]) ? c(t[l]) : t[l],
        enumerable: s ? !0 : p,
        configurable: !0,
        writable: !0
      });
  return r;
};
function serializeError(t, e = {}) {
  const { maxDepth: r = Number.POSITIVE_INFINITY, useToJSON: s = !0 } = e;
  return typeof t == "object" && t !== null ? destroyCircular({
    from: t,
    seen: [],
    forceEnumerable: !0,
    maxDepth: r,
    depth: 0,
    useToJSON: s,
    serialize: !0
  }) : typeof t == "function" ? `[Function: ${t.name || "anonymous"}]` : t;
}
function deserializeError(t, e = {}) {
  const { maxDepth: r = Number.POSITIVE_INFINITY } = e;
  return t instanceof Error ? t : isMinimumViableSerializedError(t) ? destroyCircular({
    from: t,
    seen: [],
    to: newError(t.name),
    maxDepth: r,
    depth: 0,
    serialize: !1
  }) : new NonError(t);
}
function isErrorLike(t) {
  return !!t && typeof t == "object" && typeof t.name == "string" && typeof t.message == "string" && typeof t.stack == "string";
}
function isMinimumViableSerializedError(t) {
  return !!t && typeof t == "object" && typeof t.message == "string" && !Array.isArray(t);
}
async function consumeAPISync(t) {
  setupTransferHandlers();
  const e = await NodeSABSyncReceiveMessageTransport.create();
  return wrapSync(t, e);
}
function consumeAPI(t, e = void 0) {
  setupTransferHandlers();
  let r;
  import.meta.url.startsWith("file://") ? r = nodeEndpoint(t) : r = t instanceof Worker ? t : windowEndpoint(t, e);
  const n = wrap(r), i = proxyClone(n);
  return new Proxy(i, {
    get: (o, a) => a === "isConnected" ? async () => {
      for (; ; )
        try {
          await runWithTimeout(n.isConnected(), 200);
          break;
        } catch {
        }
    } : n[a]
  });
}
async function runWithTimeout(t, e) {
  return new Promise((r, s) => {
    setTimeout(s, e), t.then(r);
  });
}
function exposeAPI(t, e, r) {
  const { setReady: s, setFailed: n, exposedApi: i } = prepareForExpose(
    t,
    e
  );
  let o;
  return r ? o = nodeEndpoint(r) : o = typeof window < "u" ? windowEndpoint(self.parent) : void 0, expose(i, o), [s, n, i];
}
async function exposeSyncAPI(t, e) {
  const { setReady: r, setFailed: s, exposedApi: n } = prepareForExpose(t), i = await NodeSABSyncReceiveMessageTransport.create(), o = nodeEndpoint(e);
  return exposeSync(n, o, i), [r, s, n];
}
function prepareForExpose(t, e) {
  setupTransferHandlers();
  const r = Promise.resolve();
  let s, n;
  const i = new Promise((c, l) => {
    s = c, n = l;
  }), o = proxyClone(t), a = new Proxy(o, {
    get: (c, l) => l === "isConnected" ? () => r : l === "isReady" ? () => i : l in c ? c[l] : e == null ? void 0 : e[l]
  });
  return { setReady: s, setFailed: n, exposedApi: a };
}
let isTransferHandlersSetup = !1;
function setupTransferHandlers() {
  if (isTransferHandlersSetup)
    return;
  isTransferHandlersSetup = !0, transferHandlers.set("EVENT", {
    canHandle: (r) => r instanceof CustomEvent,
    serialize: (r) => [
      {
        detail: r.detail
      },
      []
    ],
    deserialize: (r) => r
  }), transferHandlers.set("FUNCTION", {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
    canHandle: (r) => typeof r == "function",
    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
    serialize(r) {
      const { port1: s, port2: n } = new MessageChannel();
      return expose(r, s), [n, [n]];
    },
    deserialize(r) {
      return r.start(), wrap(r);
    }
  }), transferHandlers.set("MESSAGE_PORT", {
    canHandle: (r) => r instanceof MessagePort,
    serialize(r) {
      return [r, [r]];
    },
    deserialize(r) {
      return r;
    }
  }), transferHandlers.set("PHPResponse", {
    canHandle: (r) => typeof r == "object" && r !== null && "headers" in r && "bytes" in r && "errors" in r && "exitCode" in r && "httpStatusCode" in r,
    serialize(r) {
      const s = r.toRawData(), n = [];
      return s.bytes.buffer.byteLength > 0 && n.push(s.bytes.buffer), [s, n];
    },
    deserialize(r) {
      return PHPResponse.fromRawData(r);
    }
  });
  const t = transferHandlers.get("throw"), e = t == null ? void 0 : t.serialize;
  t.serialize = ({ value: r }) => {
    const s = e({ value: r });
    return r.response && (s[0].value.response = r.response), r.source && (s[0].value.source = r.source), s;
  }, transferHandlers.set("StreamedPHPResponse", {
    canHandle: (r) => r instanceof StreamedPHPResponse,
    serialize(r) {
      const s = supportsTransferableStreams(), n = promiseToPort(r.exitCode);
      if (s)
        return [{
          __type: "StreamedPHPResponse",
          headers: r.headersStream,
          stdout: r.stdout,
          stderr: r.stderr,
          exitCodePort: n
        }, [n]];
      const i = streamToPort(r.headersStream), o = streamToPort(r.stdout), a = streamToPort(r.stderr);
      return [
        {
          __type: "StreamedPHPResponse",
          headersPort: i,
          stdoutPort: o,
          stderrPort: a,
          exitCodePort: n
        },
        [i, o, a, n]
      ];
    },
    deserialize(r) {
      if (r.headers && r.stdout && r.stderr) {
        const a = portToPromise(
          r.exitCodePort
        );
        return new StreamedPHPResponse(
          r.headers,
          r.stdout,
          r.stderr,
          a
        );
      }
      const s = portToStream(r.headersPort), n = portToStream(r.stdoutPort), i = portToStream(r.stderrPort), o = portToPromise(r.exitCodePort);
      return new StreamedPHPResponse(s, n, i, o);
    }
  });
}
function supportsTransferableStreams() {
  try {
    if (typeof ReadableStream > "u") return !1;
    const { port1: t } = new MessageChannel(), e = new ReadableStream();
    t.postMessage(e);
    try {
      t.close();
    } catch {
    }
    return !0;
  } catch {
    return !1;
  }
}
function streamToPort(t) {
  const { port1: e, port2: r } = new MessageChannel();
  return (async () => {
    const s = t.getReader();
    try {
      for (; ; ) {
        const { done: n, value: i } = await s.read();
        if (n) {
          try {
            e.postMessage({ t: "close" });
          } catch {
          }
          try {
            e.close();
          } catch {
          }
          break;
        }
        if (i) {
          const o = i.byteOffset === 0 && i.byteLength === i.buffer.byteLength ? i : i.slice(), a = o.buffer;
          try {
            e.postMessage({ t: "chunk", b: a }, [
              a
            ]);
          } catch {
            e.postMessage({
              t: "chunk",
              b: o.buffer.slice(0)
            });
          }
        }
      }
    } catch (n) {
      try {
        e.postMessage({ t: "error", m: (n == null ? void 0 : n.message) || String(n) });
      } catch {
      }
    } finally {
      try {
        e.close();
      } catch {
      }
    }
  })(), r;
}
function portToStream(t) {
  return new ReadableStream({
    start(e) {
      const r = (n) => {
        const i = n.data;
        if (i)
          switch (i.t) {
            case "chunk":
              e.enqueue(new Uint8Array(i.b));
              break;
            case "close":
              e.close(), s();
              break;
            case "error":
              e.error(new Error(i.m || "Stream error")), s();
              break;
          }
      }, s = () => {
        var n;
        try {
          (n = t.removeEventListener) == null || n.call(t, "message", r);
        } catch {
        }
        try {
          t.onmessage = null;
        } catch {
        }
        try {
          t.close();
        } catch {
        }
      };
      t.addEventListener ? t.addEventListener("message", r) : t.on ? t.on(
        "message",
        (n) => r({ data: n })
      ) : t.onmessage = r, typeof t.start == "function" && t.start();
    },
    cancel() {
      try {
        t.close();
      } catch {
      }
    }
  });
}
function promiseToPort(t) {
  const { port1: e, port2: r } = new MessageChannel();
  return t.then((s) => {
    try {
      e.postMessage({ t: "resolve", v: s });
    } catch {
    }
  }).catch((s) => {
    try {
      e.postMessage({
        t: "reject",
        m: (s == null ? void 0 : s.message) || String(s)
      });
    } catch {
    }
  }).finally(() => {
    try {
      e.close();
    } catch {
    }
  }), r;
}
function portToPromise(t) {
  return new Promise((e, r) => {
    const s = (i) => {
      const o = i.data;
      o && (o.t === "resolve" ? (n(), e(o.v)) : o.t === "reject" && (n(), r(new Error(o.m || ""))));
    }, n = () => {
      var i;
      try {
        (i = t.removeEventListener) == null || i.call(t, "message", s);
      } catch {
      }
      try {
        t.onmessage = null;
      } catch {
      }
      try {
        t.close();
      } catch {
      }
    };
    t.addEventListener ? t.addEventListener("message", s) : t.on ? t.on(
      "message",
      (i) => s({ data: i })
    ) : t.onmessage = s, typeof t.start == "function" && t.start();
  });
}
const throwTransferHandler = transferHandlers.get(
  "throw"
), throwTransferHandlerCustom = {
  canHandle: throwTransferHandler.canHandle,
  serialize: ({ value: t }) => {
    let e;
    return t instanceof Error ? (e = {
      isError: !0,
      value: serializeError(t)
    }, e.value.originalErrorClassName = t.constructor.name) : e = { isError: !1, value: t }, [e, []];
  },
  deserialize: (t) => {
    if (t.isError) {
      const e = deserializeError(t.value), r = new Error("Comlink method call failed");
      let s = e;
      for (; s.cause; )
        s = s.cause;
      throw s.cause = r, e;
    }
    throw t.value;
  }
};
transferHandlers.set("throw", throwTransferHandlerCustom);
function proxyClone(t) {
  return new Proxy(t, {
    get(e, r) {
      switch (typeof e[r]) {
        case "function":
          return (...s) => e[r](...s);
        case "object":
          return e[r] === null ? e[r] : proxyClone(e[r]);
        case "undefined":
        case "number":
        case "string":
          return e[r];
        default:
          return proxy(e[r]);
      }
    }
  });
}
export {
  DEFAULT_BASE_URL,
  FSHelpers,
  HttpCookieStore,
  LatestSupportedPHPVersion,
  PHP,
  PHPExecutionFailureError,
  PHPProcessManager,
  PHPRequestHandler,
  PHPResponse,
  PHPWorker,
  SinglePHPInstanceManager,
  StreamedPHPResponse,
  SupportedPHPVersions,
  SupportedPHPVersionsList,
  UnhandledRejectionsTarget,
  __private__dont__use,
  applyRewriteRules,
  consumeAPI,
  consumeAPISync,
  ensurePathPrefix,
  exposeAPI,
  exposeSyncAPI,
  getPhpIniEntries,
  inferMimeType,
  isExitCode,
  isPathToSharedFS,
  iteratePhpFiles as iterateFiles,
  loadPHPRuntime,
  popLoadedRuntime,
  prettyPrintFullStackTrace,
  printDebugDetails,
  printResponseDebugDetails,
  proxyFileSystem,
  removePathPrefix,
  rotatePHPRuntime,
  sandboxedSpawnHandlerFactory,
  setPhpIniEntries,
  toRelativeUrl,
  withPHPIniValues,
  writeFiles,
  writeFilesStreamToPhp
};
//# sourceMappingURL=index.js.map
