import { isURLScoped as m, setURLScope as g, getURLScope as p } from "@php-wasm/scopes";
const R = 25e3;
let w = 0;
function U(e, t, ...r) {
  const s = y();
  return e.postMessage(
    {
      ...t,
      requestId: s
    },
    ...r
  ), s;
}
function y() {
  return ++w;
}
function b(e, t, r = R) {
  return new Promise((s, c) => {
    const o = (i) => {
      i.data.type === "response" && i.data.requestId === t && (e.removeEventListener("message", o), clearTimeout(a), s(i.data.response));
    }, a = setTimeout(() => {
      c(new Error("Request timed out")), e.removeEventListener("message", o);
    }, r);
    e.addEventListener("message", o);
  });
}
function L(e, t) {
  return {
    type: "response",
    requestId: e,
    response: t
  };
}
async function A(e) {
  let t = new URL(e.request.url);
  if (!m(t))
    try {
      const n = new URL(e.request.referrer);
      t = g(t, p(n));
    } catch {
    }
  const r = e.request.headers.get("content-type"), s = e.request.method === "POST" ? new Uint8Array(await e.request.clone().arrayBuffer()) : void 0, c = {};
  for (const n of e.request.headers.entries())
    c[n[0]] = n[1];
  let o;
  try {
    const n = {
      method: "request",
      args: [
        {
          body: s,
          url: t.toString(),
          method: e.request.method,
          headers: {
            ...c,
            Host: t.host,
            // Safari and Firefox don't make the User-Agent header
            // available in the fetch event. Let's add it manually:
            "User-agent": self.navigator.userAgent,
            "Content-type": r
          }
        }
      ]
    }, u = p(t);
    if (u === null)
      throw new Error(
        `The URL ${t.toString()} is not scoped. This should not happen.`
      );
    const f = await S(n, u);
    if (o = await b(self, f), delete o.headers["x-frame-options"], o.headers["content-security-policy"]) {
      const l = o.headers["content-security-policy"].map(
        (d) => C(
          "frame-ancestors",
          d
        )
      ).filter((d) => d.trim().length > 0);
      l.length > 0 ? o.headers["content-security-policy"] = l : delete o.headers["content-security-policy"];
    }
  } catch (n) {
    throw console.error(n, { url: t.toString() }), n;
  }
  if (o.httpStatusCode >= 300 && o.httpStatusCode <= 399 && o.headers.location)
    return Response.redirect(
      new URL(o.headers.location[0], t.toString()),
      o.httpStatusCode
    );
  const i = [101, 103, 204, 205, 304].includes(
    o.httpStatusCode
  ) ? null : o.bytes;
  return new Response(i, {
    headers: o.headers,
    status: o.httpStatusCode
  });
}
async function S(e, t) {
  const r = y();
  for (const s of await self.clients.matchAll({
    // Sometimes the client that triggered the current fetch()
    // event is considered uncontrolled in Google Chrome. This
    // only happens on the first few fetches() after the initial
    // registration of the service worker.
    includeUncontrolled: !0
  }))
    s.postMessage({
      ...e,
      /**
       * Attach the scope with a URL starting with `/scope:` to this message.
       *
       * We need this mechanics because this worker broadcasts
       * events to all the listeners across all browser tabs. Scopes
       * helps WASM workers ignore requests meant for other WASM workers.
       */
      scope: t,
      requestId: r
    });
  return r;
}
async function h(e, t) {
  let r;
  return ["GET", "HEAD"].includes(e.method) || "body" in t ? r = void 0 : !e.bodyUsed && e.body ? r = e.body : r = await e.blob(), new Request(t.url || e.url, {
    body: r,
    method: e.method,
    headers: e.headers,
    referrer: e.referrer,
    referrerPolicy: e.referrerPolicy,
    mode: e.mode === "navigate" ? "same-origin" : e.mode,
    credentials: e.credentials,
    cache: e.cache,
    redirect: e.redirect,
    integrity: e.integrity,
    ...r && { duplex: "half" },
    ...t
  });
}
async function T(e) {
  if (!e.body)
    return [e, e];
  const [t, r] = e.body.tee();
  return [
    await h(e, { body: t, duplex: "half" }),
    await h(e, { body: r, duplex: "half" })
  ];
}
function x(e) {
  const t = {};
  return e.headers.forEach((r, s) => {
    t[s] = r;
  }), t;
}
function C(e, t) {
  const r = /^[\u{9}\u{A}\u{C}\u{D}\u{20}]+/u, s = /[\u{9}\u{A}\u{C}\u{D}\u{20}]+$/u, c = /[\u{9}\u{A}\u{C}\u{D}\u{20}]/u;
  return t.split(";").filter((o) => {
    const a = o.replace(r, "").replace(s, ""), [i] = a.split(
      c,
      // The directive name is the first token.
      1
    );
    return i.toLowerCase() !== e.toLowerCase();
  }).join(";");
}
export {
  b as awaitReply,
  S as broadcastMessageExpectReply,
  h as cloneRequest,
  A as convertFetchEventToPHPRequest,
  y as getNextRequestId,
  x as getRequestHeaders,
  U as postMessageExpectReply,
  C as removeContentSecurityPolicyDirective,
  L as responseTo,
  T as teeRequest
};
