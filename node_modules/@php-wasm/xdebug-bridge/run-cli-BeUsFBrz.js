import { strictEqual as ms, notStrictEqual as gs } from "assert";
import Ui, { resolve as le, dirname as qn, normalize as ys, relative as bs, extname as ws, basename as Es } from "path";
import { statSync as Xi, readdirSync as $i, readFileSync as Xe, writeFile as xs, lstatSync as Os } from "fs";
import { format as Wi, inspect as Is } from "util";
import { fileURLToPath as Cs } from "url";
import { WebSocketServer as Ds } from "ws";
import Ts from "net";
import { createHash as vs } from "crypto";
import _s from "timers";
const qi = function() {
  return typeof process < "u" && process.release?.name === "node" ? "NODE" : typeof window < "u" ? "WEB" : (
    // @ts-ignore
    typeof WorkerGlobalScope < "u" && // @ts-ignore
    self instanceof WorkerGlobalScope ? "WORKER" : "NODE"
  );
}();
if (qi === "NODE") {
  let a = function(e) {
    return new Promise(function(n, s) {
      e.onload = e.onerror = function(i) {
        e.onload = e.onerror = null, i.type === "load" ? n(e.result) : s(new Error("Failed to read the blob/file"));
      };
    });
  }, t = function() {
    const e = new Uint8Array([1, 2, 3, 4]), s = new File([e], "test").stream();
    try {
      return s.getReader({ mode: "byob" }), !0;
    } catch {
      return !1;
    }
  };
  if (typeof File > "u") {
    class e extends Blob {
      constructor(s, i, r) {
        super(s);
        let o;
        r?.lastModified && (o = /* @__PURE__ */ new Date()), (!o || isNaN(o.getFullYear())) && (o = /* @__PURE__ */ new Date()), this.lastModifiedDate = o, this.lastModified = o.getMilliseconds(), this.name = i || "";
      }
    }
    global.File = e;
  }
  typeof Blob.prototype.arrayBuffer > "u" && (Blob.prototype.arrayBuffer = function() {
    const n = new FileReader();
    return n.readAsArrayBuffer(this), a(n);
  }), typeof Blob.prototype.text > "u" && (Blob.prototype.text = function() {
    const n = new FileReader();
    return n.readAsText(this), a(n);
  }), (typeof Blob.prototype.stream > "u" || !t()) && (Blob.prototype.stream = function() {
    let e = 0;
    const n = this;
    return new ReadableStream({
      type: "bytes",
      // 0.5 MB seems like a reasonable chunk size, let's adjust
      // this if needed.
      autoAllocateChunkSize: 512 * 1024,
      async pull(s) {
        const i = s.byobRequest.view, o = await n.slice(
          e,
          e + i.byteLength
        ).arrayBuffer(), l = new Uint8Array(o);
        new Uint8Array(i.buffer).set(l);
        const E = l.byteLength;
        s.byobRequest.respond(E), e += E, e >= n.size && s.close();
      }
    });
  });
}
if (qi === "NODE" && typeof CustomEvent > "u") {
  class a extends Event {
    constructor(e, n = {}) {
      super(e, n), this.detail = n.detail;
    }
    initCustomEvent() {
    }
  }
  globalThis.CustomEvent = a;
}
const Ns = "playground-log", mr = (a, ...t) => {
  Pt.dispatchEvent(
    new CustomEvent(Ns, {
      detail: {
        log: a,
        args: t
      }
    })
  );
}, As = (a, ...t) => {
  switch (typeof a.message == "string" ? Reflect.set(a, "message", Hn(a.message)) : a.message.message && typeof a.message.message == "string" && Reflect.set(
    a.message,
    "message",
    Hn(a.message.message)
  ), a.severity) {
    case xt.Debug:
      console.debug(a.message, ...t);
      break;
    case xt.Info:
      console.info(a.message, ...t);
      break;
    case xt.Warn:
      console.warn(a.message, ...t);
      break;
    case xt.Error:
      console.error(a.message, ...t);
      break;
    case xt.Fatal:
      console.error(a.message, ...t);
      break;
    default:
      console.log(a.message, ...t);
  }
}, Ms = (a) => a instanceof Error ? [a.message, a.stack].join(`
`) : JSON.stringify(a, null, 2), Vi = [], gr = (a) => {
  Vi.push(a);
}, Vn = (a) => {
  if (a.raw === !0)
    gr(a.message);
  else {
    const t = Ss(
      typeof a.message == "object" ? Ms(a.message) : a.message,
      a.severity,
      a.prefix ?? ue.JS
    );
    gr(t);
  }
}, xt = {
  Fatal: { name: "fatal", level: 0 },
  Error: { name: "error", level: 1 },
  Warn: { name: "warn", level: 2 },
  Log: { name: "log", level: 3 },
  Info: { name: "info", level: 4 },
  Debug: { name: "debug", level: 5 }
}, ue = {
  JS: "JavaScript"
};
class Ps extends EventTarget {
  // constructor
  constructor(t = []) {
    super(), this.fatalErrorEvent = "playground-fatal-error", this.severity = xt.Info, this.handlers = t;
  }
  /**
   * Get all logs.
   * @returns string[]
   */
  getLogs() {
    return this.handlers.includes(Vn) ? [...Vi] : (this.error(`Logs aren't stored because the logToMemory handler isn't registered.
				If you're using a custom logger instance, make sure to register logToMemory handler.
			`), []);
  }
  /**
   * Log message with severity.
   *
   * @param log Log
   * @param args any
   */
  logMessage(t, ...e) {
    const n = {
      ...t,
      severity: t.severity ?? xt.Log
    };
    for (const s of this.handlers)
      n.severity.level <= this.severity.level && s(n, ...e);
  }
  /**
   * Filter message based on severity
   * @param severity LogSeverity
   */
  setSeverityFilterLevel(t) {
    this.severity = t;
  }
  /**
   * Log message
   *
   * @param message any
   * @param args any
   */
  log(t, ...e) {
    this.logMessage(
      {
        message: t,
        severity: xt.Log,
        prefix: ue.JS,
        raw: !1
      },
      ...e
    );
  }
  /**
   * Log debug message
   *
   * @param message any
   * @param args any
   */
  debug(t, ...e) {
    this.logMessage(
      {
        message: t,
        severity: xt.Debug,
        prefix: ue.JS,
        raw: !1
      },
      ...e
    );
  }
  /**
   * Log info message
   *
   * @param message any
   * @param args any
   */
  info(t, ...e) {
    this.logMessage(
      {
        message: t,
        severity: xt.Info,
        prefix: ue.JS,
        raw: !1
      },
      ...e
    );
  }
  /**
   * Log warning message
   *
   * @param message any
   * @param args any
   */
  warn(t, ...e) {
    this.logMessage(
      {
        message: t,
        severity: xt.Warn,
        prefix: ue.JS,
        raw: !1
      },
      ...e
    );
  }
  /**
   * Log error message
   *
   * @param message any
   * @param args any
   */
  error(t, ...e) {
    this.logMessage(
      {
        message: t,
        severity: xt.Error,
        prefix: ue.JS,
        raw: !1
      },
      ...e
    );
  }
}
const Ls = () => {
  try {
    if (process.env.NODE_ENV === "test")
      return [Vn, mr];
  } catch {
  }
  return [Vn, As, mr];
}, Pt = new Ps(Ls()), Hn = (a) => a.replace(/\t/g, ""), Ss = (a, t, e) => {
  const n = /* @__PURE__ */ new Date(), s = new Intl.DateTimeFormat("en-GB", {
    year: "numeric",
    month: "short",
    day: "2-digit",
    timeZone: "UTC"
  }).format(n).replace(/ /g, "-"), i = new Intl.DateTimeFormat("en-GB", {
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: !1,
    timeZone: "UTC",
    timeZoneName: "short"
  }).format(n), r = s + " " + i;
  return a = Hn(a), `[${r}] ${e} ${t.name}: ${a}`;
};
var it = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, kn = { exports: {} }, ce = typeof Reflect == "object" ? Reflect : null, yr = ce && typeof ce.apply == "function" ? ce.apply : function(t, e, n) {
  return Function.prototype.apply.call(t, e, n);
}, je;
ce && typeof ce.ownKeys == "function" ? je = ce.ownKeys : Object.getOwnPropertySymbols ? je = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : je = function(t) {
  return Object.getOwnPropertyNames(t);
};
function Fs(a) {
  console && console.warn && console.warn(a);
}
var Hi = Number.isNaN || function(t) {
  return t !== t;
};
function ct() {
  ct.init.call(this);
}
kn.exports = ct;
kn.exports.once = Us;
ct.EventEmitter = ct;
ct.prototype._events = void 0;
ct.prototype._eventsCount = 0;
ct.prototype._maxListeners = void 0;
var br = 10;
function $e(a) {
  if (typeof a != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof a);
}
Object.defineProperty(ct, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return br;
  },
  set: function(a) {
    if (typeof a != "number" || a < 0 || Hi(a))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + a + ".");
    br = a;
  }
});
ct.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
ct.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || Hi(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function Gi(a) {
  return a._maxListeners === void 0 ? ct.defaultMaxListeners : a._maxListeners;
}
ct.prototype.getMaxListeners = function() {
  return Gi(this);
};
ct.prototype.emit = function(t) {
  for (var e = [], n = 1; n < arguments.length; n++) e.push(arguments[n]);
  var s = t === "error", i = this._events;
  if (i !== void 0)
    s = s && i.error === void 0;
  else if (!s)
    return !1;
  if (s) {
    var r;
    if (e.length > 0 && (r = e[0]), r instanceof Error)
      throw r;
    var o = new Error("Unhandled error." + (r ? " (" + r.message + ")" : ""));
    throw o.context = r, o;
  }
  var l = i[t];
  if (l === void 0)
    return !1;
  if (typeof l == "function")
    yr(l, this, e);
  else
    for (var E = l.length, m = Qi(l, E), n = 0; n < E; ++n)
      yr(m[n], this, e);
  return !0;
};
function zi(a, t, e, n) {
  var s, i, r;
  if ($e(e), i = a._events, i === void 0 ? (i = a._events = /* @__PURE__ */ Object.create(null), a._eventsCount = 0) : (i.newListener !== void 0 && (a.emit(
    "newListener",
    t,
    e.listener ? e.listener : e
  ), i = a._events), r = i[t]), r === void 0)
    r = i[t] = e, ++a._eventsCount;
  else if (typeof r == "function" ? r = i[t] = n ? [e, r] : [r, e] : n ? r.unshift(e) : r.push(e), s = Gi(a), s > 0 && r.length > s && !r.warned) {
    r.warned = !0;
    var o = new Error("Possible EventEmitter memory leak detected. " + r.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    o.name = "MaxListenersExceededWarning", o.emitter = a, o.type = t, o.count = r.length, Fs(o);
  }
  return a;
}
ct.prototype.addListener = function(t, e) {
  return zi(this, t, e, !1);
};
ct.prototype.on = ct.prototype.addListener;
ct.prototype.prependListener = function(t, e) {
  return zi(this, t, e, !0);
};
function js() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function Yi(a, t, e) {
  var n = { fired: !1, wrapFn: void 0, target: a, type: t, listener: e }, s = js.bind(n);
  return s.listener = e, n.wrapFn = s, s;
}
ct.prototype.once = function(t, e) {
  return $e(e), this.on(t, Yi(this, t, e)), this;
};
ct.prototype.prependOnceListener = function(t, e) {
  return $e(e), this.prependListener(t, Yi(this, t, e)), this;
};
ct.prototype.removeListener = function(t, e) {
  var n, s, i, r, o;
  if ($e(e), s = this._events, s === void 0)
    return this;
  if (n = s[t], n === void 0)
    return this;
  if (n === e || n.listener === e)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete s[t], s.removeListener && this.emit("removeListener", t, n.listener || e));
  else if (typeof n != "function") {
    for (i = -1, r = n.length - 1; r >= 0; r--)
      if (n[r] === e || n[r].listener === e) {
        o = n[r].listener, i = r;
        break;
      }
    if (i < 0)
      return this;
    i === 0 ? n.shift() : Bs(n, i), n.length === 1 && (s[t] = n[0]), s.removeListener !== void 0 && this.emit("removeListener", t, o || e);
  }
  return this;
};
ct.prototype.off = ct.prototype.removeListener;
ct.prototype.removeAllListeners = function(t) {
  var e, n, s;
  if (n = this._events, n === void 0)
    return this;
  if (n.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[t]), this;
  if (arguments.length === 0) {
    var i = Object.keys(n), r;
    for (s = 0; s < i.length; ++s)
      r = i[s], r !== "removeListener" && this.removeAllListeners(r);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (e = n[t], typeof e == "function")
    this.removeListener(t, e);
  else if (e !== void 0)
    for (s = e.length - 1; s >= 0; s--)
      this.removeListener(t, e[s]);
  return this;
};
function ki(a, t, e) {
  var n = a._events;
  if (n === void 0)
    return [];
  var s = n[t];
  return s === void 0 ? [] : typeof s == "function" ? e ? [s.listener || s] : [s] : e ? Rs(s) : Qi(s, s.length);
}
ct.prototype.listeners = function(t) {
  return ki(this, t, !0);
};
ct.prototype.rawListeners = function(t) {
  return ki(this, t, !1);
};
ct.listenerCount = function(a, t) {
  return typeof a.listenerCount == "function" ? a.listenerCount(t) : Ki.call(a, t);
};
ct.prototype.listenerCount = Ki;
function Ki(a) {
  var t = this._events;
  if (t !== void 0) {
    var e = t[a];
    if (typeof e == "function")
      return 1;
    if (e !== void 0)
      return e.length;
  }
  return 0;
}
ct.prototype.eventNames = function() {
  return this._eventsCount > 0 ? je(this._events) : [];
};
function Qi(a, t) {
  for (var e = new Array(t), n = 0; n < t; ++n)
    e[n] = a[n];
  return e;
}
function Bs(a, t) {
  for (; t + 1 < a.length; t++)
    a[t] = a[t + 1];
  a.pop();
}
function Rs(a) {
  for (var t = new Array(a.length), e = 0; e < t.length; ++e)
    t[e] = a[e].listener || a[e];
  return t;
}
function Us(a, t) {
  return new Promise(function(e, n) {
    function s(r) {
      a.removeListener(t, i), n(r);
    }
    function i() {
      typeof a.removeListener == "function" && a.removeListener("error", s), e([].slice.call(arguments));
    }
    Ji(a, t, i, { once: !0 }), t !== "error" && Xs(a, s, { once: !0 });
  });
}
function Xs(a, t, e) {
  typeof a.on == "function" && Ji(a, "error", t, e);
}
function Ji(a, t, e, n) {
  if (typeof a.on == "function")
    n.once ? a.once(t, e) : a.on(t, e);
  else if (typeof a.addEventListener == "function")
    a.addEventListener(t, function s(i) {
      n.once && a.removeEventListener(t, s), e(i);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof a);
}
var Kn = kn.exports;
class $s extends Kn.EventEmitter {
  constructor(t = 9229) {
    super(), this.ws = null, this.connected = !1, this.buffer = [], this.wss = new Ds({ port: t }), this.wss.on("connection", (e) => {
      if (this.ws) {
        e.close();
        return;
      }
      this.ws = e, this.emit("clientConnected"), e.on("message", (n) => {
        Pt.debug(
          "\x1B[1;32m[CDP][received]\x1B[0m",
          n.toString()
        );
        let s;
        try {
          s = JSON.parse(n.toString());
        } catch {
          return;
        }
        this.connected ? this.emit("message", s) : this.buffer.push(s);
      }), e.on("close", () => {
        this.ws = null, this.emit("clientDisconnected");
      }), e.on("error", (n) => {
        this.emit("error", n);
      });
    }), this.on("newListener", (e) => {
      e === "message" && process.nextTick(() => {
        for (const n of this.buffer)
          this.emit("message", n);
        this.buffer = [], this.connected = !0;
      });
    });
  }
  sendMessage(t) {
    if (!this.ws || this.ws.readyState !== this.ws.OPEN)
      return;
    const e = JSON.stringify(t);
    Pt.debug("\x1B[1;32m[CDP][send]\x1B[0m", e), this.ws.send(e);
  }
  close() {
    this.wss.close();
  }
}
class Ws extends Kn.EventEmitter {
  constructor(t = 9003) {
    super(), this.socket = null, this.buffer = "", this.expectedLength = null, this.server = Ts.createServer(), this.server.on("connection", (e) => {
      if (this.socket) {
        e.destroy();
        return;
      }
      this.socket = e, e.setEncoding("utf8"), this.emit("connected"), e.on("data", (n) => this.onData(n.toString())), e.on("close", () => {
        this.socket = null, this.emit("disconnected");
      }), e.on("error", (n) => {
        this.emit("error", n);
      });
    }), this.server.listen(t);
  }
  onData(t) {
    for (Pt.debug("\x1B[1;32m[XDebug][received]]\x1B[0m", t), this.buffer += t; ; ) {
      if (this.expectedLength === null) {
        const e = this.buffer.indexOf("\0");
        if (e === -1)
          break;
        const n = this.buffer.substring(0, e), s = parseInt(n, 10);
        if (isNaN(s)) {
          this.buffer = "";
          break;
        }
        this.expectedLength = s, this.buffer = this.buffer.slice(e + 1);
      }
      if (this.expectedLength !== null && this.buffer.length >= this.expectedLength) {
        const e = this.buffer.substring(0, this.expectedLength);
        this.buffer = this.buffer.slice(this.expectedLength), this.buffer.startsWith("\0") && (this.buffer = this.buffer.slice(1));
        const n = e.trim();
        this.expectedLength = null, this.emit("message", n);
        continue;
      }
      break;
    }
  }
  sendCommand(t) {
    this.socket && (Pt.debug("\x1B[1;32m[XDebug][send]\x1B[0m", t), this.socket.write(t + "\0"));
  }
  close() {
    this.server.close();
  }
}
const qs = {
  right: ks,
  center: Ks
}, Vs = 0, Be = 1, Hs = 2, Re = 3;
class Gs {
  constructor(t) {
    var e;
    this.width = t.width, this.wrap = (e = t.wrap) !== null && e !== void 0 ? e : !0, this.rows = [];
  }
  span(...t) {
    const e = this.div(...t);
    e.span = !0;
  }
  resetOutput() {
    this.rows = [];
  }
  div(...t) {
    if (t.length === 0 && this.div(""), this.wrap && this.shouldApplyLayoutDSL(...t) && typeof t[0] == "string")
      return this.applyLayoutDSL(t[0]);
    const e = t.map((n) => typeof n == "string" ? this.colFromString(n) : n);
    return this.rows.push(e), e;
  }
  shouldApplyLayoutDSL(...t) {
    return t.length === 1 && typeof t[0] == "string" && /[\t\n]/.test(t[0]);
  }
  applyLayoutDSL(t) {
    const e = t.split(`
`).map((s) => s.split("	"));
    let n = 0;
    return e.forEach((s) => {
      s.length > 1 && Tt.stringWidth(s[0]) > n && (n = Math.min(Math.floor(this.width * 0.5), Tt.stringWidth(s[0])));
    }), e.forEach((s) => {
      this.div(...s.map((i, r) => ({
        text: i.trim(),
        padding: this.measurePadding(i),
        width: r === 0 && s.length > 1 ? n : void 0
      })));
    }), this.rows[this.rows.length - 1];
  }
  colFromString(t) {
    return {
      text: t,
      padding: this.measurePadding(t)
    };
  }
  measurePadding(t) {
    const e = Tt.stripAnsi(t);
    return [0, e.match(/\s*$/)[0].length, 0, e.match(/^\s*/)[0].length];
  }
  toString() {
    const t = [];
    return this.rows.forEach((e) => {
      this.rowToString(e, t);
    }), t.filter((e) => !e.hidden).map((e) => e.text).join(`
`);
  }
  rowToString(t, e) {
    return this.rasterize(t).forEach((n, s) => {
      let i = "";
      n.forEach((r, o) => {
        const { width: l } = t[o], E = this.negatePadding(t[o]);
        let m = r;
        if (E > Tt.stringWidth(r) && (m += " ".repeat(E - Tt.stringWidth(r))), t[o].align && t[o].align !== "left" && this.wrap) {
          const b = qs[t[o].align];
          m = b(m, E), Tt.stringWidth(m) < E && (m += " ".repeat((l || 0) - Tt.stringWidth(m) - 1));
        }
        const p = t[o].padding || [0, 0, 0, 0];
        p[Re] && (i += " ".repeat(p[Re])), i += wr(t[o], m, "| "), i += m, i += wr(t[o], m, " |"), p[Be] && (i += " ".repeat(p[Be])), s === 0 && e.length > 0 && (i = this.renderInline(i, e[e.length - 1]));
      }), e.push({
        text: i.replace(/ +$/, ""),
        span: t.span
      });
    }), e;
  }
  // if the full 'source' can render in
  // the target line, do so.
  renderInline(t, e) {
    const n = t.match(/^ */), s = n ? n[0].length : 0, i = e.text, r = Tt.stringWidth(i.trimRight());
    return e.span ? this.wrap ? s < r ? t : (e.hidden = !0, i.trimRight() + " ".repeat(s - r) + t.trimLeft()) : (e.hidden = !0, i + t) : t;
  }
  rasterize(t) {
    const e = [], n = this.columnWidths(t);
    let s;
    return t.forEach((i, r) => {
      i.width = n[r], this.wrap ? s = Tt.wrap(i.text, this.negatePadding(i), { hard: !0 }).split(`
`) : s = i.text.split(`
`), i.border && (s.unshift("." + "-".repeat(this.negatePadding(i) + 2) + "."), s.push("'" + "-".repeat(this.negatePadding(i) + 2) + "'")), i.padding && (s.unshift(...new Array(i.padding[Vs] || 0).fill("")), s.push(...new Array(i.padding[Hs] || 0).fill(""))), s.forEach((o, l) => {
        e[l] || e.push([]);
        const E = e[l];
        for (let m = 0; m < r; m++)
          E[m] === void 0 && E.push("");
        E.push(o);
      });
    }), e;
  }
  negatePadding(t) {
    let e = t.width || 0;
    return t.padding && (e -= (t.padding[Re] || 0) + (t.padding[Be] || 0)), t.border && (e -= 4), e;
  }
  columnWidths(t) {
    if (!this.wrap)
      return t.map((r) => r.width || Tt.stringWidth(r.text));
    let e = t.length, n = this.width;
    const s = t.map((r) => {
      if (r.width)
        return e--, n -= r.width, r.width;
    }), i = e ? Math.floor(n / e) : 0;
    return s.map((r, o) => r === void 0 ? Math.max(i, zs(t[o])) : r);
  }
}
function wr(a, t, e) {
  return a.border ? /[.']-+[.']/.test(t) ? "" : t.trim().length !== 0 ? e : "  " : "";
}
function zs(a) {
  const t = a.padding || [], e = 1 + (t[Re] || 0) + (t[Be] || 0);
  return a.border ? e + 4 : e;
}
function Ys() {
  return typeof process == "object" && process.stdout && process.stdout.columns ? process.stdout.columns : 80;
}
function ks(a, t) {
  a = a.trim();
  const e = Tt.stringWidth(a);
  return e < t ? " ".repeat(t - e) + a : a;
}
function Ks(a, t) {
  a = a.trim();
  const e = Tt.stringWidth(a);
  return e >= t ? a : " ".repeat(t - e >> 1) + a;
}
let Tt;
function Qs(a, t) {
  return Tt = t, new Gs({
    width: a?.width || Ys(),
    wrap: a?.wrap
  });
}
const Zi = new RegExp("\x1B(?:\\[(?:\\d+[ABCDEFGJKSTm]|\\d+;\\d+[Hfm]|\\d+;\\d+;\\d+m|6n|s|u|\\?25[lh])|\\w)", "g");
function ts(a) {
  return a.replace(Zi, "");
}
function Js(a, t) {
  const [e, n] = a.match(Zi) || ["", ""];
  a = ts(a);
  let s = "";
  for (let i = 0; i < a.length; i++)
    i !== 0 && i % t === 0 && (s += `
`), s += a.charAt(i);
  return e && n && (s = `${e}${s}${n}`), s;
}
function Zs(a) {
  return Qs(a, {
    stringWidth: (t) => [...t].length,
    stripAnsi: ts,
    wrap: Js
  });
}
function to(a, t) {
  let e = le(".", a), n;
  for (Xi(e).isDirectory() || (e = qn(e)); ; ) {
    if (n = t(e, $i(e)), n) return le(e, n);
    if (e = qn(n = e), n === e) break;
  }
}
/**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
function de(a) {
  if (a !== a.toLowerCase() && a !== a.toUpperCase() || (a = a.toLowerCase()), a.indexOf("-") === -1 && a.indexOf("_") === -1)
    return a;
  {
    let e = "", n = !1;
    const s = a.match(/^-+/);
    for (let i = s ? s[0].length : 0; i < a.length; i++) {
      let r = a.charAt(i);
      n && (n = !1, r = r.toUpperCase()), i !== 0 && (r === "-" || r === "_") ? n = !0 : r !== "-" && r !== "_" && (e += r);
    }
    return e;
  }
}
function es(a, t) {
  const e = a.toLowerCase();
  t = t || "-";
  let n = "";
  for (let s = 0; s < a.length; s++) {
    const i = e.charAt(s), r = a.charAt(s);
    i !== r && s > 0 ? n += `${t}${e.charAt(s)}` : n += r;
  }
  return n;
}
function ns(a) {
  return a == null ? !1 : typeof a == "number" || /^0x[0-9a-f]+$/i.test(a) ? !0 : /^0[^.]/.test(a) ? !1 : /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(a);
}
/**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
function eo(a) {
  if (Array.isArray(a))
    return a.map((r) => typeof r != "string" ? r + "" : r);
  a = a.trim();
  let t = 0, e = null, n = null, s = null;
  const i = [];
  for (let r = 0; r < a.length; r++) {
    if (e = n, n = a.charAt(r), n === " " && !s) {
      e !== " " && t++;
      continue;
    }
    n === s ? s = null : (n === "'" || n === '"') && !s && (s = n), i[t] || (i[t] = ""), i[t] += n;
  }
  return i;
}
/**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
var Ft;
(function(a) {
  a.BOOLEAN = "boolean", a.STRING = "string", a.NUMBER = "number", a.ARRAY = "array";
})(Ft || (Ft = {}));
/**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
let Xt;
class no {
  constructor(t) {
    Xt = t;
  }
  parse(t, e) {
    const n = Object.assign({
      alias: void 0,
      array: void 0,
      boolean: void 0,
      config: void 0,
      configObjects: void 0,
      configuration: void 0,
      coerce: void 0,
      count: void 0,
      default: void 0,
      envPrefix: void 0,
      narg: void 0,
      normalize: void 0,
      string: void 0,
      number: void 0,
      __: void 0,
      key: void 0
    }, e), s = eo(t), i = typeof t == "string", r = ro(Object.assign(/* @__PURE__ */ Object.create(null), n.alias)), o = Object.assign({
      "boolean-negation": !0,
      "camel-case-expansion": !0,
      "combine-arrays": !1,
      "dot-notation": !0,
      "duplicate-arguments-array": !0,
      "flatten-duplicate-arrays": !0,
      "greedy-arrays": !0,
      "halt-at-non-option": !1,
      "nargs-eats-options": !1,
      "negation-prefix": "no-",
      "parse-numbers": !0,
      "parse-positional-numbers": !0,
      "populate--": !1,
      "set-placeholder-key": !1,
      "short-option-groups": !0,
      "strip-aliased": !1,
      "strip-dashed": !1,
      "unknown-options-as-args": !1
    }, n.configuration), l = Object.assign(/* @__PURE__ */ Object.create(null), n.default), E = n.configObjects || [], m = n.envPrefix, p = o["populate--"], b = p ? "--" : "_", w = /* @__PURE__ */ Object.create(null), D = /* @__PURE__ */ Object.create(null), _ = n.__ || Xt.format, I = {
      aliases: /* @__PURE__ */ Object.create(null),
      arrays: /* @__PURE__ */ Object.create(null),
      bools: /* @__PURE__ */ Object.create(null),
      strings: /* @__PURE__ */ Object.create(null),
      numbers: /* @__PURE__ */ Object.create(null),
      counts: /* @__PURE__ */ Object.create(null),
      normalize: /* @__PURE__ */ Object.create(null),
      configs: /* @__PURE__ */ Object.create(null),
      nargs: /* @__PURE__ */ Object.create(null),
      coercions: /* @__PURE__ */ Object.create(null),
      keys: []
    }, T = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/, C = new RegExp("^--" + o["negation-prefix"] + "(.+)");
    [].concat(n.array || []).filter(Boolean).forEach(function(A) {
      const f = typeof A == "object" ? A.key : A, u = Object.keys(A).map(function(c) {
        return {
          boolean: "bools",
          string: "strings",
          number: "numbers"
        }[c];
      }).filter(Boolean).pop();
      u && (I[u][f] = !0), I.arrays[f] = !0, I.keys.push(f);
    }), [].concat(n.boolean || []).filter(Boolean).forEach(function(A) {
      I.bools[A] = !0, I.keys.push(A);
    }), [].concat(n.string || []).filter(Boolean).forEach(function(A) {
      I.strings[A] = !0, I.keys.push(A);
    }), [].concat(n.number || []).filter(Boolean).forEach(function(A) {
      I.numbers[A] = !0, I.keys.push(A);
    }), [].concat(n.count || []).filter(Boolean).forEach(function(A) {
      I.counts[A] = !0, I.keys.push(A);
    }), [].concat(n.normalize || []).filter(Boolean).forEach(function(A) {
      I.normalize[A] = !0, I.keys.push(A);
    }), typeof n.narg == "object" && Object.entries(n.narg).forEach(([A, f]) => {
      typeof f == "number" && (I.nargs[A] = f, I.keys.push(A));
    }), typeof n.coerce == "object" && Object.entries(n.coerce).forEach(([A, f]) => {
      typeof f == "function" && (I.coercions[A] = f, I.keys.push(A));
    }), typeof n.config < "u" && (Array.isArray(n.config) || typeof n.config == "string" ? [].concat(n.config).filter(Boolean).forEach(function(A) {
      I.configs[A] = !0;
    }) : typeof n.config == "object" && Object.entries(n.config).forEach(([A, f]) => {
      (typeof f == "boolean" || typeof f == "function") && (I.configs[A] = f);
    })), vt(n.key, r, n.default, I.arrays), Object.keys(l).forEach(function(A) {
      (I.aliases[A] || []).forEach(function(f) {
        l[f] = l[A];
      });
    });
    let g = null;
    ht();
    let v = [];
    const M = Object.assign(/* @__PURE__ */ Object.create(null), { _: [] }), X = {};
    for (let A = 0; A < s.length; A++) {
      const f = s[A], u = f.replace(/^-{3,}/, "---");
      let c, h, N, L, j, Z;
      if (f !== "--" && /^-/.test(f) && y(f))
        W(f);
      else if (u.match(/^---+(=|$)/)) {
        W(f);
        continue;
      } else if (f.match(/^--.+=/) || !o["short-option-groups"] && f.match(/^-.+=/))
        L = f.match(/^--?([^=]+)=([\s\S]*)$/), L !== null && Array.isArray(L) && L.length >= 3 && (K(L[1], I.arrays) ? A = d(A, L[1], s, L[2]) : K(L[1], I.nargs) !== !1 ? A = U(A, L[1], s, L[2]) : B(L[1], L[2], !0));
      else if (f.match(C) && o["boolean-negation"])
        L = f.match(C), L !== null && Array.isArray(L) && L.length >= 2 && (h = L[1], B(h, K(h, I.arrays) ? [!1] : !1));
      else if (f.match(/^--.+/) || !o["short-option-groups"] && f.match(/^-[^-]+/))
        L = f.match(/^--?(.+)/), L !== null && Array.isArray(L) && L.length >= 2 && (h = L[1], K(h, I.arrays) ? A = d(A, h, s) : K(h, I.nargs) !== !1 ? A = U(A, h, s) : (j = s[A + 1], j !== void 0 && (!j.match(/^-/) || j.match(T)) && !K(h, I.bools) && !K(h, I.counts) || /^(true|false)$/.test(j) ? (B(h, j), A++) : B(h, P(h))));
      else if (f.match(/^-.\..+=/))
        L = f.match(/^-([^=]+)=([\s\S]*)$/), L !== null && Array.isArray(L) && L.length >= 3 && B(L[1], L[2]);
      else if (f.match(/^-.\..+/) && !f.match(T))
        j = s[A + 1], L = f.match(/^-(.\..+)/), L !== null && Array.isArray(L) && L.length >= 2 && (h = L[1], j !== void 0 && !j.match(/^-/) && !K(h, I.bools) && !K(h, I.counts) ? (B(h, j), A++) : B(h, P(h)));
      else if (f.match(/^-[^-]+/) && !f.match(T)) {
        N = f.slice(1, -1).split(""), c = !1;
        for (let nt = 0; nt < N.length; nt++) {
          if (j = f.slice(nt + 2), N[nt + 1] && N[nt + 1] === "=") {
            Z = f.slice(nt + 3), h = N[nt], K(h, I.arrays) ? A = d(A, h, s, Z) : K(h, I.nargs) !== !1 ? A = U(A, h, s, Z) : B(h, Z), c = !0;
            break;
          }
          if (j === "-") {
            B(N[nt], j);
            continue;
          }
          if (/[A-Za-z]/.test(N[nt]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(j) && K(j, I.bools) === !1) {
            B(N[nt], j), c = !0;
            break;
          }
          if (N[nt + 1] && N[nt + 1].match(/\W/)) {
            B(N[nt], j), c = !0;
            break;
          } else
            B(N[nt], P(N[nt]));
        }
        h = f.slice(-1)[0], !c && h !== "-" && (K(h, I.arrays) ? A = d(A, h, s) : K(h, I.nargs) !== !1 ? A = U(A, h, s) : (j = s[A + 1], j !== void 0 && (!/^(-|--)[^-]/.test(j) || j.match(T)) && !K(h, I.bools) && !K(h, I.counts) || /^(true|false)$/.test(j) ? (B(h, j), A++) : B(h, P(h))));
      } else if (f.match(/^-[0-9]$/) && f.match(T) && K(f.slice(1), I.bools))
        h = f.slice(1), B(h, P(h));
      else if (f === "--") {
        v = s.slice(A + 1);
        break;
      } else if (o["halt-at-non-option"]) {
        v = s.slice(A);
        break;
      } else
        W(f);
    }
    V(M, !0), V(M, !1), q(M), k(), at(M, I.aliases, l, !0), ft(M), o["set-placeholder-key"] && Ot(M), Object.keys(I.counts).forEach(function(A) {
      ot(M, A.split(".")) || B(A, 0);
    }), p && v.length && (M[b] = []), v.forEach(function(A) {
      M[b].push(A);
    }), o["camel-case-expansion"] && o["strip-dashed"] && Object.keys(M).filter((A) => A !== "--" && A.includes("-")).forEach((A) => {
      delete M[A];
    }), o["strip-aliased"] && [].concat(...Object.keys(r).map((A) => r[A])).forEach((A) => {
      o["camel-case-expansion"] && A.includes("-") && delete M[A.split(".").map((f) => de(f)).join(".")], delete M[A];
    });
    function W(A) {
      const f = $("_", A);
      (typeof f == "string" || typeof f == "number") && M._.push(f);
    }
    function U(A, f, u, c) {
      let h, N = K(f, I.nargs);
      if (N = typeof N != "number" || isNaN(N) ? 1 : N, N === 0)
        return rt(c) || (g = Error(_("Argument unexpected for: %s", f))), B(f, P(f)), A;
      let L = rt(c) ? 0 : 1;
      if (o["nargs-eats-options"])
        u.length - (A + 1) + L < N && (g = Error(_("Not enough arguments following: %s", f))), L = N;
      else {
        for (h = A + 1; h < u.length && (!u[h].match(/^-[^0-9]/) || u[h].match(T) || y(u[h])); h++)
          L++;
        L < N && (g = Error(_("Not enough arguments following: %s", f)));
      }
      let j = Math.min(L, N);
      for (!rt(c) && j > 0 && (B(f, c), j--), h = A + 1; h < j + A + 1; h++)
        B(f, u[h]);
      return A + j;
    }
    function d(A, f, u, c) {
      let h = [], N = c || u[A + 1];
      const L = K(f, I.nargs);
      if (K(f, I.bools) && !/^(true|false)$/.test(N))
        h.push(!0);
      else if (rt(N) || rt(c) && /^-/.test(N) && !T.test(N) && !y(N)) {
        if (l[f] !== void 0) {
          const j = l[f];
          h = Array.isArray(j) ? j : [j];
        }
      } else {
        rt(c) || h.push(R(f, c, !0));
        for (let j = A + 1; j < u.length && !(!o["greedy-arrays"] && h.length > 0 || L && typeof L == "number" && h.length >= L || (N = u[j], /^-/.test(N) && !T.test(N) && !y(N))); j++)
          A = j, h.push(R(f, N, i));
      }
      return typeof L == "number" && (L && h.length < L || isNaN(L) && h.length === 0) && (g = Error(_("Not enough arguments following: %s", f))), B(f, h), A;
    }
    function B(A, f, u = i) {
      if (/-/.test(A) && o["camel-case-expansion"]) {
        const N = A.split(".").map(function(L) {
          return de(L);
        }).join(".");
        S(A, N);
      }
      const c = R(A, f, u), h = A.split(".");
      ut(M, h, c), I.aliases[A] && I.aliases[A].forEach(function(N) {
        const L = N.split(".");
        ut(M, L, c);
      }), h.length > 1 && o["dot-notation"] && (I.aliases[h[0]] || []).forEach(function(N) {
        let L = N.split(".");
        const j = [].concat(h);
        j.shift(), L = L.concat(j), (I.aliases[A] || []).includes(L.join(".")) || ut(M, L, c);
      }), K(A, I.normalize) && !K(A, I.arrays) && [A].concat(I.aliases[A] || []).forEach(function(L) {
        Object.defineProperty(X, L, {
          enumerable: !0,
          get() {
            return f;
          },
          set(j) {
            f = typeof j == "string" ? Xt.normalize(j) : j;
          }
        });
      });
    }
    function S(A, f) {
      I.aliases[A] && I.aliases[A].length || (I.aliases[A] = [f], w[f] = !0), I.aliases[f] && I.aliases[f].length || S(f, A);
    }
    function R(A, f, u) {
      u && (f = io(f)), (K(A, I.bools) || K(A, I.counts)) && typeof f == "string" && (f = f === "true");
      let c = Array.isArray(f) ? f.map(function(h) {
        return $(A, h);
      }) : $(A, f);
      return K(A, I.counts) && (rt(c) || typeof c == "boolean") && (c = Ve()), K(A, I.normalize) && K(A, I.arrays) && (Array.isArray(f) ? c = f.map((h) => Xt.normalize(h)) : c = Xt.normalize(f)), c;
    }
    function $(A, f) {
      return !o["parse-positional-numbers"] && A === "_" || !K(A, I.strings) && !K(A, I.bools) && !Array.isArray(f) && (ns(f) && o["parse-numbers"] && Number.isSafeInteger(Math.floor(parseFloat(`${f}`))) || !rt(f) && K(A, I.numbers)) && (f = Number(f)), f;
    }
    function q(A) {
      const f = /* @__PURE__ */ Object.create(null);
      at(f, I.aliases, l), Object.keys(I.configs).forEach(function(u) {
        const c = A[u] || f[u];
        if (c)
          try {
            let h = null;
            const N = Xt.resolve(Xt.cwd(), c), L = I.configs[u];
            if (typeof L == "function") {
              try {
                h = L(N);
              } catch (j) {
                h = j;
              }
              if (h instanceof Error) {
                g = h;
                return;
              }
            } else
              h = Xt.require(N);
            z(h);
          } catch (h) {
            h.name === "PermissionDenied" ? g = h : A[u] && (g = Error(_("Invalid JSON config file: %s", c)));
          }
      });
    }
    function z(A, f) {
      Object.keys(A).forEach(function(u) {
        const c = A[u], h = f ? f + "." + u : u;
        typeof c == "object" && c !== null && !Array.isArray(c) && o["dot-notation"] ? z(c, h) : (!ot(M, h.split(".")) || K(h, I.arrays) && o["combine-arrays"]) && B(h, c);
      });
    }
    function k() {
      typeof E < "u" && E.forEach(function(A) {
        z(A);
      });
    }
    function V(A, f) {
      if (typeof m > "u")
        return;
      const u = typeof m == "string" ? m : "", c = Xt.env();
      Object.keys(c).forEach(function(h) {
        if (u === "" || h.lastIndexOf(u, 0) === 0) {
          const N = h.split("__").map(function(L, j) {
            return j === 0 && (L = L.substring(u.length)), de(L);
          });
          (f && I.configs[N.join(".")] || !f) && !ot(A, N) && B(N.join("."), c[h]);
        }
      });
    }
    function ft(A) {
      let f;
      const u = /* @__PURE__ */ new Set();
      Object.keys(A).forEach(function(c) {
        if (!u.has(c) && (f = K(c, I.coercions), typeof f == "function"))
          try {
            const h = $(c, f(A[c]));
            [].concat(I.aliases[c] || [], c).forEach((N) => {
              u.add(N), A[N] = h;
            });
          } catch (h) {
            g = h;
          }
      });
    }
    function Ot(A) {
      return I.keys.forEach((f) => {
        ~f.indexOf(".") || typeof A[f] > "u" && (A[f] = void 0);
      }), A;
    }
    function at(A, f, u, c = !1) {
      Object.keys(u).forEach(function(h) {
        ot(A, h.split(".")) || (ut(A, h.split("."), u[h]), c && (D[h] = !0), (f[h] || []).forEach(function(N) {
          ot(A, N.split(".")) || ut(A, N.split("."), u[h]);
        }));
      });
    }
    function ot(A, f) {
      let u = A;
      o["dot-notation"] || (f = [f.join(".")]), f.slice(0, -1).forEach(function(h) {
        u = u[h] || {};
      });
      const c = f[f.length - 1];
      return typeof u != "object" ? !1 : c in u;
    }
    function ut(A, f, u) {
      let c = A;
      o["dot-notation"] || (f = [f.join(".")]), f.slice(0, -1).forEach(function(Z) {
        Z = Er(Z), typeof c == "object" && c[Z] === void 0 && (c[Z] = {}), typeof c[Z] != "object" || Array.isArray(c[Z]) ? (Array.isArray(c[Z]) ? c[Z].push({}) : c[Z] = [c[Z], {}], c = c[Z][c[Z].length - 1]) : c = c[Z];
      });
      const h = Er(f[f.length - 1]), N = K(f.join("."), I.arrays), L = Array.isArray(u);
      let j = o["duplicate-arguments-array"];
      !j && K(h, I.nargs) && (j = !0, (!rt(c[h]) && I.nargs[h] === 1 || Array.isArray(c[h]) && c[h].length === I.nargs[h]) && (c[h] = void 0)), u === Ve() ? c[h] = Ve(c[h]) : Array.isArray(c[h]) ? j && N && L ? c[h] = o["flatten-duplicate-arrays"] ? c[h].concat(u) : (Array.isArray(c[h][0]) ? c[h] : [c[h]]).concat([u]) : !j && !!N == !!L ? c[h] = u : c[h] = c[h].concat([u]) : c[h] === void 0 && N ? c[h] = L ? u : [u] : j && !(c[h] === void 0 || K(h, I.counts) || K(h, I.bools)) ? c[h] = [c[h], u] : c[h] = u;
    }
    function vt(...A) {
      A.forEach(function(f) {
        Object.keys(f || {}).forEach(function(u) {
          I.aliases[u] || (I.aliases[u] = [].concat(r[u] || []), I.aliases[u].concat(u).forEach(function(c) {
            if (/-/.test(c) && o["camel-case-expansion"]) {
              const h = de(c);
              h !== u && I.aliases[u].indexOf(h) === -1 && (I.aliases[u].push(h), w[h] = !0);
            }
          }), I.aliases[u].concat(u).forEach(function(c) {
            if (c.length > 1 && /[A-Z]/.test(c) && o["camel-case-expansion"]) {
              const h = es(c, "-");
              h !== u && I.aliases[u].indexOf(h) === -1 && (I.aliases[u].push(h), w[h] = !0);
            }
          }), I.aliases[u].forEach(function(c) {
            I.aliases[c] = [u].concat(I.aliases[u].filter(function(h) {
              return c !== h;
            }));
          }));
        });
      });
    }
    function K(A, f) {
      const u = [].concat(I.aliases[A] || [], A), c = Object.keys(f), h = u.find((N) => c.includes(N));
      return h ? f[h] : !1;
    }
    function Bt(A) {
      const f = Object.keys(I);
      return [].concat(f.map((c) => I[c])).some(function(c) {
        return Array.isArray(c) ? c.includes(A) : c[A];
      });
    }
    function Q(A, ...f) {
      return [].concat(...f).some(function(c) {
        const h = A.match(c);
        return h && Bt(h[1]);
      });
    }
    function x(A) {
      if (A.match(T) || !A.match(/^-[^-]+/))
        return !1;
      let f = !0, u;
      const c = A.slice(1).split("");
      for (let h = 0; h < c.length; h++) {
        if (u = A.slice(h + 2), !Bt(c[h])) {
          f = !1;
          break;
        }
        if (c[h + 1] && c[h + 1] === "=" || u === "-" || /[A-Za-z]/.test(c[h]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(u) || c[h + 1] && c[h + 1].match(/\W/))
          break;
      }
      return f;
    }
    function y(A) {
      return o["unknown-options-as-args"] && F(A);
    }
    function F(A) {
      return A = A.replace(/^-{3,}/, "--"), A.match(T) || x(A) ? !1 : !Q(A, /^-+([^=]+?)=[\s\S]*$/, C, /^-+([^=]+?)$/, /^-+([^=]+?)-$/, /^-+([^=]+?\d+)$/, /^-+([^=]+?)\W+.*$/);
    }
    function P(A) {
      return !K(A, I.bools) && !K(A, I.counts) && `${A}` in l ? l[A] : J(st(A));
    }
    function J(A) {
      return {
        [Ft.BOOLEAN]: !0,
        [Ft.STRING]: "",
        [Ft.NUMBER]: void 0,
        [Ft.ARRAY]: []
      }[A];
    }
    function st(A) {
      let f = Ft.BOOLEAN;
      return K(A, I.strings) ? f = Ft.STRING : K(A, I.numbers) ? f = Ft.NUMBER : K(A, I.bools) ? f = Ft.BOOLEAN : K(A, I.arrays) && (f = Ft.ARRAY), f;
    }
    function rt(A) {
      return A === void 0;
    }
    function ht() {
      Object.keys(I.counts).find((A) => K(A, I.arrays) ? (g = Error(_("Invalid configuration: %s, opts.count excludes opts.array.", A)), !0) : K(A, I.nargs) ? (g = Error(_("Invalid configuration: %s, opts.count excludes opts.narg.", A)), !0) : !1);
    }
    return {
      aliases: Object.assign({}, I.aliases),
      argv: Object.assign(X, M),
      configuration: o,
      defaulted: Object.assign({}, D),
      error: g,
      newAliases: Object.assign({}, w)
    };
  }
}
function ro(a) {
  const t = [], e = /* @__PURE__ */ Object.create(null);
  let n = !0;
  for (Object.keys(a).forEach(function(s) {
    t.push([].concat(a[s], s));
  }); n; ) {
    n = !1;
    for (let s = 0; s < t.length; s++)
      for (let i = s + 1; i < t.length; i++)
        if (t[s].filter(function(o) {
          return t[i].indexOf(o) !== -1;
        }).length) {
          t[s] = t[s].concat(t[i]), t.splice(i, 1), n = !0;
          break;
        }
  }
  return t.forEach(function(s) {
    s = s.filter(function(r, o, l) {
      return l.indexOf(r) === o;
    });
    const i = s.pop();
    i !== void 0 && typeof i == "string" && (e[i] = s);
  }), e;
}
function Ve(a) {
  return a !== void 0 ? a + 1 : 1;
}
function Er(a) {
  return a === "__proto__" ? "___proto___" : a;
}
function io(a) {
  return typeof a == "string" && (a[0] === "'" || a[0] === '"') && a[a.length - 1] === a[0] ? a.substring(1, a.length - 1) : a;
}
/**
 * @fileoverview Main entrypoint for libraries using yargs-parser in Node.js
 * CJS and ESM environments.
 *
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
var He, Ge, ze;
const xr = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12, Or = (Ge = (He = process == null ? void 0 : process.versions) === null || He === void 0 ? void 0 : He.node) !== null && Ge !== void 0 ? Ge : (ze = process == null ? void 0 : process.version) === null || ze === void 0 ? void 0 : ze.slice(1);
if (Or && Number(Or.match(/^([^.]+)/)[1]) < xr)
  throw Error(`yargs parser supports a minimum Node.js version of ${xr}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
const so = process ? process.env : {}, rs = new no({
  cwd: process.cwd,
  env: () => so,
  format: Wi,
  normalize: ys,
  resolve: le,
  // TODO: figure  out a  way to combine ESM and CJS coverage, such  that
  // we can exercise all the lines below:
  require: (a) => {
    if (typeof require < "u")
      return require(a);
    if (a.match(/\.json$/))
      return JSON.parse(Xe(a, "utf8"));
    throw Error("only .json config files are supported in ESM");
  }
}), Oe = function(t, e) {
  return rs.parse(t.slice(), e).argv;
};
Oe.detailed = function(a, t) {
  return rs.parse(a.slice(), t);
};
Oe.camelCase = de;
Oe.decamelize = es;
Oe.looksLikeNumber = ns;
function is() {
  return oo() ? 0 : 1;
}
function oo() {
  return ao() && !process.defaultApp;
}
function ao() {
  return !!process.versions.electron;
}
function uo(a) {
  return a.slice(is() + 1);
}
function co() {
  return process.argv[is()];
}
class gt extends Error {
  constructor(t) {
    super(t || "yargs error"), this.name = "YError", Error.captureStackTrace && Error.captureStackTrace(this, gt);
  }
}
const lo = {
  fs: {
    readFileSync: Xe,
    writeFile: xs
  },
  format: Wi,
  resolve: le,
  exists: (a) => {
    try {
      return Xi(a).isFile();
    } catch {
      return !1;
    }
  }
};
let St;
class fo {
  constructor(t) {
    t = t || {}, this.directory = t.directory || "./locales", this.updateFiles = typeof t.updateFiles == "boolean" ? t.updateFiles : !0, this.locale = t.locale || "en", this.fallbackToLanguage = typeof t.fallbackToLanguage == "boolean" ? t.fallbackToLanguage : !0, this.cache = /* @__PURE__ */ Object.create(null), this.writeQueue = [];
  }
  __(...t) {
    if (typeof arguments[0] != "string")
      return this._taggedLiteral(arguments[0], ...arguments);
    const e = t.shift();
    let n = function() {
    };
    return typeof t[t.length - 1] == "function" && (n = t.pop()), n = n || function() {
    }, this.cache[this.locale] || this._readLocaleFile(), !this.cache[this.locale][e] && this.updateFiles ? (this.cache[this.locale][e] = e, this._enqueueWrite({
      directory: this.directory,
      locale: this.locale,
      cb: n
    })) : n(), St.format.apply(St.format, [this.cache[this.locale][e] || e].concat(t));
  }
  __n() {
    const t = Array.prototype.slice.call(arguments), e = t.shift(), n = t.shift(), s = t.shift();
    let i = function() {
    };
    typeof t[t.length - 1] == "function" && (i = t.pop()), this.cache[this.locale] || this._readLocaleFile();
    let r = s === 1 ? e : n;
    this.cache[this.locale][e] && (r = this.cache[this.locale][e][s === 1 ? "one" : "other"]), !this.cache[this.locale][e] && this.updateFiles ? (this.cache[this.locale][e] = {
      one: e,
      other: n
    }, this._enqueueWrite({
      directory: this.directory,
      locale: this.locale,
      cb: i
    })) : i();
    const o = [r];
    return ~r.indexOf("%d") && o.push(s), St.format.apply(St.format, o.concat(t));
  }
  setLocale(t) {
    this.locale = t;
  }
  getLocale() {
    return this.locale;
  }
  updateLocale(t) {
    this.cache[this.locale] || this._readLocaleFile();
    for (const e in t)
      Object.prototype.hasOwnProperty.call(t, e) && (this.cache[this.locale][e] = t[e]);
  }
  _taggedLiteral(t, ...e) {
    let n = "";
    return t.forEach(function(s, i) {
      const r = e[i + 1];
      n += s, typeof r < "u" && (n += "%s");
    }), this.__.apply(this, [n].concat([].slice.call(e, 1)));
  }
  _enqueueWrite(t) {
    this.writeQueue.push(t), this.writeQueue.length === 1 && this._processWriteQueue();
  }
  _processWriteQueue() {
    const t = this, e = this.writeQueue[0], n = e.directory, s = e.locale, i = e.cb, r = this._resolveLocaleFile(n, s), o = JSON.stringify(this.cache[s], null, 2);
    St.fs.writeFile(r, o, "utf-8", function(l) {
      t.writeQueue.shift(), t.writeQueue.length > 0 && t._processWriteQueue(), i(l);
    });
  }
  _readLocaleFile() {
    let t = {};
    const e = this._resolveLocaleFile(this.directory, this.locale);
    try {
      St.fs.readFileSync && (t = JSON.parse(St.fs.readFileSync(e, "utf-8")));
    } catch (n) {
      if (n instanceof SyntaxError && (n.message = "syntax error in " + e), n.code === "ENOENT")
        t = {};
      else
        throw n;
    }
    this.cache[this.locale] = t;
  }
  _resolveLocaleFile(t, e) {
    let n = St.resolve(t, "./", e + ".json");
    if (this.fallbackToLanguage && !this._fileExistsSync(n) && ~e.lastIndexOf("_")) {
      const s = St.resolve(t, "./", e.split("_")[0] + ".json");
      this._fileExistsSync(s) && (n = s);
    }
    return n;
  }
  _fileExistsSync(t) {
    return St.exists(t);
  }
}
function ho(a, t) {
  St = t;
  const e = new fo(a);
  return {
    __: e.__.bind(e),
    __n: e.__n.bind(e),
    setLocale: e.setLocale.bind(e),
    getLocale: e.getLocale.bind(e),
    updateLocale: e.updateLocale.bind(e),
    locale: e.locale
  };
}
const po = (a) => ho(a, lo), mo = "require is not supported by ESM", Ir = "loading a directory of commands is not supported yet for ESM";
let Ee;
try {
  Ee = Cs(import.meta.url);
} catch {
  Ee = process.cwd();
}
const go = Ee.substring(0, Ee.lastIndexOf("node_modules")), yo = {
  assert: {
    notStrictEqual: gs,
    strictEqual: ms
  },
  cliui: Zs,
  findUp: to,
  getEnv: (a) => process.env[a],
  inspect: Is,
  getCallerFile: () => {
    throw new gt(Ir);
  },
  getProcessArgvBin: co,
  mainFilename: go || process.cwd(),
  Parser: Oe,
  path: {
    basename: Es,
    dirname: qn,
    extname: ws,
    relative: bs,
    resolve: le
  },
  process: {
    argv: () => process.argv,
    cwd: process.cwd,
    emitWarning: (a, t) => process.emitWarning(a, t),
    execPath: () => process.execPath,
    exit: process.exit,
    nextTick: process.nextTick,
    stdColumns: typeof process.stdout.columns < "u" ? process.stdout.columns : null
  },
  readFileSync: Xe,
  require: () => {
    throw new gt(mo);
  },
  requireDirectory: () => {
    throw new gt(Ir);
  },
  stringWidth: (a) => [...a].length,
  y18n: po({
    directory: le(Ee, "../../../locales"),
    updateFiles: !1
  })
};
function jt(a, t, e, n) {
  e.assert.notStrictEqual(a, t, n);
}
function Cr(a, t) {
  t.assert.strictEqual(typeof a, "string");
}
function Ue(a) {
  return Object.keys(a);
}
function yt(a) {
  return !!a && !!a.then && typeof a.then == "function";
}
function ye(a) {
  const e = a.replace(/\s{2,}/g, " ").split(/\s+(?![^[]*]|[^<]*>)/), n = /\.*[\][<>]/g, s = e.shift();
  if (!s)
    throw new Error(`No command found in: ${a}`);
  const i = {
    cmd: s.replace(n, ""),
    demanded: [],
    optional: []
  };
  return e.forEach((r, o) => {
    let l = !1;
    r = r.replace(/\s/g, ""), /\.+[\]>]/.test(r) && o === e.length - 1 && (l = !0), /^\[/.test(r) ? i.optional.push({
      cmd: r.replace(n, "").split("|"),
      variadic: l
    }) : i.demanded.push({
      cmd: r.replace(n, "").split("|"),
      variadic: l
    });
  }), i;
}
const bo = ["first", "second", "third", "fourth", "fifth", "sixth"];
function G(a, t, e) {
  function n() {
    return typeof a == "object" ? [{ demanded: [], optional: [] }, a, t] : [
      ye(`cmd ${a}`),
      t,
      e
    ];
  }
  try {
    let s = 0;
    const [i, r, o] = n(), l = [].slice.call(r);
    for (; l.length && l[l.length - 1] === void 0; )
      l.pop();
    const E = o || l.length;
    if (E < i.demanded.length)
      throw new gt(`Not enough arguments provided. Expected ${i.demanded.length} but received ${l.length}.`);
    const m = i.demanded.length + i.optional.length;
    if (E > m)
      throw new gt(`Too many arguments provided. Expected max ${m} but received ${E}.`);
    i.demanded.forEach((p) => {
      const b = l.shift(), w = Dr(b);
      p.cmd.filter((_) => _ === w || _ === "*").length === 0 && Tr(w, p.cmd, s), s += 1;
    }), i.optional.forEach((p) => {
      if (l.length === 0)
        return;
      const b = l.shift(), w = Dr(b);
      p.cmd.filter((_) => _ === w || _ === "*").length === 0 && Tr(w, p.cmd, s), s += 1;
    });
  } catch (s) {
    console.warn(s.stack);
  }
}
function Dr(a) {
  return Array.isArray(a) ? "array" : a === null ? "null" : typeof a;
}
function Tr(a, t, e) {
  throw new gt(`Invalid ${bo[e] || "manyith"} argument. Expected ${t.join(" or ")} but received ${a}.`);
}
class wo {
  constructor(t) {
    this.globalMiddleware = [], this.frozens = [], this.yargs = t;
  }
  addMiddleware(t, e, n = !0, s = !1) {
    if (G("<array|function> [boolean] [boolean] [boolean]", [t, e, n], arguments.length), Array.isArray(t)) {
      for (let i = 0; i < t.length; i++) {
        if (typeof t[i] != "function")
          throw Error("middleware must be a function");
        const r = t[i];
        r.applyBeforeValidation = e, r.global = n;
      }
      Array.prototype.push.apply(this.globalMiddleware, t);
    } else if (typeof t == "function") {
      const i = t;
      i.applyBeforeValidation = e, i.global = n, i.mutates = s, this.globalMiddleware.push(t);
    }
    return this.yargs;
  }
  addCoerceMiddleware(t, e) {
    const n = this.yargs.getAliases();
    return this.globalMiddleware = this.globalMiddleware.filter((s) => {
      const i = [...n[e] || [], e];
      return s.option ? !i.includes(s.option) : !0;
    }), t.option = e, this.addMiddleware(t, !0, !0, !0);
  }
  getMiddleware() {
    return this.globalMiddleware;
  }
  freeze() {
    this.frozens.push([...this.globalMiddleware]);
  }
  unfreeze() {
    const t = this.frozens.pop();
    t !== void 0 && (this.globalMiddleware = t);
  }
  reset() {
    this.globalMiddleware = this.globalMiddleware.filter((t) => t.global);
  }
}
function Eo(a) {
  return a ? a.map((t) => (t.applyBeforeValidation = !1, t)) : [];
}
function be(a, t, e, n) {
  return e.reduce((s, i) => {
    if (i.applyBeforeValidation !== n)
      return s;
    if (i.mutates) {
      if (i.applied)
        return s;
      i.applied = !0;
    }
    if (yt(s))
      return s.then((r) => Promise.all([r, i(r, t)])).then(([r, o]) => Object.assign(r, o));
    {
      const r = i(s, t);
      return yt(r) ? r.then((o) => Object.assign(s, o)) : Object.assign(s, r);
    }
  }, a);
}
function we(a, t, e = (n) => {
  throw n;
}) {
  try {
    const n = xo(a) ? a() : a;
    return yt(n) ? n.then((s) => t(s)) : t(n);
  } catch (n) {
    return e(n);
  }
}
function xo(a) {
  return typeof a == "function";
}
function Oo(a) {
  if (typeof require > "u")
    return null;
  for (let t = 0, e = Object.keys(require.cache), n; t < e.length; t++)
    if (n = require.cache[e[t]], n.exports === a)
      return n;
  return null;
}
const ie = /(^\*)|(^\$0)/;
class Io {
  constructor(t, e, n, s) {
    this.requireCache = /* @__PURE__ */ new Set(), this.handlers = {}, this.aliasMap = {}, this.frozens = [], this.shim = s, this.usage = t, this.globalMiddleware = n, this.validation = e;
  }
  addDirectory(t, e, n, s) {
    s = s || {}, typeof s.recurse != "boolean" && (s.recurse = !1), Array.isArray(s.extensions) || (s.extensions = ["js"]);
    const i = typeof s.visit == "function" ? s.visit : (r) => r;
    s.visit = (r, o, l) => {
      const E = i(r, o, l);
      if (E) {
        if (this.requireCache.has(o))
          return E;
        this.requireCache.add(o), this.addHandler(E);
      }
      return E;
    }, this.shim.requireDirectory({ require: e, filename: n }, t, s);
  }
  addHandler(t, e, n, s, i, r) {
    let o = [];
    const l = Eo(i);
    if (s = s || (() => {
    }), Array.isArray(t))
      if (Do(t))
        [t, ...o] = t;
      else
        for (const E of t)
          this.addHandler(E);
    else if (vo(t)) {
      let E = Array.isArray(t.command) || typeof t.command == "string" ? t.command : this.moduleName(t);
      t.aliases && (E = [].concat(E).concat(t.aliases)), this.addHandler(E, this.extractDesc(t), t.builder, t.handler, t.middlewares, t.deprecated);
      return;
    } else if (vr(n)) {
      this.addHandler([t].concat(o), e, n.builder, n.handler, n.middlewares, n.deprecated);
      return;
    }
    if (typeof t == "string") {
      const E = ye(t);
      o = o.map((b) => ye(b).cmd);
      let m = !1;
      const p = [E.cmd].concat(o).filter((b) => ie.test(b) ? (m = !0, !1) : !0);
      p.length === 0 && m && p.push("$0"), m && (E.cmd = p[0], o = p.slice(1), t = t.replace(ie, E.cmd)), o.forEach((b) => {
        this.aliasMap[b] = E.cmd;
      }), e !== !1 && this.usage.command(t, e, m, o, r), this.handlers[E.cmd] = {
        original: t,
        description: e,
        handler: s,
        builder: n || {},
        middlewares: l,
        deprecated: r,
        demanded: E.demanded,
        optional: E.optional
      }, m && (this.defaultCommand = this.handlers[E.cmd]);
    }
  }
  getCommandHandlers() {
    return this.handlers;
  }
  getCommands() {
    return Object.keys(this.handlers).concat(Object.keys(this.aliasMap));
  }
  hasDefaultCommand() {
    return !!this.defaultCommand;
  }
  runCommand(t, e, n, s, i, r) {
    const o = this.handlers[t] || this.handlers[this.aliasMap[t]] || this.defaultCommand, l = e.getInternalMethods().getContext(), E = l.commands.slice(), m = !t;
    t && (l.commands.push(t), l.fullCommands.push(o.original));
    const p = this.applyBuilderUpdateUsageAndParse(m, o, e, n.aliases, E, s, i, r);
    return yt(p) ? p.then((b) => this.applyMiddlewareAndGetResult(m, o, b.innerArgv, l, i, b.aliases, e)) : this.applyMiddlewareAndGetResult(m, o, p.innerArgv, l, i, p.aliases, e);
  }
  applyBuilderUpdateUsageAndParse(t, e, n, s, i, r, o, l) {
    const E = e.builder;
    let m = n;
    if (Gn(E)) {
      n.getInternalMethods().getUsageInstance().freeze();
      const p = E(n.getInternalMethods().reset(s), l);
      if (yt(p))
        return p.then((b) => (m = qo(b) ? b : n, this.parseAndUpdateUsage(t, e, m, i, r, o)));
    } else To(E) && (n.getInternalMethods().getUsageInstance().freeze(), m = n.getInternalMethods().reset(s), Object.keys(e.builder).forEach((p) => {
      m.option(p, E[p]);
    }));
    return this.parseAndUpdateUsage(t, e, m, i, r, o);
  }
  parseAndUpdateUsage(t, e, n, s, i, r) {
    t && n.getInternalMethods().getUsageInstance().unfreeze(!0), this.shouldUpdateUsage(n) && n.getInternalMethods().getUsageInstance().usage(this.usageFromParentCommandsCommandHandler(s, e), e.description);
    const o = n.getInternalMethods().runYargsParserAndExecuteCommands(null, void 0, !0, i, r);
    return yt(o) ? o.then((l) => ({
      aliases: n.parsed.aliases,
      innerArgv: l
    })) : {
      aliases: n.parsed.aliases,
      innerArgv: o
    };
  }
  shouldUpdateUsage(t) {
    return !t.getInternalMethods().getUsageInstance().getUsageDisabled() && t.getInternalMethods().getUsageInstance().getUsage().length === 0;
  }
  usageFromParentCommandsCommandHandler(t, e) {
    const n = ie.test(e.original) ? e.original.replace(ie, "").trim() : e.original, s = t.filter((i) => !ie.test(i));
    return s.push(n), `$0 ${s.join(" ")}`;
  }
  handleValidationAndGetResult(t, e, n, s, i, r, o, l) {
    if (!r.getInternalMethods().getHasOutput()) {
      const E = r.getInternalMethods().runValidation(i, l, r.parsed.error, t);
      n = we(n, (m) => (E(m), m));
    }
    if (e.handler && !r.getInternalMethods().getHasOutput()) {
      r.getInternalMethods().setHasOutput();
      const E = !!r.getOptions().configuration["populate--"];
      r.getInternalMethods().postProcess(n, E, !1, !1), n = be(n, r, o, !1), n = we(n, (m) => {
        const p = e.handler(m);
        return yt(p) ? p.then(() => m) : m;
      }), t || r.getInternalMethods().getUsageInstance().cacheHelpMessage(), yt(n) && !r.getInternalMethods().hasParseCallback() && n.catch((m) => {
        try {
          r.getInternalMethods().getUsageInstance().fail(null, m);
        } catch {
        }
      });
    }
    return t || (s.commands.pop(), s.fullCommands.pop()), n;
  }
  applyMiddlewareAndGetResult(t, e, n, s, i, r, o) {
    let l = {};
    if (i)
      return n;
    o.getInternalMethods().getHasOutput() || (l = this.populatePositionals(e, n, s, o));
    const E = this.globalMiddleware.getMiddleware().slice(0).concat(e.middlewares), m = be(n, o, E, !0);
    return yt(m) ? m.then((p) => this.handleValidationAndGetResult(t, e, p, s, r, o, E, l)) : this.handleValidationAndGetResult(t, e, m, s, r, o, E, l);
  }
  populatePositionals(t, e, n, s) {
    e._ = e._.slice(n.commands.length);
    const i = t.demanded.slice(0), r = t.optional.slice(0), o = {};
    for (this.validation.positionalCount(i.length, e._.length); i.length; ) {
      const l = i.shift();
      this.populatePositional(l, e, o);
    }
    for (; r.length; ) {
      const l = r.shift();
      this.populatePositional(l, e, o);
    }
    return e._ = n.commands.concat(e._.map((l) => "" + l)), this.postProcessPositionals(e, o, this.cmdToParseOptions(t.original), s), o;
  }
  populatePositional(t, e, n) {
    const s = t.cmd[0];
    t.variadic ? n[s] = e._.splice(0).map(String) : e._.length && (n[s] = [String(e._.shift())]);
  }
  cmdToParseOptions(t) {
    const e = {
      array: [],
      default: {},
      alias: {},
      demand: {}
    }, n = ye(t);
    return n.demanded.forEach((s) => {
      const [i, ...r] = s.cmd;
      s.variadic && (e.array.push(i), e.default[i] = []), e.alias[i] = r, e.demand[i] = !0;
    }), n.optional.forEach((s) => {
      const [i, ...r] = s.cmd;
      s.variadic && (e.array.push(i), e.default[i] = []), e.alias[i] = r;
    }), e;
  }
  postProcessPositionals(t, e, n, s) {
    const i = Object.assign({}, s.getOptions());
    i.default = Object.assign(n.default, i.default);
    for (const E of Object.keys(n.alias))
      i.alias[E] = (i.alias[E] || []).concat(n.alias[E]);
    i.array = i.array.concat(n.array), i.config = {};
    const r = [];
    if (Object.keys(e).forEach((E) => {
      e[E].map((m) => {
        i.configuration["unknown-options-as-args"] && (i.key[E] = !0), r.push(`--${E}`), r.push(m);
      });
    }), !r.length)
      return;
    const o = Object.assign({}, i.configuration, {
      "populate--": !1
    }), l = this.shim.Parser.detailed(r, Object.assign({}, i, {
      configuration: o
    }));
    if (l.error)
      s.getInternalMethods().getUsageInstance().fail(l.error.message, l.error);
    else {
      const E = Object.keys(e);
      Object.keys(e).forEach((m) => {
        E.push(...l.aliases[m]);
      }), Object.keys(l.argv).forEach((m) => {
        E.includes(m) && (e[m] || (e[m] = l.argv[m]), !this.isInConfigs(s, m) && !this.isDefaulted(s, m) && Object.prototype.hasOwnProperty.call(t, m) && Object.prototype.hasOwnProperty.call(l.argv, m) && (Array.isArray(t[m]) || Array.isArray(l.argv[m])) ? t[m] = [].concat(t[m], l.argv[m]) : t[m] = l.argv[m]);
      });
    }
  }
  isDefaulted(t, e) {
    const { default: n } = t.getOptions();
    return Object.prototype.hasOwnProperty.call(n, e) || Object.prototype.hasOwnProperty.call(n, this.shim.Parser.camelCase(e));
  }
  isInConfigs(t, e) {
    const { configObjects: n } = t.getOptions();
    return n.some((s) => Object.prototype.hasOwnProperty.call(s, e)) || n.some((s) => Object.prototype.hasOwnProperty.call(s, this.shim.Parser.camelCase(e)));
  }
  runDefaultBuilderOn(t) {
    if (!this.defaultCommand)
      return;
    if (this.shouldUpdateUsage(t)) {
      const n = ie.test(this.defaultCommand.original) ? this.defaultCommand.original : this.defaultCommand.original.replace(/^[^[\]<>]*/, "$0 ");
      t.getInternalMethods().getUsageInstance().usage(n, this.defaultCommand.description);
    }
    const e = this.defaultCommand.builder;
    if (Gn(e))
      return e(t, !0);
    vr(e) || Object.keys(e).forEach((n) => {
      t.option(n, e[n]);
    });
  }
  moduleName(t) {
    const e = Oo(t);
    if (!e)
      throw new Error(`No command name given for module: ${this.shim.inspect(t)}`);
    return this.commandFromFilename(e.filename);
  }
  commandFromFilename(t) {
    return this.shim.path.basename(t, this.shim.path.extname(t));
  }
  extractDesc({ describe: t, description: e, desc: n }) {
    for (const s of [t, e, n]) {
      if (typeof s == "string" || s === !1)
        return s;
      jt(s, !0, this.shim);
    }
    return !1;
  }
  freeze() {
    this.frozens.push({
      handlers: this.handlers,
      aliasMap: this.aliasMap,
      defaultCommand: this.defaultCommand
    });
  }
  unfreeze() {
    const t = this.frozens.pop();
    jt(t, void 0, this.shim), {
      handlers: this.handlers,
      aliasMap: this.aliasMap,
      defaultCommand: this.defaultCommand
    } = t;
  }
  reset() {
    return this.handlers = {}, this.aliasMap = {}, this.defaultCommand = void 0, this.requireCache = /* @__PURE__ */ new Set(), this;
  }
}
function Co(a, t, e, n) {
  return new Io(a, t, e, n);
}
function vr(a) {
  return typeof a == "object" && !!a.builder && typeof a.handler == "function";
}
function Do(a) {
  return a.every((t) => typeof t == "string");
}
function Gn(a) {
  return typeof a == "function";
}
function To(a) {
  return typeof a == "object";
}
function vo(a) {
  return typeof a == "object" && !Array.isArray(a);
}
function xe(a = {}, t = () => !0) {
  const e = {};
  return Ue(a).forEach((n) => {
    t(n, a[n]) && (e[n] = a[n]);
  }), e;
}
function me(a) {
  typeof process > "u" || [process.stdout, process.stderr].forEach((t) => {
    const e = t;
    e._handle && e.isTTY && typeof e._handle.setBlocking == "function" && e._handle.setBlocking(a);
  });
}
function _o(a) {
  return typeof a == "boolean";
}
function No(a, t) {
  const e = t.y18n.__, n = {}, s = [];
  n.failFn = function(R) {
    s.push(R);
  };
  let i = null, r = null, o = !0;
  n.showHelpOnFail = function(R = !0, $) {
    const [q, z] = typeof R == "string" ? [!0, R] : [R, $];
    return a.getInternalMethods().isGlobalContext() && (r = z), i = z, o = q, n;
  };
  let l = !1;
  n.fail = function(R, $) {
    const q = a.getInternalMethods().getLoggerInstance();
    if (s.length)
      for (let z = s.length - 1; z >= 0; --z) {
        const k = s[z];
        if (_o(k)) {
          if ($)
            throw $;
          if (R)
            throw Error(R);
        } else
          k(R, $, n);
      }
    else {
      if (a.getExitProcess() && me(!0), !l) {
        l = !0, o && (a.showHelp("error"), q.error()), (R || $) && q.error(R || $);
        const z = i || r;
        z && ((R || $) && q.error(""), q.error(z));
      }
      if ($ = $ || new gt(R), a.getExitProcess())
        return a.exit(1);
      if (a.getInternalMethods().hasParseCallback())
        return a.exit(1, $);
      throw $;
    }
  };
  let E = [], m = !1;
  n.usage = (S, R) => S === null ? (m = !0, E = [], n) : (m = !1, E.push([S, R || ""]), n), n.getUsage = () => E, n.getUsageDisabled = () => m, n.getPositionalGroupName = () => e("Positionals:");
  let p = [];
  n.example = (S, R) => {
    p.push([S, R || ""]);
  };
  let b = [];
  n.command = function(R, $, q, z, k = !1) {
    q && (b = b.map((V) => (V[2] = !1, V))), b.push([R, $ || "", q, z, k]);
  }, n.getCommands = () => b;
  let w = {};
  n.describe = function(R, $) {
    Array.isArray(R) ? R.forEach((q) => {
      n.describe(q, $);
    }) : typeof R == "object" ? Object.keys(R).forEach((q) => {
      n.describe(q, R[q]);
    }) : w[R] = $;
  }, n.getDescriptions = () => w;
  let D = [];
  n.epilog = (S) => {
    D.push(S);
  };
  let _ = !1, I;
  n.wrap = (S) => {
    _ = !0, I = S;
  }, n.getWrap = () => t.getEnv("YARGS_DISABLE_WRAP") ? null : (_ || (I = U(), _ = !0), I);
  const T = "__yargsString__:";
  n.deferY18nLookup = (S) => T + S, n.help = function() {
    if (v)
      return v;
    g();
    const R = a.customScriptName ? a.$0 : t.path.basename(a.$0), $ = a.getDemandedOptions(), q = a.getDemandedCommands(), z = a.getDeprecatedOptions(), k = a.getGroups(), V = a.getOptions();
    let ft = [];
    ft = ft.concat(Object.keys(w)), ft = ft.concat(Object.keys($)), ft = ft.concat(Object.keys(q)), ft = ft.concat(Object.keys(V.default)), ft = ft.filter(X), ft = Object.keys(ft.reduce((Q, x) => (x !== "_" && (Q[x] = !0), Q), {}));
    const Ot = n.getWrap(), at = t.cliui({
      width: Ot,
      wrap: !!Ot
    });
    if (!m) {
      if (E.length)
        E.forEach((Q) => {
          at.div({ text: `${Q[0].replace(/\$0/g, R)}` }), Q[1] && at.div({ text: `${Q[1]}`, padding: [1, 0, 0, 0] });
        }), at.div();
      else if (b.length) {
        let Q = null;
        q._ ? Q = `${R} <${e("command")}>
` : Q = `${R} [${e("command")}]
`, at.div(`${Q}`);
      }
    }
    if (b.length > 1 || b.length === 1 && !b[0][2]) {
      at.div(e("Commands:"));
      const Q = a.getInternalMethods().getContext(), x = Q.commands.length ? `${Q.commands.join(" ")} ` : "";
      a.getInternalMethods().getParserConfiguration()["sort-commands"] === !0 && (b = b.sort((F, P) => F[0].localeCompare(P[0])));
      const y = R ? `${R} ` : "";
      b.forEach((F) => {
        const P = `${y}${x}${F[0].replace(/^\$0 ?/, "")}`;
        at.span({
          text: P,
          padding: [0, 2, 0, 2],
          width: C(b, Ot, `${R}${x}`) + 4
        }, { text: F[1] });
        const J = [];
        F[2] && J.push(`[${e("default")}]`), F[3] && F[3].length && J.push(`[${e("aliases:")} ${F[3].join(", ")}]`), F[4] && (typeof F[4] == "string" ? J.push(`[${e("deprecated: %s", F[4])}]`) : J.push(`[${e("deprecated")}]`)), J.length ? at.div({
          text: J.join(" "),
          padding: [0, 0, 0, 2],
          align: "right"
        }) : at.div();
      }), at.div();
    }
    const ot = (Object.keys(V.alias) || []).concat(Object.keys(a.parsed.newAliases) || []);
    ft = ft.filter((Q) => !a.parsed.newAliases[Q] && ot.every((x) => (V.alias[x] || []).indexOf(Q) === -1));
    const ut = e("Options:");
    k[ut] || (k[ut] = []), M(ft, V.alias, k, ut);
    const vt = (Q) => /^--/.test(Ce(Q)), K = Object.keys(k).filter((Q) => k[Q].length > 0).map((Q) => {
      const x = k[Q].filter(X).map((y) => {
        if (ot.includes(y))
          return y;
        for (let F = 0, P; (P = ot[F]) !== void 0; F++)
          if ((V.alias[P] || []).includes(y))
            return P;
        return y;
      });
      return { groupName: Q, normalizedKeys: x };
    }).filter(({ normalizedKeys: Q }) => Q.length > 0).map(({ groupName: Q, normalizedKeys: x }) => {
      const y = x.reduce((F, P) => (F[P] = [P].concat(V.alias[P] || []).map((J) => Q === n.getPositionalGroupName() ? J : (/^[0-9]$/.test(J) ? V.boolean.includes(P) ? "-" : "--" : J.length > 1 ? "--" : "-") + J).sort((J, st) => vt(J) === vt(st) ? 0 : vt(J) ? 1 : -1).join(", "), F), {});
      return { groupName: Q, normalizedKeys: x, switches: y };
    });
    if (K.filter(({ groupName: Q }) => Q !== n.getPositionalGroupName()).some(({ normalizedKeys: Q, switches: x }) => !Q.every((y) => vt(x[y]))) && K.filter(({ groupName: Q }) => Q !== n.getPositionalGroupName()).forEach(({ normalizedKeys: Q, switches: x }) => {
      Q.forEach((y) => {
        vt(x[y]) && (x[y] = Ao(x[y], 4));
      });
    }), K.forEach(({ groupName: Q, normalizedKeys: x, switches: y }) => {
      at.div(Q), x.forEach((F) => {
        const P = y[F];
        let J = w[F] || "", st = null;
        J.includes(T) && (J = e(J.substring(T.length))), V.boolean.includes(F) && (st = `[${e("boolean")}]`), V.count.includes(F) && (st = `[${e("count")}]`), V.string.includes(F) && (st = `[${e("string")}]`), V.normalize.includes(F) && (st = `[${e("string")}]`), V.array.includes(F) && (st = `[${e("array")}]`), V.number.includes(F) && (st = `[${e("number")}]`);
        const rt = (f) => typeof f == "string" ? `[${e("deprecated: %s", f)}]` : `[${e("deprecated")}]`, ht = [
          F in z ? rt(z[F]) : null,
          st,
          F in $ ? `[${e("required")}]` : null,
          V.choices && V.choices[F] ? `[${e("choices:")} ${n.stringifiedValues(V.choices[F])}]` : null,
          W(V.default[F], V.defaultDescription[F])
        ].filter(Boolean).join(" ");
        at.span({
          text: Ce(P),
          padding: [0, 2, 0, 2 + _r(P)],
          width: C(y, Ot) + 4
        }, J);
        const A = a.getInternalMethods().getUsageConfiguration()["hide-types"] === !0;
        ht && !A ? at.div({ text: ht, padding: [0, 0, 0, 2], align: "right" }) : at.div();
      }), at.div();
    }), p.length && (at.div(e("Examples:")), p.forEach((Q) => {
      Q[0] = Q[0].replace(/\$0/g, R);
    }), p.forEach((Q) => {
      Q[1] === "" ? at.div({
        text: Q[0],
        padding: [0, 2, 0, 2]
      }) : at.div({
        text: Q[0],
        padding: [0, 2, 0, 2],
        width: C(p, Ot) + 4
      }, {
        text: Q[1]
      });
    }), at.div()), D.length > 0) {
      const Q = D.map((x) => x.replace(/\$0/g, R)).join(`
`);
      at.div(`${Q}
`);
    }
    return at.toString().replace(/\s*$/, "");
  };
  function C(S, R, $) {
    let q = 0;
    return Array.isArray(S) || (S = Object.values(S).map((z) => [z])), S.forEach((z) => {
      q = Math.max(t.stringWidth($ ? `${$} ${Ce(z[0])}` : Ce(z[0])) + _r(z[0]), q);
    }), R && (q = Math.min(q, parseInt((R * 0.5).toString(), 10))), q;
  }
  function g() {
    const S = a.getDemandedOptions(), R = a.getOptions();
    (Object.keys(R.alias) || []).forEach(($) => {
      R.alias[$].forEach((q) => {
        w[q] && n.describe($, w[q]), q in S && a.demandOption($, S[q]), R.boolean.includes(q) && a.boolean($), R.count.includes(q) && a.count($), R.string.includes(q) && a.string($), R.normalize.includes(q) && a.normalize($), R.array.includes(q) && a.array($), R.number.includes(q) && a.number($);
      });
    });
  }
  let v;
  n.cacheHelpMessage = function() {
    v = this.help();
  }, n.clearCachedHelpMessage = function() {
    v = void 0;
  }, n.hasCachedHelpMessage = function() {
    return !!v;
  };
  function M(S, R, $, q) {
    let z = [], k = null;
    return Object.keys($).forEach((V) => {
      z = z.concat($[V]);
    }), S.forEach((V) => {
      k = [V].concat(R[V]), k.some((ft) => z.indexOf(ft) !== -1) || $[q].push(V);
    }), z;
  }
  function X(S) {
    return a.getOptions().hiddenOptions.indexOf(S) < 0 || a.parsed.argv[a.getOptions().showHiddenOpt];
  }
  n.showHelp = (S) => {
    const R = a.getInternalMethods().getLoggerInstance();
    S || (S = "error"), (typeof S == "function" ? S : R[S])(n.help());
  }, n.functionDescription = (S) => ["(", S.name ? t.Parser.decamelize(S.name, "-") : e("generated-value"), ")"].join(""), n.stringifiedValues = function(R, $) {
    let q = "";
    const z = $ || ", ", k = [].concat(R);
    return !R || !k.length || k.forEach((V) => {
      q.length && (q += z), q += JSON.stringify(V);
    }), q;
  };
  function W(S, R) {
    let $ = `[${e("default:")} `;
    if (S === void 0 && !R)
      return null;
    if (R)
      $ += R;
    else
      switch (typeof S) {
        case "string":
          $ += `"${S}"`;
          break;
        case "object":
          $ += JSON.stringify(S);
          break;
        default:
          $ += S;
      }
    return `${$}]`;
  }
  function U() {
    return t.process.stdColumns ? Math.min(80, t.process.stdColumns) : 80;
  }
  let d = null;
  n.version = (S) => {
    d = S;
  }, n.showVersion = (S) => {
    const R = a.getInternalMethods().getLoggerInstance();
    S || (S = "error"), (typeof S == "function" ? S : R[S])(d);
  }, n.reset = function(R) {
    return i = null, l = !1, E = [], m = !1, D = [], p = [], b = [], w = xe(w, ($) => !R[$]), n;
  };
  const B = [];
  return n.freeze = function() {
    B.push({
      failMessage: i,
      failureOutput: l,
      usages: E,
      usageDisabled: m,
      epilogs: D,
      examples: p,
      commands: b,
      descriptions: w
    });
  }, n.unfreeze = function(R = !1) {
    const $ = B.pop();
    $ && (R ? (w = { ...$.descriptions, ...w }, b = [...$.commands, ...b], E = [...$.usages, ...E], p = [...$.examples, ...p], D = [...$.epilogs, ...D]) : {
      failMessage: i,
      failureOutput: l,
      usages: E,
      usageDisabled: m,
      epilogs: D,
      examples: p,
      commands: b,
      descriptions: w
    } = $);
  }, n;
}
function Qn(a) {
  return typeof a == "object";
}
function Ao(a, t) {
  return Qn(a) ? { text: a.text, indentation: a.indentation + t } : { text: a, indentation: t };
}
function _r(a) {
  return Qn(a) ? a.indentation : 0;
}
function Ce(a) {
  return Qn(a) ? a.text : a;
}
const Mo = `###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc
#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.
#
_{{app_name}}_yargs_completions()
{
    local cur_word args type_list

    cur_word="\${COMP_WORDS[COMP_CWORD]}"
    args=("\${COMP_WORDS[@]}")

    # ask yargs to generate completions.
    type_list=$({{app_path}} --get-yargs-completions "\${args[@]}")

    COMPREPLY=( $(compgen -W "\${type_list}" -- \${cur_word}) )

    # if no match was found, fall back to filename completion
    if [ \${#COMPREPLY[@]} -eq 0 ]; then
      COMPREPLY=()
    fi

    return 0
}
complete -o bashdefault -o default -F _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`, Po = `#compdef {{app_name}}
###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc
#    or {{app_path}} {{completion_command}} >> ~/.zprofile on OSX.
#
_{{app_name}}_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'
' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\${words[@]}"))
  IFS=$si
  _describe 'values' reply
}
compdef _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
class Lo {
  constructor(t, e, n, s) {
    var i, r, o;
    this.yargs = t, this.usage = e, this.command = n, this.shim = s, this.completionKey = "get-yargs-completions", this.aliases = null, this.customCompletionFunction = null, this.indexAfterLastReset = 0, this.zshShell = (o = ((i = this.shim.getEnv("SHELL")) === null || i === void 0 ? void 0 : i.includes("zsh")) || ((r = this.shim.getEnv("ZSH_NAME")) === null || r === void 0 ? void 0 : r.includes("zsh"))) !== null && o !== void 0 ? o : !1;
  }
  defaultCompletion(t, e, n, s) {
    const i = this.command.getCommandHandlers();
    for (let o = 0, l = t.length; o < l; ++o)
      if (i[t[o]] && i[t[o]].builder) {
        const E = i[t[o]].builder;
        if (Gn(E)) {
          this.indexAfterLastReset = o + 1;
          const m = this.yargs.getInternalMethods().reset();
          return E(m, !0), m.argv;
        }
      }
    const r = [];
    this.commandCompletions(r, t, n), this.optionCompletions(r, t, e, n), this.choicesFromOptionsCompletions(r, t, e, n), this.choicesFromPositionalsCompletions(r, t, e, n), s(null, r);
  }
  commandCompletions(t, e, n) {
    const s = this.yargs.getInternalMethods().getContext().commands;
    !n.match(/^-/) && s[s.length - 1] !== n && !this.previousArgHasChoices(e) && this.usage.getCommands().forEach((i) => {
      const r = ye(i[0]).cmd;
      if (e.indexOf(r) === -1)
        if (!this.zshShell)
          t.push(r);
        else {
          const o = i[1] || "";
          t.push(r.replace(/:/g, "\\:") + ":" + o);
        }
    });
  }
  optionCompletions(t, e, n, s) {
    if ((s.match(/^-/) || s === "" && t.length === 0) && !this.previousArgHasChoices(e)) {
      const i = this.yargs.getOptions(), r = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
      Object.keys(i.key).forEach((o) => {
        const l = !!i.configuration["boolean-negation"] && i.boolean.includes(o);
        !r.includes(o) && !i.hiddenOptions.includes(o) && !this.argsContainKey(e, o, l) && this.completeOptionKey(o, t, s, l && !!i.default[o]);
      });
    }
  }
  choicesFromOptionsCompletions(t, e, n, s) {
    if (this.previousArgHasChoices(e)) {
      const i = this.getPreviousArgChoices(e);
      i && i.length > 0 && t.push(...i.map((r) => r.replace(/:/g, "\\:")));
    }
  }
  choicesFromPositionalsCompletions(t, e, n, s) {
    if (s === "" && t.length > 0 && this.previousArgHasChoices(e))
      return;
    const i = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [], r = Math.max(this.indexAfterLastReset, this.yargs.getInternalMethods().getContext().commands.length + 1), o = i[n._.length - r - 1];
    if (!o)
      return;
    const l = this.yargs.getOptions().choices[o] || [];
    for (const E of l)
      E.startsWith(s) && t.push(E.replace(/:/g, "\\:"));
  }
  getPreviousArgChoices(t) {
    if (t.length < 1)
      return;
    let e = t[t.length - 1], n = "";
    if (!e.startsWith("-") && t.length > 1 && (n = e, e = t[t.length - 2]), !e.startsWith("-"))
      return;
    const s = e.replace(/^-+/, ""), i = this.yargs.getOptions(), r = [
      s,
      ...this.yargs.getAliases()[s] || []
    ];
    let o;
    for (const l of r)
      if (Object.prototype.hasOwnProperty.call(i.key, l) && Array.isArray(i.choices[l])) {
        o = i.choices[l];
        break;
      }
    if (o)
      return o.filter((l) => !n || l.startsWith(n));
  }
  previousArgHasChoices(t) {
    const e = this.getPreviousArgChoices(t);
    return e !== void 0 && e.length > 0;
  }
  argsContainKey(t, e, n) {
    const s = (i) => t.indexOf((/^[^0-9]$/.test(i) ? "-" : "--") + i) !== -1;
    if (s(e) || n && s(`no-${e}`))
      return !0;
    if (this.aliases) {
      for (const i of this.aliases[e])
        if (s(i))
          return !0;
    }
    return !1;
  }
  completeOptionKey(t, e, n, s) {
    var i, r, o, l;
    let E = t;
    if (this.zshShell) {
      const w = this.usage.getDescriptions(), D = (r = (i = this === null || this === void 0 ? void 0 : this.aliases) === null || i === void 0 ? void 0 : i[t]) === null || r === void 0 ? void 0 : r.find((T) => {
        const C = w[T];
        return typeof C == "string" && C.length > 0;
      }), _ = D ? w[D] : void 0, I = (l = (o = w[t]) !== null && o !== void 0 ? o : _) !== null && l !== void 0 ? l : "";
      E = `${t.replace(/:/g, "\\:")}:${I.replace("__yargsString__:", "").replace(/(\r\n|\n|\r)/gm, " ")}`;
    }
    const m = (w) => /^--/.test(w), p = (w) => /^[^0-9]$/.test(w), b = !m(n) && p(t) ? "-" : "--";
    e.push(b + E), s && e.push(b + "no-" + E);
  }
  customCompletion(t, e, n, s) {
    if (jt(this.customCompletionFunction, null, this.shim), Fo(this.customCompletionFunction)) {
      const i = this.customCompletionFunction(n, e);
      return yt(i) ? i.then((r) => {
        this.shim.process.nextTick(() => {
          s(null, r);
        });
      }).catch((r) => {
        this.shim.process.nextTick(() => {
          s(r, void 0);
        });
      }) : s(null, i);
    } else return jo(this.customCompletionFunction) ? this.customCompletionFunction(n, e, (i = s) => this.defaultCompletion(t, e, n, i), (i) => {
      s(null, i);
    }) : this.customCompletionFunction(n, e, (i) => {
      s(null, i);
    });
  }
  getCompletion(t, e) {
    const n = t.length ? t[t.length - 1] : "", s = this.yargs.parse(t, !0), i = this.customCompletionFunction ? (r) => this.customCompletion(t, r, n, e) : (r) => this.defaultCompletion(t, r, n, e);
    return yt(s) ? s.then(i) : i(s);
  }
  generateCompletionScript(t, e) {
    let n = this.zshShell ? Po : Mo;
    const s = this.shim.path.basename(t);
    return t.match(/\.js$/) && (t = `./${t}`), n = n.replace(/{{app_name}}/g, s), n = n.replace(/{{completion_command}}/g, e), n.replace(/{{app_path}}/g, t);
  }
  registerFunction(t) {
    this.customCompletionFunction = t;
  }
  setParsed(t) {
    this.aliases = t.aliases;
  }
}
function So(a, t, e, n) {
  return new Lo(a, t, e, n);
}
function Fo(a) {
  return a.length < 3;
}
function jo(a) {
  return a.length > 3;
}
function Bo(a, t) {
  if (a.length === 0)
    return t.length;
  if (t.length === 0)
    return a.length;
  const e = [];
  let n;
  for (n = 0; n <= t.length; n++)
    e[n] = [n];
  let s;
  for (s = 0; s <= a.length; s++)
    e[0][s] = s;
  for (n = 1; n <= t.length; n++)
    for (s = 1; s <= a.length; s++)
      t.charAt(n - 1) === a.charAt(s - 1) ? e[n][s] = e[n - 1][s - 1] : n > 1 && s > 1 && t.charAt(n - 2) === a.charAt(s - 1) && t.charAt(n - 1) === a.charAt(s - 2) ? e[n][s] = e[n - 2][s - 2] + 1 : e[n][s] = Math.min(e[n - 1][s - 1] + 1, Math.min(e[n][s - 1] + 1, e[n - 1][s] + 1));
  return e[t.length][a.length];
}
const Nr = ["$0", "--", "_"];
function Ro(a, t, e) {
  const n = e.y18n.__, s = e.y18n.__n, i = {};
  i.nonOptionCount = function(p) {
    const b = a.getDemandedCommands(), D = p._.length + (p["--"] ? p["--"].length : 0) - a.getInternalMethods().getContext().commands.length;
    b._ && (D < b._.min || D > b._.max) && (D < b._.min ? b._.minMsg !== void 0 ? t.fail(b._.minMsg ? b._.minMsg.replace(/\$0/g, D.toString()).replace(/\$1/, b._.min.toString()) : null) : t.fail(s("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", D, D.toString(), b._.min.toString())) : D > b._.max && (b._.maxMsg !== void 0 ? t.fail(b._.maxMsg ? b._.maxMsg.replace(/\$0/g, D.toString()).replace(/\$1/, b._.max.toString()) : null) : t.fail(s("Too many non-option arguments: got %s, maximum of %s", "Too many non-option arguments: got %s, maximum of %s", D, D.toString(), b._.max.toString()))));
  }, i.positionalCount = function(p, b) {
    b < p && t.fail(s("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", b, b + "", p + ""));
  }, i.requiredArguments = function(p, b) {
    let w = null;
    for (const D of Object.keys(b))
      (!Object.prototype.hasOwnProperty.call(p, D) || typeof p[D] > "u") && (w = w || {}, w[D] = b[D]);
    if (w) {
      const D = [];
      for (const I of Object.keys(w)) {
        const T = w[I];
        T && D.indexOf(T) < 0 && D.push(T);
      }
      const _ = D.length ? `
${D.join(`
`)}` : "";
      t.fail(s("Missing required argument: %s", "Missing required arguments: %s", Object.keys(w).length, Object.keys(w).join(", ") + _));
    }
  }, i.unknownArguments = function(p, b, w, D, _ = !0) {
    var I;
    const T = a.getInternalMethods().getCommandInstance().getCommands(), C = [], g = a.getInternalMethods().getContext();
    if (Object.keys(p).forEach((v) => {
      !Nr.includes(v) && !Object.prototype.hasOwnProperty.call(w, v) && !Object.prototype.hasOwnProperty.call(a.getInternalMethods().getParseContext(), v) && !i.isValidAndSomeAliasIsNotNew(v, b) && C.push(v);
    }), _ && (g.commands.length > 0 || T.length > 0 || D) && p._.slice(g.commands.length).forEach((v) => {
      T.includes("" + v) || C.push("" + v);
    }), _) {
      const M = ((I = a.getDemandedCommands()._) === null || I === void 0 ? void 0 : I.max) || 0, X = g.commands.length + M;
      X < p._.length && p._.slice(X).forEach((W) => {
        W = String(W), !g.commands.includes(W) && !C.includes(W) && C.push(W);
      });
    }
    C.length && t.fail(s("Unknown argument: %s", "Unknown arguments: %s", C.length, C.map((v) => v.trim() ? v : `"${v}"`).join(", ")));
  }, i.unknownCommands = function(p) {
    const b = a.getInternalMethods().getCommandInstance().getCommands(), w = [], D = a.getInternalMethods().getContext();
    return (D.commands.length > 0 || b.length > 0) && p._.slice(D.commands.length).forEach((_) => {
      b.includes("" + _) || w.push("" + _);
    }), w.length > 0 ? (t.fail(s("Unknown command: %s", "Unknown commands: %s", w.length, w.join(", "))), !0) : !1;
  }, i.isValidAndSomeAliasIsNotNew = function(p, b) {
    if (!Object.prototype.hasOwnProperty.call(b, p))
      return !1;
    const w = a.parsed.newAliases;
    return [p, ...b[p]].some((D) => !Object.prototype.hasOwnProperty.call(w, D) || !w[p]);
  }, i.limitedChoices = function(p) {
    const b = a.getOptions(), w = {};
    if (!Object.keys(b.choices).length)
      return;
    Object.keys(p).forEach((I) => {
      Nr.indexOf(I) === -1 && Object.prototype.hasOwnProperty.call(b.choices, I) && [].concat(p[I]).forEach((T) => {
        b.choices[I].indexOf(T) === -1 && T !== void 0 && (w[I] = (w[I] || []).concat(T));
      });
    });
    const D = Object.keys(w);
    if (!D.length)
      return;
    let _ = n("Invalid values:");
    D.forEach((I) => {
      _ += `
  ${n("Argument: %s, Given: %s, Choices: %s", I, t.stringifiedValues(w[I]), t.stringifiedValues(b.choices[I]))}`;
    }), t.fail(_);
  };
  let r = {};
  i.implies = function(p, b) {
    G("<string|object> [array|number|string]", [p, b], arguments.length), typeof p == "object" ? Object.keys(p).forEach((w) => {
      i.implies(w, p[w]);
    }) : (a.global(p), r[p] || (r[p] = []), Array.isArray(b) ? b.forEach((w) => i.implies(p, w)) : (jt(b, void 0, e), r[p].push(b)));
  }, i.getImplied = function() {
    return r;
  };
  function o(m, p) {
    const b = Number(p);
    return p = isNaN(b) ? p : b, typeof p == "number" ? p = m._.length >= p : p.match(/^--no-.+/) ? (p = p.match(/^--no-(.+)/)[1], p = !Object.prototype.hasOwnProperty.call(m, p)) : p = Object.prototype.hasOwnProperty.call(m, p), p;
  }
  i.implications = function(p) {
    const b = [];
    if (Object.keys(r).forEach((w) => {
      const D = w;
      (r[w] || []).forEach((_) => {
        let I = D;
        const T = _;
        I = o(p, I), _ = o(p, _), I && !_ && b.push(` ${D} -> ${T}`);
      });
    }), b.length) {
      let w = `${n("Implications failed:")}
`;
      b.forEach((D) => {
        w += D;
      }), t.fail(w);
    }
  };
  let l = {};
  i.conflicts = function(p, b) {
    G("<string|object> [array|string]", [p, b], arguments.length), typeof p == "object" ? Object.keys(p).forEach((w) => {
      i.conflicts(w, p[w]);
    }) : (a.global(p), l[p] || (l[p] = []), Array.isArray(b) ? b.forEach((w) => i.conflicts(p, w)) : l[p].push(b));
  }, i.getConflicting = () => l, i.conflicting = function(p) {
    Object.keys(p).forEach((b) => {
      l[b] && l[b].forEach((w) => {
        w && p[b] !== void 0 && p[w] !== void 0 && t.fail(n("Arguments %s and %s are mutually exclusive", b, w));
      });
    }), a.getInternalMethods().getParserConfiguration()["strip-dashed"] && Object.keys(l).forEach((b) => {
      l[b].forEach((w) => {
        w && p[e.Parser.camelCase(b)] !== void 0 && p[e.Parser.camelCase(w)] !== void 0 && t.fail(n("Arguments %s and %s are mutually exclusive", b, w));
      });
    });
  }, i.recommendCommands = function(p, b) {
    b = b.sort((I, T) => T.length - I.length);
    let D = null, _ = 1 / 0;
    for (let I = 0, T; (T = b[I]) !== void 0; I++) {
      const C = Bo(p, T);
      C <= 3 && C < _ && (_ = C, D = T);
    }
    D && t.fail(n("Did you mean %s?", D));
  }, i.reset = function(p) {
    return r = xe(r, (b) => !p[b]), l = xe(l, (b) => !p[b]), i;
  };
  const E = [];
  return i.freeze = function() {
    E.push({
      implied: r,
      conflicting: l
    });
  }, i.unfreeze = function() {
    const p = E.pop();
    jt(p, void 0, e), { implied: r, conflicting: l } = p;
  }, i;
}
let zn = [], ge;
function Yn(a, t, e, n) {
  ge = n;
  let s = {};
  if (Object.prototype.hasOwnProperty.call(a, "extends")) {
    if (typeof a.extends != "string")
      return s;
    const i = /\.json|\..*rc$/.test(a.extends);
    let r = null;
    if (i)
      r = Xo(t, a.extends);
    else
      try {
        r = require.resolve(a.extends);
      } catch {
        return a;
      }
    Uo(r), zn.push(r), s = i ? JSON.parse(ge.readFileSync(r, "utf8")) : require(a.extends), delete a.extends, s = Yn(s, ge.path.dirname(r), e, ge);
  }
  return zn = [], e ? ss(s, a) : Object.assign({}, s, a);
}
function Uo(a) {
  if (zn.indexOf(a) > -1)
    throw new gt(`Circular extended configurations: '${a}'.`);
}
function Xo(a, t) {
  return ge.path.resolve(a, t);
}
function ss(a, t) {
  const e = {};
  function n(s) {
    return s && typeof s == "object" && !Array.isArray(s);
  }
  Object.assign(e, a);
  for (const s of Object.keys(t))
    n(t[s]) && n(e[s]) ? e[s] = ss(a[s], t[s]) : e[s] = t[s];
  return e;
}
var H = function(a, t, e, n, s) {
  if (n === "m") throw new TypeError("Private method is not writable");
  if (n === "a" && !s) throw new TypeError("Private accessor was defined without a setter");
  if (typeof t == "function" ? a !== t || !s : !t.has(a)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return n === "a" ? s.call(a, e) : s ? s.value = e : t.set(a, e), e;
}, O = function(a, t, e, n) {
  if (e === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? a !== t || !n : !t.has(a)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return e === "m" ? n : e === "a" ? n.call(a) : n ? n.value : t.get(a);
}, mt, zt, fe, _t, It, De, Vt, Yt, Te, Nt, ve, At, Rt, Ct, Mt, _e, se, wt, Y, Ne, Ae, Dt, kt, oe, Kt, Ht, Me, tt, Qt, Jt, Zt, et, Pe, Ut, dt;
function $o(a) {
  return (t = [], e = a.process.cwd(), n) => {
    const s = new Wo(t, e, n, a);
    return Object.defineProperty(s, "argv", {
      get: () => s.parse(),
      enumerable: !0
    }), s.help(), s.version(), s;
  };
}
const Ar = Symbol("copyDoubleDash"), Mr = Symbol("copyDoubleDash"), Ye = Symbol("deleteFromParserHintObject"), Pr = Symbol("emitWarning"), Lr = Symbol("freeze"), Sr = Symbol("getDollarZero"), te = Symbol("getParserConfiguration"), Fr = Symbol("getUsageConfiguration"), ke = Symbol("guessLocale"), jr = Symbol("guessVersion"), Br = Symbol("parsePositionalNumbers"), Ke = Symbol("pkgUp"), Gt = Symbol("populateParserHintArray"), ae = Symbol("populateParserHintSingleValueDictionary"), Qe = Symbol("populateParserHintArrayDictionary"), Je = Symbol("populateParserHintDictionary"), Ze = Symbol("sanitizeKey"), tn = Symbol("setKey"), en = Symbol("unfreeze"), Rr = Symbol("validateAsync"), Ur = Symbol("getCommandInstance"), Xr = Symbol("getContext"), $r = Symbol("getHasOutput"), Wr = Symbol("getLoggerInstance"), qr = Symbol("getParseContext"), Vr = Symbol("getUsageInstance"), Hr = Symbol("getValidationInstance"), Le = Symbol("hasParseCallback"), Gr = Symbol("isGlobalContext"), ee = Symbol("postProcess"), zr = Symbol("rebase"), nn = Symbol("reset"), he = Symbol("runYargsParserAndExecuteCommands"), rn = Symbol("runValidation"), Yr = Symbol("setHasOutput"), ne = Symbol("kTrackManuallySetKeys");
class Wo {
  constructor(t = [], e, n, s) {
    this.customScriptName = !1, this.parsed = !1, mt.set(this, void 0), zt.set(this, void 0), fe.set(this, { commands: [], fullCommands: [] }), _t.set(this, null), It.set(this, null), De.set(this, "show-hidden"), Vt.set(this, null), Yt.set(this, !0), Te.set(this, {}), Nt.set(this, !0), ve.set(this, []), At.set(this, void 0), Rt.set(this, {}), Ct.set(this, !1), Mt.set(this, null), _e.set(this, !0), se.set(this, void 0), wt.set(this, ""), Y.set(this, void 0), Ne.set(this, void 0), Ae.set(this, {}), Dt.set(this, null), kt.set(this, null), oe.set(this, {}), Kt.set(this, {}), Ht.set(this, void 0), Me.set(this, !1), tt.set(this, void 0), Qt.set(this, !1), Jt.set(this, !1), Zt.set(this, !1), et.set(this, void 0), Pe.set(this, {}), Ut.set(this, null), dt.set(this, void 0), H(this, tt, s, "f"), H(this, Ht, t, "f"), H(this, zt, e, "f"), H(this, Ne, n, "f"), H(this, At, new wo(this), "f"), this.$0 = this[Sr](), this[nn](), H(this, mt, O(this, mt, "f"), "f"), H(this, et, O(this, et, "f"), "f"), H(this, dt, O(this, dt, "f"), "f"), H(this, Y, O(this, Y, "f"), "f"), O(this, Y, "f").showHiddenOpt = O(this, De, "f"), H(this, se, this[Mr](), "f");
  }
  addHelpOpt(t, e) {
    const n = "help";
    return G("[string|boolean] [string]", [t, e], arguments.length), O(this, Mt, "f") && (this[Ye](O(this, Mt, "f")), H(this, Mt, null, "f")), t === !1 && e === void 0 ? this : (H(this, Mt, typeof t == "string" ? t : n, "f"), this.boolean(O(this, Mt, "f")), this.describe(O(this, Mt, "f"), e || O(this, et, "f").deferY18nLookup("Show help")), this);
  }
  help(t, e) {
    return this.addHelpOpt(t, e);
  }
  addShowHiddenOpt(t, e) {
    if (G("[string|boolean] [string]", [t, e], arguments.length), t === !1 && e === void 0)
      return this;
    const n = typeof t == "string" ? t : O(this, De, "f");
    return this.boolean(n), this.describe(n, e || O(this, et, "f").deferY18nLookup("Show hidden options")), O(this, Y, "f").showHiddenOpt = n, this;
  }
  showHidden(t, e) {
    return this.addShowHiddenOpt(t, e);
  }
  alias(t, e) {
    return G("<object|string|array> [string|array]", [t, e], arguments.length), this[Qe](this.alias.bind(this), "alias", t, e), this;
  }
  array(t) {
    return G("<array|string>", [t], arguments.length), this[Gt]("array", t), this[ne](t), this;
  }
  boolean(t) {
    return G("<array|string>", [t], arguments.length), this[Gt]("boolean", t), this[ne](t), this;
  }
  check(t, e) {
    return G("<function> [boolean]", [t, e], arguments.length), this.middleware((n, s) => we(() => t(n, s.getOptions()), (i) => (i ? (typeof i == "string" || i instanceof Error) && O(this, et, "f").fail(i.toString(), i) : O(this, et, "f").fail(O(this, tt, "f").y18n.__("Argument check failed: %s", t.toString())), n), (i) => (O(this, et, "f").fail(i.message ? i.message : i.toString(), i), n)), !1, e), this;
  }
  choices(t, e) {
    return G("<object|string|array> [string|array]", [t, e], arguments.length), this[Qe](this.choices.bind(this), "choices", t, e), this;
  }
  coerce(t, e) {
    if (G("<object|string|array> [function]", [t, e], arguments.length), Array.isArray(t)) {
      if (!e)
        throw new gt("coerce callback must be provided");
      for (const n of t)
        this.coerce(n, e);
      return this;
    } else if (typeof t == "object") {
      for (const n of Object.keys(t))
        this.coerce(n, t[n]);
      return this;
    }
    if (!e)
      throw new gt("coerce callback must be provided");
    return O(this, Y, "f").key[t] = !0, O(this, At, "f").addCoerceMiddleware((n, s) => {
      let i;
      return Object.prototype.hasOwnProperty.call(n, t) ? we(() => (i = s.getAliases(), e(n[t])), (o) => {
        n[t] = o;
        const l = s.getInternalMethods().getParserConfiguration()["strip-aliased"];
        if (i[t] && l !== !0)
          for (const E of i[t])
            n[E] = o;
        return n;
      }, (o) => {
        throw new gt(o.message);
      }) : n;
    }, t), this;
  }
  conflicts(t, e) {
    return G("<string|object> [string|array]", [t, e], arguments.length), O(this, dt, "f").conflicts(t, e), this;
  }
  config(t = "config", e, n) {
    return G("[object|string] [string|function] [function]", [t, e, n], arguments.length), typeof t == "object" && !Array.isArray(t) ? (t = Yn(t, O(this, zt, "f"), this[te]()["deep-merge-config"] || !1, O(this, tt, "f")), O(this, Y, "f").configObjects = (O(this, Y, "f").configObjects || []).concat(t), this) : (typeof e == "function" && (n = e, e = void 0), this.describe(t, e || O(this, et, "f").deferY18nLookup("Path to JSON config file")), (Array.isArray(t) ? t : [t]).forEach((s) => {
      O(this, Y, "f").config[s] = n || !0;
    }), this);
  }
  completion(t, e, n) {
    return G("[string] [string|boolean|function] [function]", [t, e, n], arguments.length), typeof e == "function" && (n = e, e = void 0), H(this, It, t || O(this, It, "f") || "completion", "f"), !e && e !== !1 && (e = "generate completion script"), this.command(O(this, It, "f"), e), n && O(this, _t, "f").registerFunction(n), this;
  }
  command(t, e, n, s, i, r) {
    return G("<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]", [t, e, n, s, i, r], arguments.length), O(this, mt, "f").addHandler(t, e, n, s, i, r), this;
  }
  commands(t, e, n, s, i, r) {
    return this.command(t, e, n, s, i, r);
  }
  commandDir(t, e) {
    G("<string> [object]", [t, e], arguments.length);
    const n = O(this, Ne, "f") || O(this, tt, "f").require;
    return O(this, mt, "f").addDirectory(t, n, O(this, tt, "f").getCallerFile(), e), this;
  }
  count(t) {
    return G("<array|string>", [t], arguments.length), this[Gt]("count", t), this[ne](t), this;
  }
  default(t, e, n) {
    return G("<object|string|array> [*] [string]", [t, e, n], arguments.length), n && (Cr(t, O(this, tt, "f")), O(this, Y, "f").defaultDescription[t] = n), typeof e == "function" && (Cr(t, O(this, tt, "f")), O(this, Y, "f").defaultDescription[t] || (O(this, Y, "f").defaultDescription[t] = O(this, et, "f").functionDescription(e)), e = e.call()), this[ae](this.default.bind(this), "default", t, e), this;
  }
  defaults(t, e, n) {
    return this.default(t, e, n);
  }
  demandCommand(t = 1, e, n, s) {
    return G("[number] [number|string] [string|null|undefined] [string|null|undefined]", [t, e, n, s], arguments.length), typeof e != "number" && (n = e, e = 1 / 0), this.global("_", !1), O(this, Y, "f").demandedCommands._ = {
      min: t,
      max: e,
      minMsg: n,
      maxMsg: s
    }, this;
  }
  demand(t, e, n) {
    return Array.isArray(e) ? (e.forEach((s) => {
      jt(n, !0, O(this, tt, "f")), this.demandOption(s, n);
    }), e = 1 / 0) : typeof e != "number" && (n = e, e = 1 / 0), typeof t == "number" ? (jt(n, !0, O(this, tt, "f")), this.demandCommand(t, e, n, n)) : Array.isArray(t) ? t.forEach((s) => {
      jt(n, !0, O(this, tt, "f")), this.demandOption(s, n);
    }) : typeof n == "string" ? this.demandOption(t, n) : (n === !0 || typeof n > "u") && this.demandOption(t), this;
  }
  demandOption(t, e) {
    return G("<object|string|array> [string]", [t, e], arguments.length), this[ae](this.demandOption.bind(this), "demandedOptions", t, e), this;
  }
  deprecateOption(t, e) {
    return G("<string> [string|boolean]", [t, e], arguments.length), O(this, Y, "f").deprecatedOptions[t] = e, this;
  }
  describe(t, e) {
    return G("<object|string|array> [string]", [t, e], arguments.length), this[tn](t, !0), O(this, et, "f").describe(t, e), this;
  }
  detectLocale(t) {
    return G("<boolean>", [t], arguments.length), H(this, Yt, t, "f"), this;
  }
  env(t) {
    return G("[string|boolean]", [t], arguments.length), t === !1 ? delete O(this, Y, "f").envPrefix : O(this, Y, "f").envPrefix = t || "", this;
  }
  epilogue(t) {
    return G("<string>", [t], arguments.length), O(this, et, "f").epilog(t), this;
  }
  epilog(t) {
    return this.epilogue(t);
  }
  example(t, e) {
    return G("<string|array> [string]", [t, e], arguments.length), Array.isArray(t) ? t.forEach((n) => this.example(...n)) : O(this, et, "f").example(t, e), this;
  }
  exit(t, e) {
    H(this, Ct, !0, "f"), H(this, Vt, e, "f"), O(this, Nt, "f") && O(this, tt, "f").process.exit(t);
  }
  exitProcess(t = !0) {
    return G("[boolean]", [t], arguments.length), H(this, Nt, t, "f"), this;
  }
  fail(t) {
    if (G("<function|boolean>", [t], arguments.length), typeof t == "boolean" && t !== !1)
      throw new gt("Invalid first argument. Expected function or boolean 'false'");
    return O(this, et, "f").failFn(t), this;
  }
  getAliases() {
    return this.parsed ? this.parsed.aliases : {};
  }
  async getCompletion(t, e) {
    return G("<array> [function]", [t, e], arguments.length), e ? O(this, _t, "f").getCompletion(t, e) : new Promise((n, s) => {
      O(this, _t, "f").getCompletion(t, (i, r) => {
        i ? s(i) : n(r);
      });
    });
  }
  getDemandedOptions() {
    return G([], 0), O(this, Y, "f").demandedOptions;
  }
  getDemandedCommands() {
    return G([], 0), O(this, Y, "f").demandedCommands;
  }
  getDeprecatedOptions() {
    return G([], 0), O(this, Y, "f").deprecatedOptions;
  }
  getDetectLocale() {
    return O(this, Yt, "f");
  }
  getExitProcess() {
    return O(this, Nt, "f");
  }
  getGroups() {
    return Object.assign({}, O(this, Rt, "f"), O(this, Kt, "f"));
  }
  getHelp() {
    if (H(this, Ct, !0, "f"), !O(this, et, "f").hasCachedHelpMessage()) {
      if (!this.parsed) {
        const e = this[he](O(this, Ht, "f"), void 0, void 0, 0, !0);
        if (yt(e))
          return e.then(() => O(this, et, "f").help());
      }
      const t = O(this, mt, "f").runDefaultBuilderOn(this);
      if (yt(t))
        return t.then(() => O(this, et, "f").help());
    }
    return Promise.resolve(O(this, et, "f").help());
  }
  getOptions() {
    return O(this, Y, "f");
  }
  getStrict() {
    return O(this, Qt, "f");
  }
  getStrictCommands() {
    return O(this, Jt, "f");
  }
  getStrictOptions() {
    return O(this, Zt, "f");
  }
  global(t, e) {
    return G("<string|array> [boolean]", [t, e], arguments.length), t = [].concat(t), e !== !1 ? O(this, Y, "f").local = O(this, Y, "f").local.filter((n) => t.indexOf(n) === -1) : t.forEach((n) => {
      O(this, Y, "f").local.includes(n) || O(this, Y, "f").local.push(n);
    }), this;
  }
  group(t, e) {
    G("<string|array> <string>", [t, e], arguments.length);
    const n = O(this, Kt, "f")[e] || O(this, Rt, "f")[e];
    O(this, Kt, "f")[e] && delete O(this, Kt, "f")[e];
    const s = {};
    return O(this, Rt, "f")[e] = (n || []).concat(t).filter((i) => s[i] ? !1 : s[i] = !0), this;
  }
  hide(t) {
    return G("<string>", [t], arguments.length), O(this, Y, "f").hiddenOptions.push(t), this;
  }
  implies(t, e) {
    return G("<string|object> [number|string|array]", [t, e], arguments.length), O(this, dt, "f").implies(t, e), this;
  }
  locale(t) {
    return G("[string]", [t], arguments.length), t === void 0 ? (this[ke](), O(this, tt, "f").y18n.getLocale()) : (H(this, Yt, !1, "f"), O(this, tt, "f").y18n.setLocale(t), this);
  }
  middleware(t, e, n) {
    return O(this, At, "f").addMiddleware(t, !!e, n);
  }
  nargs(t, e) {
    return G("<string|object|array> [number]", [t, e], arguments.length), this[ae](this.nargs.bind(this), "narg", t, e), this;
  }
  normalize(t) {
    return G("<array|string>", [t], arguments.length), this[Gt]("normalize", t), this;
  }
  number(t) {
    return G("<array|string>", [t], arguments.length), this[Gt]("number", t), this[ne](t), this;
  }
  option(t, e) {
    if (G("<string|object> [object]", [t, e], arguments.length), typeof t == "object")
      Object.keys(t).forEach((n) => {
        this.options(n, t[n]);
      });
    else {
      typeof e != "object" && (e = {}), this[ne](t), O(this, Ut, "f") && (t === "version" || e?.alias === "version") && this[Pr]([
        '"version" is a reserved word.',
        "Please do one of the following:",
        '- Disable version with `yargs.version(false)` if using "version" as an option',
        "- Use the built-in `yargs.version` method instead (if applicable)",
        "- Use a different option key",
        "https://yargs.js.org/docs/#api-reference-version"
      ].join(`
`), void 0, "versionWarning"), O(this, Y, "f").key[t] = !0, e.alias && this.alias(t, e.alias);
      const n = e.deprecate || e.deprecated;
      n && this.deprecateOption(t, n);
      const s = e.demand || e.required || e.require;
      s && this.demand(t, s), e.demandOption && this.demandOption(t, typeof e.demandOption == "string" ? e.demandOption : void 0), e.conflicts && this.conflicts(t, e.conflicts), "default" in e && this.default(t, e.default), e.implies !== void 0 && this.implies(t, e.implies), e.nargs !== void 0 && this.nargs(t, e.nargs), e.config && this.config(t, e.configParser), e.normalize && this.normalize(t), e.choices && this.choices(t, e.choices), e.coerce && this.coerce(t, e.coerce), e.group && this.group(t, e.group), (e.boolean || e.type === "boolean") && (this.boolean(t), e.alias && this.boolean(e.alias)), (e.array || e.type === "array") && (this.array(t), e.alias && this.array(e.alias)), (e.number || e.type === "number") && (this.number(t), e.alias && this.number(e.alias)), (e.string || e.type === "string") && (this.string(t), e.alias && this.string(e.alias)), (e.count || e.type === "count") && this.count(t), typeof e.global == "boolean" && this.global(t, e.global), e.defaultDescription && (O(this, Y, "f").defaultDescription[t] = e.defaultDescription), e.skipValidation && this.skipValidation(t);
      const i = e.describe || e.description || e.desc, r = O(this, et, "f").getDescriptions();
      (!Object.prototype.hasOwnProperty.call(r, t) || typeof i == "string") && this.describe(t, i), e.hidden && this.hide(t), e.requiresArg && this.requiresArg(t);
    }
    return this;
  }
  options(t, e) {
    return this.option(t, e);
  }
  parse(t, e, n) {
    G("[string|array] [function|boolean|object] [function]", [t, e, n], arguments.length), this[Lr](), typeof t > "u" && (t = O(this, Ht, "f")), typeof e == "object" && (H(this, kt, e, "f"), e = n), typeof e == "function" && (H(this, Dt, e, "f"), e = !1), e || H(this, Ht, t, "f"), O(this, Dt, "f") && H(this, Nt, !1, "f");
    const s = this[he](t, !!e), i = this.parsed;
    return O(this, _t, "f").setParsed(this.parsed), yt(s) ? s.then((r) => (O(this, Dt, "f") && O(this, Dt, "f").call(this, O(this, Vt, "f"), r, O(this, wt, "f")), r)).catch((r) => {
      throw O(this, Dt, "f") && O(this, Dt, "f")(r, this.parsed.argv, O(this, wt, "f")), r;
    }).finally(() => {
      this[en](), this.parsed = i;
    }) : (O(this, Dt, "f") && O(this, Dt, "f").call(this, O(this, Vt, "f"), s, O(this, wt, "f")), this[en](), this.parsed = i, s);
  }
  parseAsync(t, e, n) {
    const s = this.parse(t, e, n);
    return yt(s) ? s : Promise.resolve(s);
  }
  parseSync(t, e, n) {
    const s = this.parse(t, e, n);
    if (yt(s))
      throw new gt(".parseSync() must not be used with asynchronous builders, handlers, or middleware");
    return s;
  }
  parserConfiguration(t) {
    return G("<object>", [t], arguments.length), H(this, Ae, t, "f"), this;
  }
  pkgConf(t, e) {
    G("<string> [string]", [t, e], arguments.length);
    let n = null;
    const s = this[Ke](e || O(this, zt, "f"));
    return s[t] && typeof s[t] == "object" && (n = Yn(s[t], e || O(this, zt, "f"), this[te]()["deep-merge-config"] || !1, O(this, tt, "f")), O(this, Y, "f").configObjects = (O(this, Y, "f").configObjects || []).concat(n)), this;
  }
  positional(t, e) {
    G("<string> <object>", [t, e], arguments.length);
    const n = [
      "default",
      "defaultDescription",
      "implies",
      "normalize",
      "choices",
      "conflicts",
      "coerce",
      "type",
      "describe",
      "desc",
      "description",
      "alias"
    ];
    e = xe(e, (r, o) => r === "type" && !["string", "number", "boolean"].includes(o) ? !1 : n.includes(r));
    const s = O(this, fe, "f").fullCommands[O(this, fe, "f").fullCommands.length - 1], i = s ? O(this, mt, "f").cmdToParseOptions(s) : {
      array: [],
      alias: {},
      default: {},
      demand: {}
    };
    return Ue(i).forEach((r) => {
      const o = i[r];
      Array.isArray(o) ? o.indexOf(t) !== -1 && (e[r] = !0) : o[t] && !(r in e) && (e[r] = o[t]);
    }), this.group(t, O(this, et, "f").getPositionalGroupName()), this.option(t, e);
  }
  recommendCommands(t = !0) {
    return G("[boolean]", [t], arguments.length), H(this, Me, t, "f"), this;
  }
  required(t, e, n) {
    return this.demand(t, e, n);
  }
  require(t, e, n) {
    return this.demand(t, e, n);
  }
  requiresArg(t) {
    return G("<array|string|object> [number]", [t], arguments.length), typeof t == "string" && O(this, Y, "f").narg[t] ? this : (this[ae](this.requiresArg.bind(this), "narg", t, NaN), this);
  }
  showCompletionScript(t, e) {
    return G("[string] [string]", [t, e], arguments.length), t = t || this.$0, O(this, se, "f").log(O(this, _t, "f").generateCompletionScript(t, e || O(this, It, "f") || "completion")), this;
  }
  showHelp(t) {
    if (G("[string|function]", [t], arguments.length), H(this, Ct, !0, "f"), !O(this, et, "f").hasCachedHelpMessage()) {
      if (!this.parsed) {
        const n = this[he](O(this, Ht, "f"), void 0, void 0, 0, !0);
        if (yt(n))
          return n.then(() => {
            O(this, et, "f").showHelp(t);
          }), this;
      }
      const e = O(this, mt, "f").runDefaultBuilderOn(this);
      if (yt(e))
        return e.then(() => {
          O(this, et, "f").showHelp(t);
        }), this;
    }
    return O(this, et, "f").showHelp(t), this;
  }
  scriptName(t) {
    return this.customScriptName = !0, this.$0 = t, this;
  }
  showHelpOnFail(t, e) {
    return G("[boolean|string] [string]", [t, e], arguments.length), O(this, et, "f").showHelpOnFail(t, e), this;
  }
  showVersion(t) {
    return G("[string|function]", [t], arguments.length), O(this, et, "f").showVersion(t), this;
  }
  skipValidation(t) {
    return G("<array|string>", [t], arguments.length), this[Gt]("skipValidation", t), this;
  }
  strict(t) {
    return G("[boolean]", [t], arguments.length), H(this, Qt, t !== !1, "f"), this;
  }
  strictCommands(t) {
    return G("[boolean]", [t], arguments.length), H(this, Jt, t !== !1, "f"), this;
  }
  strictOptions(t) {
    return G("[boolean]", [t], arguments.length), H(this, Zt, t !== !1, "f"), this;
  }
  string(t) {
    return G("<array|string>", [t], arguments.length), this[Gt]("string", t), this[ne](t), this;
  }
  terminalWidth() {
    return G([], 0), O(this, tt, "f").process.stdColumns;
  }
  updateLocale(t) {
    return this.updateStrings(t);
  }
  updateStrings(t) {
    return G("<object>", [t], arguments.length), H(this, Yt, !1, "f"), O(this, tt, "f").y18n.updateLocale(t), this;
  }
  usage(t, e, n, s) {
    if (G("<string|null|undefined> [string|boolean] [function|object] [function]", [t, e, n, s], arguments.length), e !== void 0) {
      if (jt(t, null, O(this, tt, "f")), (t || "").match(/^\$0( |$)/))
        return this.command(t, e, n, s);
      throw new gt(".usage() description must start with $0 if being used as alias for .command()");
    } else
      return O(this, et, "f").usage(t), this;
  }
  usageConfiguration(t) {
    return G("<object>", [t], arguments.length), H(this, Pe, t, "f"), this;
  }
  version(t, e, n) {
    const s = "version";
    if (G("[boolean|string] [string] [string]", [t, e, n], arguments.length), O(this, Ut, "f") && (this[Ye](O(this, Ut, "f")), O(this, et, "f").version(void 0), H(this, Ut, null, "f")), arguments.length === 0)
      n = this[jr](), t = s;
    else if (arguments.length === 1) {
      if (t === !1)
        return this;
      n = t, t = s;
    } else arguments.length === 2 && (n = e, e = void 0);
    return H(this, Ut, typeof t == "string" ? t : s, "f"), e = e || O(this, et, "f").deferY18nLookup("Show version number"), O(this, et, "f").version(n || void 0), this.boolean(O(this, Ut, "f")), this.describe(O(this, Ut, "f"), e), this;
  }
  wrap(t) {
    return G("<number|null|undefined>", [t], arguments.length), O(this, et, "f").wrap(t), this;
  }
  [(mt = /* @__PURE__ */ new WeakMap(), zt = /* @__PURE__ */ new WeakMap(), fe = /* @__PURE__ */ new WeakMap(), _t = /* @__PURE__ */ new WeakMap(), It = /* @__PURE__ */ new WeakMap(), De = /* @__PURE__ */ new WeakMap(), Vt = /* @__PURE__ */ new WeakMap(), Yt = /* @__PURE__ */ new WeakMap(), Te = /* @__PURE__ */ new WeakMap(), Nt = /* @__PURE__ */ new WeakMap(), ve = /* @__PURE__ */ new WeakMap(), At = /* @__PURE__ */ new WeakMap(), Rt = /* @__PURE__ */ new WeakMap(), Ct = /* @__PURE__ */ new WeakMap(), Mt = /* @__PURE__ */ new WeakMap(), _e = /* @__PURE__ */ new WeakMap(), se = /* @__PURE__ */ new WeakMap(), wt = /* @__PURE__ */ new WeakMap(), Y = /* @__PURE__ */ new WeakMap(), Ne = /* @__PURE__ */ new WeakMap(), Ae = /* @__PURE__ */ new WeakMap(), Dt = /* @__PURE__ */ new WeakMap(), kt = /* @__PURE__ */ new WeakMap(), oe = /* @__PURE__ */ new WeakMap(), Kt = /* @__PURE__ */ new WeakMap(), Ht = /* @__PURE__ */ new WeakMap(), Me = /* @__PURE__ */ new WeakMap(), tt = /* @__PURE__ */ new WeakMap(), Qt = /* @__PURE__ */ new WeakMap(), Jt = /* @__PURE__ */ new WeakMap(), Zt = /* @__PURE__ */ new WeakMap(), et = /* @__PURE__ */ new WeakMap(), Pe = /* @__PURE__ */ new WeakMap(), Ut = /* @__PURE__ */ new WeakMap(), dt = /* @__PURE__ */ new WeakMap(), Ar)](t) {
    if (!t._ || !t["--"])
      return t;
    t._.push.apply(t._, t["--"]);
    try {
      delete t["--"];
    } catch {
    }
    return t;
  }
  [Mr]() {
    return {
      log: (...t) => {
        this[Le]() || console.log(...t), H(this, Ct, !0, "f"), O(this, wt, "f").length && H(this, wt, O(this, wt, "f") + `
`, "f"), H(this, wt, O(this, wt, "f") + t.join(" "), "f");
      },
      error: (...t) => {
        this[Le]() || console.error(...t), H(this, Ct, !0, "f"), O(this, wt, "f").length && H(this, wt, O(this, wt, "f") + `
`, "f"), H(this, wt, O(this, wt, "f") + t.join(" "), "f");
      }
    };
  }
  [Ye](t) {
    Ue(O(this, Y, "f")).forEach((e) => {
      if (/* @__PURE__ */ ((s) => s === "configObjects")(e))
        return;
      const n = O(this, Y, "f")[e];
      Array.isArray(n) ? n.includes(t) && n.splice(n.indexOf(t), 1) : typeof n == "object" && delete n[t];
    }), delete O(this, et, "f").getDescriptions()[t];
  }
  [Pr](t, e, n) {
    O(this, Te, "f")[n] || (O(this, tt, "f").process.emitWarning(t, e), O(this, Te, "f")[n] = !0);
  }
  [Lr]() {
    O(this, ve, "f").push({
      options: O(this, Y, "f"),
      configObjects: O(this, Y, "f").configObjects.slice(0),
      exitProcess: O(this, Nt, "f"),
      groups: O(this, Rt, "f"),
      strict: O(this, Qt, "f"),
      strictCommands: O(this, Jt, "f"),
      strictOptions: O(this, Zt, "f"),
      completionCommand: O(this, It, "f"),
      output: O(this, wt, "f"),
      exitError: O(this, Vt, "f"),
      hasOutput: O(this, Ct, "f"),
      parsed: this.parsed,
      parseFn: O(this, Dt, "f"),
      parseContext: O(this, kt, "f")
    }), O(this, et, "f").freeze(), O(this, dt, "f").freeze(), O(this, mt, "f").freeze(), O(this, At, "f").freeze();
  }
  [Sr]() {
    let t = "", e;
    return /\b(node|iojs|electron)(\.exe)?$/.test(O(this, tt, "f").process.argv()[0]) ? e = O(this, tt, "f").process.argv().slice(1, 2) : e = O(this, tt, "f").process.argv().slice(0, 1), t = e.map((n) => {
      const s = this[zr](O(this, zt, "f"), n);
      return n.match(/^(\/|([a-zA-Z]:)?\\)/) && s.length < n.length ? s : n;
    }).join(" ").trim(), O(this, tt, "f").getEnv("_") && O(this, tt, "f").getProcessArgvBin() === O(this, tt, "f").getEnv("_") && (t = O(this, tt, "f").getEnv("_").replace(`${O(this, tt, "f").path.dirname(O(this, tt, "f").process.execPath())}/`, "")), t;
  }
  [te]() {
    return O(this, Ae, "f");
  }
  [Fr]() {
    return O(this, Pe, "f");
  }
  [ke]() {
    if (!O(this, Yt, "f"))
      return;
    const t = O(this, tt, "f").getEnv("LC_ALL") || O(this, tt, "f").getEnv("LC_MESSAGES") || O(this, tt, "f").getEnv("LANG") || O(this, tt, "f").getEnv("LANGUAGE") || "en_US";
    this.locale(t.replace(/[.:].*/, ""));
  }
  [jr]() {
    return this[Ke]().version || "unknown";
  }
  [Br](t) {
    const e = t["--"] ? t["--"] : t._;
    for (let n = 0, s; (s = e[n]) !== void 0; n++)
      O(this, tt, "f").Parser.looksLikeNumber(s) && Number.isSafeInteger(Math.floor(parseFloat(`${s}`))) && (e[n] = Number(s));
    return t;
  }
  [Ke](t) {
    const e = t || "*";
    if (O(this, oe, "f")[e])
      return O(this, oe, "f")[e];
    let n = {};
    try {
      let s = t || O(this, tt, "f").mainFilename;
      !t && O(this, tt, "f").path.extname(s) && (s = O(this, tt, "f").path.dirname(s));
      const i = O(this, tt, "f").findUp(s, (r, o) => {
        if (o.includes("package.json"))
          return "package.json";
      });
      jt(i, void 0, O(this, tt, "f")), n = JSON.parse(O(this, tt, "f").readFileSync(i, "utf8"));
    } catch {
    }
    return O(this, oe, "f")[e] = n || {}, O(this, oe, "f")[e];
  }
  [Gt](t, e) {
    e = [].concat(e), e.forEach((n) => {
      n = this[Ze](n), O(this, Y, "f")[t].push(n);
    });
  }
  [ae](t, e, n, s) {
    this[Je](t, e, n, s, (i, r, o) => {
      O(this, Y, "f")[i][r] = o;
    });
  }
  [Qe](t, e, n, s) {
    this[Je](t, e, n, s, (i, r, o) => {
      O(this, Y, "f")[i][r] = (O(this, Y, "f")[i][r] || []).concat(o);
    });
  }
  [Je](t, e, n, s, i) {
    if (Array.isArray(n))
      n.forEach((r) => {
        t(r, s);
      });
    else if (/* @__PURE__ */ ((r) => typeof r == "object")(n))
      for (const r of Ue(n))
        t(r, n[r]);
    else
      i(e, this[Ze](n), s);
  }
  [Ze](t) {
    return t === "__proto__" ? "___proto___" : t;
  }
  [tn](t, e) {
    return this[ae](this[tn].bind(this), "key", t, e), this;
  }
  [en]() {
    var t, e, n, s, i, r, o, l, E, m, p, b;
    const w = O(this, ve, "f").pop();
    jt(w, void 0, O(this, tt, "f"));
    let D;
    t = this, e = this, n = this, s = this, i = this, r = this, o = this, l = this, E = this, m = this, p = this, b = this, {
      options: { set value(_) {
        H(t, Y, _, "f");
      } }.value,
      configObjects: D,
      exitProcess: { set value(_) {
        H(e, Nt, _, "f");
      } }.value,
      groups: { set value(_) {
        H(n, Rt, _, "f");
      } }.value,
      output: { set value(_) {
        H(s, wt, _, "f");
      } }.value,
      exitError: { set value(_) {
        H(i, Vt, _, "f");
      } }.value,
      hasOutput: { set value(_) {
        H(r, Ct, _, "f");
      } }.value,
      parsed: this.parsed,
      strict: { set value(_) {
        H(o, Qt, _, "f");
      } }.value,
      strictCommands: { set value(_) {
        H(l, Jt, _, "f");
      } }.value,
      strictOptions: { set value(_) {
        H(E, Zt, _, "f");
      } }.value,
      completionCommand: { set value(_) {
        H(m, It, _, "f");
      } }.value,
      parseFn: { set value(_) {
        H(p, Dt, _, "f");
      } }.value,
      parseContext: { set value(_) {
        H(b, kt, _, "f");
      } }.value
    } = w, O(this, Y, "f").configObjects = D, O(this, et, "f").unfreeze(), O(this, dt, "f").unfreeze(), O(this, mt, "f").unfreeze(), O(this, At, "f").unfreeze();
  }
  [Rr](t, e) {
    return we(e, (n) => (t(n), n));
  }
  getInternalMethods() {
    return {
      getCommandInstance: this[Ur].bind(this),
      getContext: this[Xr].bind(this),
      getHasOutput: this[$r].bind(this),
      getLoggerInstance: this[Wr].bind(this),
      getParseContext: this[qr].bind(this),
      getParserConfiguration: this[te].bind(this),
      getUsageConfiguration: this[Fr].bind(this),
      getUsageInstance: this[Vr].bind(this),
      getValidationInstance: this[Hr].bind(this),
      hasParseCallback: this[Le].bind(this),
      isGlobalContext: this[Gr].bind(this),
      postProcess: this[ee].bind(this),
      reset: this[nn].bind(this),
      runValidation: this[rn].bind(this),
      runYargsParserAndExecuteCommands: this[he].bind(this),
      setHasOutput: this[Yr].bind(this)
    };
  }
  [Ur]() {
    return O(this, mt, "f");
  }
  [Xr]() {
    return O(this, fe, "f");
  }
  [$r]() {
    return O(this, Ct, "f");
  }
  [Wr]() {
    return O(this, se, "f");
  }
  [qr]() {
    return O(this, kt, "f") || {};
  }
  [Vr]() {
    return O(this, et, "f");
  }
  [Hr]() {
    return O(this, dt, "f");
  }
  [Le]() {
    return !!O(this, Dt, "f");
  }
  [Gr]() {
    return O(this, _e, "f");
  }
  [ee](t, e, n, s) {
    return n || yt(t) || (e || (t = this[Ar](t)), (this[te]()["parse-positional-numbers"] || this[te]()["parse-positional-numbers"] === void 0) && (t = this[Br](t)), s && (t = be(t, this, O(this, At, "f").getMiddleware(), !1))), t;
  }
  [nn](t = {}) {
    H(this, Y, O(this, Y, "f") || {}, "f");
    const e = {};
    e.local = O(this, Y, "f").local || [], e.configObjects = O(this, Y, "f").configObjects || [];
    const n = {};
    e.local.forEach((r) => {
      n[r] = !0, (t[r] || []).forEach((o) => {
        n[o] = !0;
      });
    }), Object.assign(O(this, Kt, "f"), Object.keys(O(this, Rt, "f")).reduce((r, o) => {
      const l = O(this, Rt, "f")[o].filter((E) => !(E in n));
      return l.length > 0 && (r[o] = l), r;
    }, {})), H(this, Rt, {}, "f");
    const s = [
      "array",
      "boolean",
      "string",
      "skipValidation",
      "count",
      "normalize",
      "number",
      "hiddenOptions"
    ], i = [
      "narg",
      "key",
      "alias",
      "default",
      "defaultDescription",
      "config",
      "choices",
      "demandedOptions",
      "demandedCommands",
      "deprecatedOptions"
    ];
    return s.forEach((r) => {
      e[r] = (O(this, Y, "f")[r] || []).filter((o) => !n[o]);
    }), i.forEach((r) => {
      e[r] = xe(O(this, Y, "f")[r], (o) => !n[o]);
    }), e.envPrefix = O(this, Y, "f").envPrefix, H(this, Y, e, "f"), H(this, et, O(this, et, "f") ? O(this, et, "f").reset(n) : No(this, O(this, tt, "f")), "f"), H(this, dt, O(this, dt, "f") ? O(this, dt, "f").reset(n) : Ro(this, O(this, et, "f"), O(this, tt, "f")), "f"), H(this, mt, O(this, mt, "f") ? O(this, mt, "f").reset() : Co(O(this, et, "f"), O(this, dt, "f"), O(this, At, "f"), O(this, tt, "f")), "f"), O(this, _t, "f") || H(this, _t, So(this, O(this, et, "f"), O(this, mt, "f"), O(this, tt, "f")), "f"), O(this, At, "f").reset(), H(this, It, null, "f"), H(this, wt, "", "f"), H(this, Vt, null, "f"), H(this, Ct, !1, "f"), this.parsed = !1, this;
  }
  [zr](t, e) {
    return O(this, tt, "f").path.relative(t, e);
  }
  [he](t, e, n, s = 0, i = !1) {
    let r = !!n || i;
    t = t || O(this, Ht, "f"), O(this, Y, "f").__ = O(this, tt, "f").y18n.__, O(this, Y, "f").configuration = this[te]();
    const o = !!O(this, Y, "f").configuration["populate--"], l = Object.assign({}, O(this, Y, "f").configuration, {
      "populate--": !0
    }), E = O(this, tt, "f").Parser.detailed(t, Object.assign({}, O(this, Y, "f"), {
      configuration: { "parse-positional-numbers": !1, ...l }
    })), m = Object.assign(E.argv, O(this, kt, "f"));
    let p;
    const b = E.aliases;
    let w = !1, D = !1;
    Object.keys(m).forEach((_) => {
      _ === O(this, Mt, "f") && m[_] ? w = !0 : _ === O(this, Ut, "f") && m[_] && (D = !0);
    }), m.$0 = this.$0, this.parsed = E, s === 0 && O(this, et, "f").clearCachedHelpMessage();
    try {
      if (this[ke](), e)
        return this[ee](m, o, !!n, !1);
      O(this, Mt, "f") && [O(this, Mt, "f")].concat(b[O(this, Mt, "f")] || []).filter((g) => g.length > 1).includes("" + m._[m._.length - 1]) && (m._.pop(), w = !0), H(this, _e, !1, "f");
      const _ = O(this, mt, "f").getCommands(), I = O(this, _t, "f").completionKey in m, T = w || I || i;
      if (m._.length) {
        if (_.length) {
          let C;
          for (let g = s || 0, v; m._[g] !== void 0; g++)
            if (v = String(m._[g]), _.includes(v) && v !== O(this, It, "f")) {
              const M = O(this, mt, "f").runCommand(v, this, E, g + 1, i, w || D || i);
              return this[ee](M, o, !!n, !1);
            } else if (!C && v !== O(this, It, "f")) {
              C = v;
              break;
            }
          !O(this, mt, "f").hasDefaultCommand() && O(this, Me, "f") && C && !T && O(this, dt, "f").recommendCommands(C, _);
        }
        O(this, It, "f") && m._.includes(O(this, It, "f")) && !I && (O(this, Nt, "f") && me(!0), this.showCompletionScript(), this.exit(0));
      }
      if (O(this, mt, "f").hasDefaultCommand() && !T) {
        const C = O(this, mt, "f").runCommand(null, this, E, 0, i, w || D || i);
        return this[ee](C, o, !!n, !1);
      }
      if (I) {
        O(this, Nt, "f") && me(!0), t = [].concat(t);
        const C = t.slice(t.indexOf(`--${O(this, _t, "f").completionKey}`) + 1);
        return O(this, _t, "f").getCompletion(C, (g, v) => {
          if (g)
            throw new gt(g.message);
          (v || []).forEach((M) => {
            O(this, se, "f").log(M);
          }), this.exit(0);
        }), this[ee](m, !o, !!n, !1);
      }
      if (O(this, Ct, "f") || (w ? (O(this, Nt, "f") && me(!0), r = !0, this.showHelp("log"), this.exit(0)) : D && (O(this, Nt, "f") && me(!0), r = !0, O(this, et, "f").showVersion("log"), this.exit(0))), !r && O(this, Y, "f").skipValidation.length > 0 && (r = Object.keys(m).some((C) => O(this, Y, "f").skipValidation.indexOf(C) >= 0 && m[C] === !0)), !r) {
        if (E.error)
          throw new gt(E.error.message);
        if (!I) {
          const C = this[rn](b, {}, E.error);
          n || (p = be(m, this, O(this, At, "f").getMiddleware(), !0)), p = this[Rr](C, p ?? m), yt(p) && !n && (p = p.then(() => be(m, this, O(this, At, "f").getMiddleware(), !1)));
        }
      }
    } catch (_) {
      if (_ instanceof gt)
        O(this, et, "f").fail(_.message, _);
      else
        throw _;
    }
    return this[ee](p ?? m, o, !!n, !0);
  }
  [rn](t, e, n, s) {
    const i = { ...this.getDemandedOptions() };
    return (r) => {
      if (n)
        throw new gt(n.message);
      O(this, dt, "f").nonOptionCount(r), O(this, dt, "f").requiredArguments(r, i);
      let o = !1;
      O(this, Jt, "f") && (o = O(this, dt, "f").unknownCommands(r)), O(this, Qt, "f") && !o ? O(this, dt, "f").unknownArguments(r, t, e, !!s) : O(this, Zt, "f") && O(this, dt, "f").unknownArguments(r, t, {}, !1, !1), O(this, dt, "f").limitedChoices(r), O(this, dt, "f").implications(r), O(this, dt, "f").conflicting(r);
    };
  }
  [Yr]() {
    H(this, Ct, !0, "f");
  }
  [ne](t) {
    if (typeof t == "string")
      O(this, Y, "f").key[t] = !0;
    else
      for (const e of t)
        O(this, Y, "f").key[e] = !0;
  }
}
function qo(a) {
  return !!a && typeof a.getInternalMethods == "function";
}
const Vo = $o(yo);
var sn = {}, kr;
function Jn() {
  return kr || (kr = 1, function() {
    sn.defaults = {
      "0.1": {
        explicitCharkey: !1,
        trim: !0,
        normalize: !0,
        normalizeTags: !1,
        attrkey: "@",
        charkey: "#",
        explicitArray: !1,
        ignoreAttrs: !1,
        mergeAttrs: !1,
        explicitRoot: !1,
        validator: null,
        xmlns: !1,
        explicitChildren: !1,
        childkey: "@@",
        charsAsChildren: !1,
        includeWhiteChars: !1,
        async: !1,
        strict: !0,
        attrNameProcessors: null,
        attrValueProcessors: null,
        tagNameProcessors: null,
        valueProcessors: null,
        emptyTag: ""
      },
      "0.2": {
        explicitCharkey: !1,
        trim: !1,
        normalize: !1,
        normalizeTags: !1,
        attrkey: "$",
        charkey: "_",
        explicitArray: !0,
        ignoreAttrs: !1,
        mergeAttrs: !1,
        explicitRoot: !0,
        validator: null,
        xmlns: !1,
        explicitChildren: !1,
        preserveChildrenOrder: !1,
        childkey: "$$",
        charsAsChildren: !1,
        includeWhiteChars: !1,
        async: !1,
        strict: !0,
        attrNameProcessors: null,
        attrValueProcessors: null,
        tagNameProcessors: null,
        valueProcessors: null,
        rootName: "root",
        xmldec: {
          version: "1.0",
          encoding: "UTF-8",
          standalone: !0
        },
        doctype: null,
        renderOpts: {
          pretty: !0,
          indent: "  ",
          newline: `
`
        },
        headless: !1,
        chunkSize: 1e4,
        emptyTag: "",
        cdata: !1
      }
    };
  }.call(it)), sn;
}
var on = {}, $t = {}, Wt = {}, Kr;
function qt() {
  return Kr || (Kr = 1, function() {
    var a, t, e, n, s, i, r, o = [].slice, l = {}.hasOwnProperty;
    a = function() {
      var E, m, p, b, w, D;
      if (D = arguments[0], w = 2 <= arguments.length ? o.call(arguments, 1) : [], s(Object.assign))
        Object.assign.apply(null, arguments);
      else
        for (E = 0, p = w.length; E < p; E++)
          if (b = w[E], b != null)
            for (m in b)
              l.call(b, m) && (D[m] = b[m]);
      return D;
    }, s = function(E) {
      return !!E && Object.prototype.toString.call(E) === "[object Function]";
    }, i = function(E) {
      var m;
      return !!E && ((m = typeof E) == "function" || m === "object");
    }, e = function(E) {
      return s(Array.isArray) ? Array.isArray(E) : Object.prototype.toString.call(E) === "[object Array]";
    }, n = function(E) {
      var m;
      if (e(E))
        return !E.length;
      for (m in E)
        if (l.call(E, m))
          return !1;
      return !0;
    }, r = function(E) {
      var m, p;
      return i(E) && (p = Object.getPrototypeOf(E)) && (m = p.constructor) && typeof m == "function" && m instanceof m && Function.prototype.toString.call(m) === Function.prototype.toString.call(Object);
    }, t = function(E) {
      return s(E.valueOf) ? E.valueOf() : E;
    }, Wt.assign = a, Wt.isFunction = s, Wt.isObject = i, Wt.isArray = e, Wt.isEmpty = n, Wt.isPlainObject = r, Wt.getValue = t;
  }.call(it)), Wt;
}
var an = { exports: {} }, Qr;
function os() {
  return Qr || (Qr = 1, function() {
    an.exports = function() {
      function a() {
      }
      return a.prototype.hasFeature = function(t, e) {
        return !0;
      }, a.prototype.createDocumentType = function(t, e, n) {
        throw new Error("This DOM method is not implemented.");
      }, a.prototype.createDocument = function(t, e, n) {
        throw new Error("This DOM method is not implemented.");
      }, a.prototype.createHTMLDocument = function(t) {
        throw new Error("This DOM method is not implemented.");
      }, a.prototype.getFeature = function(t, e) {
        throw new Error("This DOM method is not implemented.");
      }, a;
    }();
  }.call(it)), an.exports;
}
var un = { exports: {} }, cn = { exports: {} }, ln = { exports: {} }, Jr;
function Ho() {
  return Jr || (Jr = 1, function() {
    ln.exports = function() {
      function a() {
      }
      return a.prototype.handleError = function(t) {
        throw new Error(t);
      }, a;
    }();
  }.call(it)), ln.exports;
}
var fn = { exports: {} }, Zr;
function Go() {
  return Zr || (Zr = 1, function() {
    fn.exports = function() {
      function a(t) {
        this.arr = t || [];
      }
      return Object.defineProperty(a.prototype, "length", {
        get: function() {
          return this.arr.length;
        }
      }), a.prototype.item = function(t) {
        return this.arr[t] || null;
      }, a.prototype.contains = function(t) {
        return this.arr.indexOf(t) !== -1;
      }, a;
    }();
  }.call(it)), fn.exports;
}
var ti;
function zo() {
  return ti || (ti = 1, function() {
    var a, t;
    a = Ho(), t = Go(), cn.exports = function() {
      function e() {
        this.defaultParams = {
          "canonical-form": !1,
          "cdata-sections": !1,
          comments: !1,
          "datatype-normalization": !1,
          "element-content-whitespace": !0,
          entities: !0,
          "error-handler": new a(),
          infoset: !0,
          "validate-if-schema": !1,
          namespaces: !0,
          "namespace-declarations": !0,
          "normalize-characters": !1,
          "schema-location": "",
          "schema-type": "",
          "split-cdata-sections": !0,
          validate: !1,
          "well-formed": !0
        }, this.params = Object.create(this.defaultParams);
      }
      return Object.defineProperty(e.prototype, "parameterNames", {
        get: function() {
          return new t(Object.keys(this.defaultParams));
        }
      }), e.prototype.getParameter = function(n) {
        return this.params.hasOwnProperty(n) ? this.params[n] : null;
      }, e.prototype.canSetParameter = function(n, s) {
        return !0;
      }, e.prototype.setParameter = function(n, s) {
        return s != null ? this.params[n] = s : delete this.params[n];
      }, e;
    }();
  }.call(it)), cn.exports;
}
var hn = { exports: {} }, pn = { exports: {} }, dn = { exports: {} }, ei;
function bt() {
  return ei || (ei = 1, function() {
    dn.exports = {
      Element: 1,
      Attribute: 2,
      Text: 3,
      CData: 4,
      EntityReference: 5,
      EntityDeclaration: 6,
      ProcessingInstruction: 7,
      Comment: 8,
      Document: 9,
      DocType: 10,
      DocumentFragment: 11,
      NotationDeclaration: 12,
      Declaration: 201,
      Raw: 202,
      AttributeDeclaration: 203,
      ElementDeclaration: 204,
      Dummy: 205
    };
  }.call(it)), dn.exports;
}
var mn = { exports: {} }, ni;
function as() {
  return ni || (ni = 1, function() {
    var a;
    a = bt(), Lt(), mn.exports = function() {
      function t(e, n, s) {
        if (this.parent = e, this.parent && (this.options = this.parent.options, this.stringify = this.parent.stringify), n == null)
          throw new Error("Missing attribute name. " + this.debugInfo(n));
        this.name = this.stringify.name(n), this.value = this.stringify.attValue(s), this.type = a.Attribute, this.isId = !1, this.schemaTypeInfo = null;
      }
      return Object.defineProperty(t.prototype, "nodeType", {
        get: function() {
          return this.type;
        }
      }), Object.defineProperty(t.prototype, "ownerElement", {
        get: function() {
          return this.parent;
        }
      }), Object.defineProperty(t.prototype, "textContent", {
        get: function() {
          return this.value;
        },
        set: function(e) {
          return this.value = e || "";
        }
      }), Object.defineProperty(t.prototype, "namespaceURI", {
        get: function() {
          return "";
        }
      }), Object.defineProperty(t.prototype, "prefix", {
        get: function() {
          return "";
        }
      }), Object.defineProperty(t.prototype, "localName", {
        get: function() {
          return this.name;
        }
      }), Object.defineProperty(t.prototype, "specified", {
        get: function() {
          return !0;
        }
      }), t.prototype.clone = function() {
        return Object.create(this);
      }, t.prototype.toString = function(e) {
        return this.options.writer.attribute(this, this.options.writer.filterOptions(e));
      }, t.prototype.debugInfo = function(e) {
        return e = e || this.name, e == null ? "parent: <" + this.parent.name + ">" : "attribute: {" + e + "}, parent: <" + this.parent.name + ">";
      }, t.prototype.isEqualNode = function(e) {
        return !(e.namespaceURI !== this.namespaceURI || e.prefix !== this.prefix || e.localName !== this.localName || e.value !== this.value);
      }, t;
    }();
  }.call(it)), mn.exports;
}
var gn = { exports: {} }, ri;
function Zn() {
  return ri || (ri = 1, function() {
    gn.exports = function() {
      function a(t) {
        this.nodes = t;
      }
      return Object.defineProperty(a.prototype, "length", {
        get: function() {
          return Object.keys(this.nodes).length || 0;
        }
      }), a.prototype.clone = function() {
        return this.nodes = null;
      }, a.prototype.getNamedItem = function(t) {
        return this.nodes[t];
      }, a.prototype.setNamedItem = function(t) {
        var e;
        return e = this.nodes[t.nodeName], this.nodes[t.nodeName] = t, e || null;
      }, a.prototype.removeNamedItem = function(t) {
        var e;
        return e = this.nodes[t], delete this.nodes[t], e || null;
      }, a.prototype.item = function(t) {
        return this.nodes[Object.keys(this.nodes)[t]] || null;
      }, a.prototype.getNamedItemNS = function(t, e) {
        throw new Error("This DOM method is not implemented.");
      }, a.prototype.setNamedItemNS = function(t) {
        throw new Error("This DOM method is not implemented.");
      }, a.prototype.removeNamedItemNS = function(t, e) {
        throw new Error("This DOM method is not implemented.");
      }, a;
    }();
  }.call(it)), gn.exports;
}
var ii;
function tr() {
  return ii || (ii = 1, function() {
    var a, t, e, n, s, i, r, o, l = function(m, p) {
      for (var b in p)
        E.call(p, b) && (m[b] = p[b]);
      function w() {
        this.constructor = m;
      }
      return w.prototype = p.prototype, m.prototype = new w(), m.__super__ = p.prototype, m;
    }, E = {}.hasOwnProperty;
    o = qt(), r = o.isObject, i = o.isFunction, s = o.getValue, n = Lt(), a = bt(), t = as(), e = Zn(), pn.exports = function(m) {
      l(p, m);
      function p(b, w, D) {
        var _, I, T, C;
        if (p.__super__.constructor.call(this, b), w == null)
          throw new Error("Missing element name. " + this.debugInfo());
        if (this.name = this.stringify.name(w), this.type = a.Element, this.attribs = {}, this.schemaTypeInfo = null, D != null && this.attribute(D), b.type === a.Document && (this.isRoot = !0, this.documentObject = b, b.rootObject = this, b.children)) {
          for (C = b.children, I = 0, T = C.length; I < T; I++)
            if (_ = C[I], _.type === a.DocType) {
              _.name = this.name;
              break;
            }
        }
      }
      return Object.defineProperty(p.prototype, "tagName", {
        get: function() {
          return this.name;
        }
      }), Object.defineProperty(p.prototype, "namespaceURI", {
        get: function() {
          return "";
        }
      }), Object.defineProperty(p.prototype, "prefix", {
        get: function() {
          return "";
        }
      }), Object.defineProperty(p.prototype, "localName", {
        get: function() {
          return this.name;
        }
      }), Object.defineProperty(p.prototype, "id", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), Object.defineProperty(p.prototype, "className", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), Object.defineProperty(p.prototype, "classList", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), Object.defineProperty(p.prototype, "attributes", {
        get: function() {
          return (!this.attributeMap || !this.attributeMap.nodes) && (this.attributeMap = new e(this.attribs)), this.attributeMap;
        }
      }), p.prototype.clone = function() {
        var b, w, D, _;
        D = Object.create(this), D.isRoot && (D.documentObject = null), D.attribs = {}, _ = this.attribs;
        for (w in _)
          E.call(_, w) && (b = _[w], D.attribs[w] = b.clone());
        return D.children = [], this.children.forEach(function(I) {
          var T;
          return T = I.clone(), T.parent = D, D.children.push(T);
        }), D;
      }, p.prototype.attribute = function(b, w) {
        var D, _;
        if (b != null && (b = s(b)), r(b))
          for (D in b)
            E.call(b, D) && (_ = b[D], this.attribute(D, _));
        else
          i(w) && (w = w.apply()), this.options.keepNullAttributes && w == null ? this.attribs[b] = new t(this, b, "") : w != null && (this.attribs[b] = new t(this, b, w));
        return this;
      }, p.prototype.removeAttribute = function(b) {
        var w, D, _;
        if (b == null)
          throw new Error("Missing attribute name. " + this.debugInfo());
        if (b = s(b), Array.isArray(b))
          for (D = 0, _ = b.length; D < _; D++)
            w = b[D], delete this.attribs[w];
        else
          delete this.attribs[b];
        return this;
      }, p.prototype.toString = function(b) {
        return this.options.writer.element(this, this.options.writer.filterOptions(b));
      }, p.prototype.att = function(b, w) {
        return this.attribute(b, w);
      }, p.prototype.a = function(b, w) {
        return this.attribute(b, w);
      }, p.prototype.getAttribute = function(b) {
        return this.attribs.hasOwnProperty(b) ? this.attribs[b].value : null;
      }, p.prototype.setAttribute = function(b, w) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, p.prototype.getAttributeNode = function(b) {
        return this.attribs.hasOwnProperty(b) ? this.attribs[b] : null;
      }, p.prototype.setAttributeNode = function(b) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, p.prototype.removeAttributeNode = function(b) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, p.prototype.getElementsByTagName = function(b) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, p.prototype.getAttributeNS = function(b, w) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, p.prototype.setAttributeNS = function(b, w, D) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, p.prototype.removeAttributeNS = function(b, w) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, p.prototype.getAttributeNodeNS = function(b, w) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, p.prototype.setAttributeNodeNS = function(b) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, p.prototype.getElementsByTagNameNS = function(b, w) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, p.prototype.hasAttribute = function(b) {
        return this.attribs.hasOwnProperty(b);
      }, p.prototype.hasAttributeNS = function(b, w) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, p.prototype.setIdAttribute = function(b, w) {
        return this.attribs.hasOwnProperty(b) ? this.attribs[b].isId : w;
      }, p.prototype.setIdAttributeNS = function(b, w, D) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, p.prototype.setIdAttributeNode = function(b, w) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, p.prototype.getElementsByTagName = function(b) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, p.prototype.getElementsByTagNameNS = function(b, w) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, p.prototype.getElementsByClassName = function(b) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, p.prototype.isEqualNode = function(b) {
        var w, D, _;
        if (!p.__super__.isEqualNode.apply(this, arguments).isEqualNode(b) || b.namespaceURI !== this.namespaceURI || b.prefix !== this.prefix || b.localName !== this.localName || b.attribs.length !== this.attribs.length)
          return !1;
        for (w = D = 0, _ = this.attribs.length - 1; 0 <= _ ? D <= _ : D >= _; w = 0 <= _ ? ++D : --D)
          if (!this.attribs[w].isEqualNode(b.attribs[w]))
            return !1;
        return !0;
      }, p;
    }(n);
  }.call(it)), pn.exports;
}
var yn = { exports: {} }, bn = { exports: {} }, si;
function We() {
  return si || (si = 1, function() {
    var a, t = function(n, s) {
      for (var i in s)
        e.call(s, i) && (n[i] = s[i]);
      function r() {
        this.constructor = n;
      }
      return r.prototype = s.prototype, n.prototype = new r(), n.__super__ = s.prototype, n;
    }, e = {}.hasOwnProperty;
    a = Lt(), bn.exports = function(n) {
      t(s, n);
      function s(i) {
        s.__super__.constructor.call(this, i), this.value = "";
      }
      return Object.defineProperty(s.prototype, "data", {
        get: function() {
          return this.value;
        },
        set: function(i) {
          return this.value = i || "";
        }
      }), Object.defineProperty(s.prototype, "length", {
        get: function() {
          return this.value.length;
        }
      }), Object.defineProperty(s.prototype, "textContent", {
        get: function() {
          return this.value;
        },
        set: function(i) {
          return this.value = i || "";
        }
      }), s.prototype.clone = function() {
        return Object.create(this);
      }, s.prototype.substringData = function(i, r) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, s.prototype.appendData = function(i) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, s.prototype.insertData = function(i, r) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, s.prototype.deleteData = function(i, r) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, s.prototype.replaceData = function(i, r, o) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, s.prototype.isEqualNode = function(i) {
        return !(!s.__super__.isEqualNode.apply(this, arguments).isEqualNode(i) || i.data !== this.data);
      }, s;
    }(a);
  }.call(it)), bn.exports;
}
var oi;
function er() {
  return oi || (oi = 1, function() {
    var a, t, e = function(s, i) {
      for (var r in i)
        n.call(i, r) && (s[r] = i[r]);
      function o() {
        this.constructor = s;
      }
      return o.prototype = i.prototype, s.prototype = new o(), s.__super__ = i.prototype, s;
    }, n = {}.hasOwnProperty;
    a = bt(), t = We(), yn.exports = function(s) {
      e(i, s);
      function i(r, o) {
        if (i.__super__.constructor.call(this, r), o == null)
          throw new Error("Missing CDATA text. " + this.debugInfo());
        this.name = "#cdata-section", this.type = a.CData, this.value = this.stringify.cdata(o);
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(r) {
        return this.options.writer.cdata(this, this.options.writer.filterOptions(r));
      }, i;
    }(t);
  }.call(it)), yn.exports;
}
var wn = { exports: {} }, ai;
function nr() {
  return ai || (ai = 1, function() {
    var a, t, e = function(s, i) {
      for (var r in i)
        n.call(i, r) && (s[r] = i[r]);
      function o() {
        this.constructor = s;
      }
      return o.prototype = i.prototype, s.prototype = new o(), s.__super__ = i.prototype, s;
    }, n = {}.hasOwnProperty;
    a = bt(), t = We(), wn.exports = function(s) {
      e(i, s);
      function i(r, o) {
        if (i.__super__.constructor.call(this, r), o == null)
          throw new Error("Missing comment text. " + this.debugInfo());
        this.name = "#comment", this.type = a.Comment, this.value = this.stringify.comment(o);
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(r) {
        return this.options.writer.comment(this, this.options.writer.filterOptions(r));
      }, i;
    }(t);
  }.call(it)), wn.exports;
}
var En = { exports: {} }, ui;
function rr() {
  return ui || (ui = 1, function() {
    var a, t, e, n = function(i, r) {
      for (var o in r)
        s.call(r, o) && (i[o] = r[o]);
      function l() {
        this.constructor = i;
      }
      return l.prototype = r.prototype, i.prototype = new l(), i.__super__ = r.prototype, i;
    }, s = {}.hasOwnProperty;
    e = qt().isObject, t = Lt(), a = bt(), En.exports = function(i) {
      n(r, i);
      function r(o, l, E, m) {
        var p;
        r.__super__.constructor.call(this, o), e(l) && (p = l, l = p.version, E = p.encoding, m = p.standalone), l || (l = "1.0"), this.type = a.Declaration, this.version = this.stringify.xmlVersion(l), E != null && (this.encoding = this.stringify.xmlEncoding(E)), m != null && (this.standalone = this.stringify.xmlStandalone(m));
      }
      return r.prototype.toString = function(o) {
        return this.options.writer.declaration(this, this.options.writer.filterOptions(o));
      }, r;
    }(t);
  }.call(it)), En.exports;
}
var xn = { exports: {} }, On = { exports: {} }, ci;
function ir() {
  return ci || (ci = 1, function() {
    var a, t, e = function(s, i) {
      for (var r in i)
        n.call(i, r) && (s[r] = i[r]);
      function o() {
        this.constructor = s;
      }
      return o.prototype = i.prototype, s.prototype = new o(), s.__super__ = i.prototype, s;
    }, n = {}.hasOwnProperty;
    t = Lt(), a = bt(), On.exports = function(s) {
      e(i, s);
      function i(r, o, l, E, m, p) {
        if (i.__super__.constructor.call(this, r), o == null)
          throw new Error("Missing DTD element name. " + this.debugInfo());
        if (l == null)
          throw new Error("Missing DTD attribute name. " + this.debugInfo(o));
        if (!E)
          throw new Error("Missing DTD attribute type. " + this.debugInfo(o));
        if (!m)
          throw new Error("Missing DTD attribute default. " + this.debugInfo(o));
        if (m.indexOf("#") !== 0 && (m = "#" + m), !m.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/))
          throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(o));
        if (p && !m.match(/^(#FIXED|#DEFAULT)$/))
          throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(o));
        this.elementName = this.stringify.name(o), this.type = a.AttributeDeclaration, this.attributeName = this.stringify.name(l), this.attributeType = this.stringify.dtdAttType(E), p && (this.defaultValue = this.stringify.dtdAttDefault(p)), this.defaultValueType = m;
      }
      return i.prototype.toString = function(r) {
        return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(r));
      }, i;
    }(t);
  }.call(it)), On.exports;
}
var In = { exports: {} }, li;
function sr() {
  return li || (li = 1, function() {
    var a, t, e, n = function(i, r) {
      for (var o in r)
        s.call(r, o) && (i[o] = r[o]);
      function l() {
        this.constructor = i;
      }
      return l.prototype = r.prototype, i.prototype = new l(), i.__super__ = r.prototype, i;
    }, s = {}.hasOwnProperty;
    e = qt().isObject, t = Lt(), a = bt(), In.exports = function(i) {
      n(r, i);
      function r(o, l, E, m) {
        if (r.__super__.constructor.call(this, o), E == null)
          throw new Error("Missing DTD entity name. " + this.debugInfo(E));
        if (m == null)
          throw new Error("Missing DTD entity value. " + this.debugInfo(E));
        if (this.pe = !!l, this.name = this.stringify.name(E), this.type = a.EntityDeclaration, !e(m))
          this.value = this.stringify.dtdEntityValue(m), this.internal = !0;
        else {
          if (!m.pubID && !m.sysID)
            throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(E));
          if (m.pubID && !m.sysID)
            throw new Error("System identifier is required for a public external entity. " + this.debugInfo(E));
          if (this.internal = !1, m.pubID != null && (this.pubID = this.stringify.dtdPubID(m.pubID)), m.sysID != null && (this.sysID = this.stringify.dtdSysID(m.sysID)), m.nData != null && (this.nData = this.stringify.dtdNData(m.nData)), this.pe && this.nData)
            throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(E));
        }
      }
      return Object.defineProperty(r.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      }), Object.defineProperty(r.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      }), Object.defineProperty(r.prototype, "notationName", {
        get: function() {
          return this.nData || null;
        }
      }), Object.defineProperty(r.prototype, "inputEncoding", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(r.prototype, "xmlEncoding", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(r.prototype, "xmlVersion", {
        get: function() {
          return null;
        }
      }), r.prototype.toString = function(o) {
        return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(o));
      }, r;
    }(t);
  }.call(it)), In.exports;
}
var Cn = { exports: {} }, fi;
function or() {
  return fi || (fi = 1, function() {
    var a, t, e = function(s, i) {
      for (var r in i)
        n.call(i, r) && (s[r] = i[r]);
      function o() {
        this.constructor = s;
      }
      return o.prototype = i.prototype, s.prototype = new o(), s.__super__ = i.prototype, s;
    }, n = {}.hasOwnProperty;
    t = Lt(), a = bt(), Cn.exports = function(s) {
      e(i, s);
      function i(r, o, l) {
        if (i.__super__.constructor.call(this, r), o == null)
          throw new Error("Missing DTD element name. " + this.debugInfo());
        l || (l = "(#PCDATA)"), Array.isArray(l) && (l = "(" + l.join(",") + ")"), this.name = this.stringify.name(o), this.type = a.ElementDeclaration, this.value = this.stringify.dtdElementValue(l);
      }
      return i.prototype.toString = function(r) {
        return this.options.writer.dtdElement(this, this.options.writer.filterOptions(r));
      }, i;
    }(t);
  }.call(it)), Cn.exports;
}
var Dn = { exports: {} }, hi;
function ar() {
  return hi || (hi = 1, function() {
    var a, t, e = function(s, i) {
      for (var r in i)
        n.call(i, r) && (s[r] = i[r]);
      function o() {
        this.constructor = s;
      }
      return o.prototype = i.prototype, s.prototype = new o(), s.__super__ = i.prototype, s;
    }, n = {}.hasOwnProperty;
    t = Lt(), a = bt(), Dn.exports = function(s) {
      e(i, s);
      function i(r, o, l) {
        if (i.__super__.constructor.call(this, r), o == null)
          throw new Error("Missing DTD notation name. " + this.debugInfo(o));
        if (!l.pubID && !l.sysID)
          throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(o));
        this.name = this.stringify.name(o), this.type = a.NotationDeclaration, l.pubID != null && (this.pubID = this.stringify.dtdPubID(l.pubID)), l.sysID != null && (this.sysID = this.stringify.dtdSysID(l.sysID));
      }
      return Object.defineProperty(i.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      }), Object.defineProperty(i.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      }), i.prototype.toString = function(r) {
        return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(r));
      }, i;
    }(t);
  }.call(it)), Dn.exports;
}
var pi;
function ur() {
  return pi || (pi = 1, function() {
    var a, t, e, n, s, i, r, o, l = function(m, p) {
      for (var b in p)
        E.call(p, b) && (m[b] = p[b]);
      function w() {
        this.constructor = m;
      }
      return w.prototype = p.prototype, m.prototype = new w(), m.__super__ = p.prototype, m;
    }, E = {}.hasOwnProperty;
    o = qt().isObject, r = Lt(), a = bt(), t = ir(), n = sr(), e = or(), s = ar(), i = Zn(), xn.exports = function(m) {
      l(p, m);
      function p(b, w, D) {
        var _, I, T, C, g, v;
        if (p.__super__.constructor.call(this, b), this.type = a.DocType, b.children) {
          for (C = b.children, I = 0, T = C.length; I < T; I++)
            if (_ = C[I], _.type === a.Element) {
              this.name = _.name;
              break;
            }
        }
        this.documentObject = b, o(w) && (g = w, w = g.pubID, D = g.sysID), D == null && (v = [w, D], D = v[0], w = v[1]), w != null && (this.pubID = this.stringify.dtdPubID(w)), D != null && (this.sysID = this.stringify.dtdSysID(D));
      }
      return Object.defineProperty(p.prototype, "entities", {
        get: function() {
          var b, w, D, _, I;
          for (_ = {}, I = this.children, w = 0, D = I.length; w < D; w++)
            b = I[w], b.type === a.EntityDeclaration && !b.pe && (_[b.name] = b);
          return new i(_);
        }
      }), Object.defineProperty(p.prototype, "notations", {
        get: function() {
          var b, w, D, _, I;
          for (_ = {}, I = this.children, w = 0, D = I.length; w < D; w++)
            b = I[w], b.type === a.NotationDeclaration && (_[b.name] = b);
          return new i(_);
        }
      }), Object.defineProperty(p.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      }), Object.defineProperty(p.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      }), Object.defineProperty(p.prototype, "internalSubset", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), p.prototype.element = function(b, w) {
        var D;
        return D = new e(this, b, w), this.children.push(D), this;
      }, p.prototype.attList = function(b, w, D, _, I) {
        var T;
        return T = new t(this, b, w, D, _, I), this.children.push(T), this;
      }, p.prototype.entity = function(b, w) {
        var D;
        return D = new n(this, !1, b, w), this.children.push(D), this;
      }, p.prototype.pEntity = function(b, w) {
        var D;
        return D = new n(this, !0, b, w), this.children.push(D), this;
      }, p.prototype.notation = function(b, w) {
        var D;
        return D = new s(this, b, w), this.children.push(D), this;
      }, p.prototype.toString = function(b) {
        return this.options.writer.docType(this, this.options.writer.filterOptions(b));
      }, p.prototype.ele = function(b, w) {
        return this.element(b, w);
      }, p.prototype.att = function(b, w, D, _, I) {
        return this.attList(b, w, D, _, I);
      }, p.prototype.ent = function(b, w) {
        return this.entity(b, w);
      }, p.prototype.pent = function(b, w) {
        return this.pEntity(b, w);
      }, p.prototype.not = function(b, w) {
        return this.notation(b, w);
      }, p.prototype.up = function() {
        return this.root() || this.documentObject;
      }, p.prototype.isEqualNode = function(b) {
        return !(!p.__super__.isEqualNode.apply(this, arguments).isEqualNode(b) || b.name !== this.name || b.publicId !== this.publicId || b.systemId !== this.systemId);
      }, p;
    }(r);
  }.call(it)), xn.exports;
}
var Tn = { exports: {} }, di;
function cr() {
  return di || (di = 1, function() {
    var a, t, e = function(s, i) {
      for (var r in i)
        n.call(i, r) && (s[r] = i[r]);
      function o() {
        this.constructor = s;
      }
      return o.prototype = i.prototype, s.prototype = new o(), s.__super__ = i.prototype, s;
    }, n = {}.hasOwnProperty;
    a = bt(), t = Lt(), Tn.exports = function(s) {
      e(i, s);
      function i(r, o) {
        if (i.__super__.constructor.call(this, r), o == null)
          throw new Error("Missing raw text. " + this.debugInfo());
        this.type = a.Raw, this.value = this.stringify.raw(o);
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(r) {
        return this.options.writer.raw(this, this.options.writer.filterOptions(r));
      }, i;
    }(t);
  }.call(it)), Tn.exports;
}
var vn = { exports: {} }, mi;
function lr() {
  return mi || (mi = 1, function() {
    var a, t, e = function(s, i) {
      for (var r in i)
        n.call(i, r) && (s[r] = i[r]);
      function o() {
        this.constructor = s;
      }
      return o.prototype = i.prototype, s.prototype = new o(), s.__super__ = i.prototype, s;
    }, n = {}.hasOwnProperty;
    a = bt(), t = We(), vn.exports = function(s) {
      e(i, s);
      function i(r, o) {
        if (i.__super__.constructor.call(this, r), o == null)
          throw new Error("Missing element text. " + this.debugInfo());
        this.name = "#text", this.type = a.Text, this.value = this.stringify.text(o);
      }
      return Object.defineProperty(i.prototype, "isElementContentWhitespace", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), Object.defineProperty(i.prototype, "wholeText", {
        get: function() {
          var r, o, l;
          for (l = "", o = this.previousSibling; o; )
            l = o.data + l, o = o.previousSibling;
          for (l += this.data, r = this.nextSibling; r; )
            l = l + r.data, r = r.nextSibling;
          return l;
        }
      }), i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(r) {
        return this.options.writer.text(this, this.options.writer.filterOptions(r));
      }, i.prototype.splitText = function(r) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, i.prototype.replaceWholeText = function(r) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, i;
    }(t);
  }.call(it)), vn.exports;
}
var _n = { exports: {} }, gi;
function fr() {
  return gi || (gi = 1, function() {
    var a, t, e = function(s, i) {
      for (var r in i)
        n.call(i, r) && (s[r] = i[r]);
      function o() {
        this.constructor = s;
      }
      return o.prototype = i.prototype, s.prototype = new o(), s.__super__ = i.prototype, s;
    }, n = {}.hasOwnProperty;
    a = bt(), t = We(), _n.exports = function(s) {
      e(i, s);
      function i(r, o, l) {
        if (i.__super__.constructor.call(this, r), o == null)
          throw new Error("Missing instruction target. " + this.debugInfo());
        this.type = a.ProcessingInstruction, this.target = this.stringify.insTarget(o), this.name = this.target, l && (this.value = this.stringify.insValue(l));
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(r) {
        return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(r));
      }, i.prototype.isEqualNode = function(r) {
        return !(!i.__super__.isEqualNode.apply(this, arguments).isEqualNode(r) || r.target !== this.target);
      }, i;
    }(t);
  }.call(it)), _n.exports;
}
var Nn = { exports: {} }, yi;
function us() {
  return yi || (yi = 1, function() {
    var a, t, e = function(s, i) {
      for (var r in i)
        n.call(i, r) && (s[r] = i[r]);
      function o() {
        this.constructor = s;
      }
      return o.prototype = i.prototype, s.prototype = new o(), s.__super__ = i.prototype, s;
    }, n = {}.hasOwnProperty;
    t = Lt(), a = bt(), Nn.exports = function(s) {
      e(i, s);
      function i(r) {
        i.__super__.constructor.call(this, r), this.type = a.Dummy;
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(r) {
        return "";
      }, i;
    }(t);
  }.call(it)), Nn.exports;
}
var An = { exports: {} }, bi;
function Yo() {
  return bi || (bi = 1, function() {
    An.exports = function() {
      function a(t) {
        this.nodes = t;
      }
      return Object.defineProperty(a.prototype, "length", {
        get: function() {
          return this.nodes.length || 0;
        }
      }), a.prototype.clone = function() {
        return this.nodes = null;
      }, a.prototype.item = function(t) {
        return this.nodes[t] || null;
      }, a;
    }();
  }.call(it)), An.exports;
}
var Mn = { exports: {} }, wi;
function ko() {
  return wi || (wi = 1, function() {
    Mn.exports = {
      Disconnected: 1,
      Preceding: 2,
      Following: 4,
      Contains: 8,
      ContainedBy: 16,
      ImplementationSpecific: 32
    };
  }.call(it)), Mn.exports;
}
var Ei;
function Lt() {
  return Ei || (Ei = 1, function() {
    var a, t, e, n, s, i, r, o, l, E, m, p, b, w, D, _, I, T = {}.hasOwnProperty;
    I = qt(), _ = I.isObject, D = I.isFunction, w = I.isEmpty, b = I.getValue, o = null, e = null, n = null, s = null, i = null, m = null, p = null, E = null, r = null, t = null, l = null, a = null, hn.exports = function() {
      function C(g) {
        this.parent = g, this.parent && (this.options = this.parent.options, this.stringify = this.parent.stringify), this.value = null, this.children = [], this.baseURI = null, o || (o = tr(), e = er(), n = nr(), s = rr(), i = ur(), m = cr(), p = lr(), E = fr(), r = us(), t = bt(), l = Yo(), Zn(), a = ko());
      }
      return Object.defineProperty(C.prototype, "nodeName", {
        get: function() {
          return this.name;
        }
      }), Object.defineProperty(C.prototype, "nodeType", {
        get: function() {
          return this.type;
        }
      }), Object.defineProperty(C.prototype, "nodeValue", {
        get: function() {
          return this.value;
        }
      }), Object.defineProperty(C.prototype, "parentNode", {
        get: function() {
          return this.parent;
        }
      }), Object.defineProperty(C.prototype, "childNodes", {
        get: function() {
          return (!this.childNodeList || !this.childNodeList.nodes) && (this.childNodeList = new l(this.children)), this.childNodeList;
        }
      }), Object.defineProperty(C.prototype, "firstChild", {
        get: function() {
          return this.children[0] || null;
        }
      }), Object.defineProperty(C.prototype, "lastChild", {
        get: function() {
          return this.children[this.children.length - 1] || null;
        }
      }), Object.defineProperty(C.prototype, "previousSibling", {
        get: function() {
          var g;
          return g = this.parent.children.indexOf(this), this.parent.children[g - 1] || null;
        }
      }), Object.defineProperty(C.prototype, "nextSibling", {
        get: function() {
          var g;
          return g = this.parent.children.indexOf(this), this.parent.children[g + 1] || null;
        }
      }), Object.defineProperty(C.prototype, "ownerDocument", {
        get: function() {
          return this.document() || null;
        }
      }), Object.defineProperty(C.prototype, "textContent", {
        get: function() {
          var g, v, M, X, W;
          if (this.nodeType === t.Element || this.nodeType === t.DocumentFragment) {
            for (W = "", X = this.children, v = 0, M = X.length; v < M; v++)
              g = X[v], g.textContent && (W += g.textContent);
            return W;
          } else
            return null;
        },
        set: function(g) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), C.prototype.setParent = function(g) {
        var v, M, X, W, U;
        for (this.parent = g, g && (this.options = g.options, this.stringify = g.stringify), W = this.children, U = [], M = 0, X = W.length; M < X; M++)
          v = W[M], U.push(v.setParent(this));
        return U;
      }, C.prototype.element = function(g, v, M) {
        var X, W, U, d, B, S, R, $, q, z, k;
        if (S = null, v === null && M == null && (q = [{}, null], v = q[0], M = q[1]), v == null && (v = {}), v = b(v), _(v) || (z = [v, M], M = z[0], v = z[1]), g != null && (g = b(g)), Array.isArray(g))
          for (U = 0, R = g.length; U < R; U++)
            W = g[U], S = this.element(W);
        else if (D(g))
          S = this.element(g.apply());
        else if (_(g)) {
          for (B in g)
            if (T.call(g, B))
              if (k = g[B], D(k) && (k = k.apply()), !this.options.ignoreDecorators && this.stringify.convertAttKey && B.indexOf(this.stringify.convertAttKey) === 0)
                S = this.attribute(B.substr(this.stringify.convertAttKey.length), k);
              else if (!this.options.separateArrayItems && Array.isArray(k) && w(k))
                S = this.dummy();
              else if (_(k) && w(k))
                S = this.element(B);
              else if (!this.options.keepNullNodes && k == null)
                S = this.dummy();
              else if (!this.options.separateArrayItems && Array.isArray(k))
                for (d = 0, $ = k.length; d < $; d++)
                  W = k[d], X = {}, X[B] = W, S = this.element(X);
              else _(k) ? !this.options.ignoreDecorators && this.stringify.convertTextKey && B.indexOf(this.stringify.convertTextKey) === 0 ? S = this.element(k) : (S = this.element(B), S.element(k)) : S = this.element(B, k);
        } else !this.options.keepNullNodes && M === null ? S = this.dummy() : !this.options.ignoreDecorators && this.stringify.convertTextKey && g.indexOf(this.stringify.convertTextKey) === 0 ? S = this.text(M) : !this.options.ignoreDecorators && this.stringify.convertCDataKey && g.indexOf(this.stringify.convertCDataKey) === 0 ? S = this.cdata(M) : !this.options.ignoreDecorators && this.stringify.convertCommentKey && g.indexOf(this.stringify.convertCommentKey) === 0 ? S = this.comment(M) : !this.options.ignoreDecorators && this.stringify.convertRawKey && g.indexOf(this.stringify.convertRawKey) === 0 ? S = this.raw(M) : !this.options.ignoreDecorators && this.stringify.convertPIKey && g.indexOf(this.stringify.convertPIKey) === 0 ? S = this.instruction(g.substr(this.stringify.convertPIKey.length), M) : S = this.node(g, v, M);
        if (S == null)
          throw new Error("Could not create any elements with: " + g + ". " + this.debugInfo());
        return S;
      }, C.prototype.insertBefore = function(g, v, M) {
        var X, W, U, d, B;
        if (g?.type)
          return U = g, d = v, U.setParent(this), d ? (W = children.indexOf(d), B = children.splice(W), children.push(U), Array.prototype.push.apply(children, B)) : children.push(U), U;
        if (this.isRoot)
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(g));
        return W = this.parent.children.indexOf(this), B = this.parent.children.splice(W), X = this.parent.element(g, v, M), Array.prototype.push.apply(this.parent.children, B), X;
      }, C.prototype.insertAfter = function(g, v, M) {
        var X, W, U;
        if (this.isRoot)
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(g));
        return W = this.parent.children.indexOf(this), U = this.parent.children.splice(W + 1), X = this.parent.element(g, v, M), Array.prototype.push.apply(this.parent.children, U), X;
      }, C.prototype.remove = function() {
        var g;
        if (this.isRoot)
          throw new Error("Cannot remove the root element. " + this.debugInfo());
        return g = this.parent.children.indexOf(this), [].splice.apply(this.parent.children, [g, g - g + 1].concat([])), this.parent;
      }, C.prototype.node = function(g, v, M) {
        var X, W;
        return g != null && (g = b(g)), v || (v = {}), v = b(v), _(v) || (W = [v, M], M = W[0], v = W[1]), X = new o(this, g, v), M != null && X.text(M), this.children.push(X), X;
      }, C.prototype.text = function(g) {
        var v;
        return _(g) && this.element(g), v = new p(this, g), this.children.push(v), this;
      }, C.prototype.cdata = function(g) {
        var v;
        return v = new e(this, g), this.children.push(v), this;
      }, C.prototype.comment = function(g) {
        var v;
        return v = new n(this, g), this.children.push(v), this;
      }, C.prototype.commentBefore = function(g) {
        var v, M;
        return v = this.parent.children.indexOf(this), M = this.parent.children.splice(v), this.parent.comment(g), Array.prototype.push.apply(this.parent.children, M), this;
      }, C.prototype.commentAfter = function(g) {
        var v, M;
        return v = this.parent.children.indexOf(this), M = this.parent.children.splice(v + 1), this.parent.comment(g), Array.prototype.push.apply(this.parent.children, M), this;
      }, C.prototype.raw = function(g) {
        var v;
        return v = new m(this, g), this.children.push(v), this;
      }, C.prototype.dummy = function() {
        var g;
        return g = new r(this), g;
      }, C.prototype.instruction = function(g, v) {
        var M, X, W, U, d;
        if (g != null && (g = b(g)), v != null && (v = b(v)), Array.isArray(g))
          for (U = 0, d = g.length; U < d; U++)
            M = g[U], this.instruction(M);
        else if (_(g))
          for (M in g)
            T.call(g, M) && (X = g[M], this.instruction(M, X));
        else
          D(v) && (v = v.apply()), W = new E(this, g, v), this.children.push(W);
        return this;
      }, C.prototype.instructionBefore = function(g, v) {
        var M, X;
        return M = this.parent.children.indexOf(this), X = this.parent.children.splice(M), this.parent.instruction(g, v), Array.prototype.push.apply(this.parent.children, X), this;
      }, C.prototype.instructionAfter = function(g, v) {
        var M, X;
        return M = this.parent.children.indexOf(this), X = this.parent.children.splice(M + 1), this.parent.instruction(g, v), Array.prototype.push.apply(this.parent.children, X), this;
      }, C.prototype.declaration = function(g, v, M) {
        var X, W;
        return X = this.document(), W = new s(X, g, v, M), X.children.length === 0 ? X.children.unshift(W) : X.children[0].type === t.Declaration ? X.children[0] = W : X.children.unshift(W), X.root() || X;
      }, C.prototype.dtd = function(g, v) {
        var M, X, W, U, d, B, S, R, $, q;
        for (X = this.document(), W = new i(X, g, v), $ = X.children, U = d = 0, S = $.length; d < S; U = ++d)
          if (M = $[U], M.type === t.DocType)
            return X.children[U] = W, W;
        for (q = X.children, U = B = 0, R = q.length; B < R; U = ++B)
          if (M = q[U], M.isRoot)
            return X.children.splice(U, 0, W), W;
        return X.children.push(W), W;
      }, C.prototype.up = function() {
        if (this.isRoot)
          throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
        return this.parent;
      }, C.prototype.root = function() {
        var g;
        for (g = this; g; ) {
          if (g.type === t.Document)
            return g.rootObject;
          if (g.isRoot)
            return g;
          g = g.parent;
        }
      }, C.prototype.document = function() {
        var g;
        for (g = this; g; ) {
          if (g.type === t.Document)
            return g;
          g = g.parent;
        }
      }, C.prototype.end = function(g) {
        return this.document().end(g);
      }, C.prototype.prev = function() {
        var g;
        if (g = this.parent.children.indexOf(this), g < 1)
          throw new Error("Already at the first node. " + this.debugInfo());
        return this.parent.children[g - 1];
      }, C.prototype.next = function() {
        var g;
        if (g = this.parent.children.indexOf(this), g === -1 || g === this.parent.children.length - 1)
          throw new Error("Already at the last node. " + this.debugInfo());
        return this.parent.children[g + 1];
      }, C.prototype.importDocument = function(g) {
        var v;
        return v = g.root().clone(), v.parent = this, v.isRoot = !1, this.children.push(v), this;
      }, C.prototype.debugInfo = function(g) {
        var v, M;
        return g = g || this.name, g == null && !((v = this.parent) != null && v.name) ? "" : g == null ? "parent: <" + this.parent.name + ">" : (M = this.parent) != null && M.name ? "node: <" + g + ">, parent: <" + this.parent.name + ">" : "node: <" + g + ">";
      }, C.prototype.ele = function(g, v, M) {
        return this.element(g, v, M);
      }, C.prototype.nod = function(g, v, M) {
        return this.node(g, v, M);
      }, C.prototype.txt = function(g) {
        return this.text(g);
      }, C.prototype.dat = function(g) {
        return this.cdata(g);
      }, C.prototype.com = function(g) {
        return this.comment(g);
      }, C.prototype.ins = function(g, v) {
        return this.instruction(g, v);
      }, C.prototype.doc = function() {
        return this.document();
      }, C.prototype.dec = function(g, v, M) {
        return this.declaration(g, v, M);
      }, C.prototype.e = function(g, v, M) {
        return this.element(g, v, M);
      }, C.prototype.n = function(g, v, M) {
        return this.node(g, v, M);
      }, C.prototype.t = function(g) {
        return this.text(g);
      }, C.prototype.d = function(g) {
        return this.cdata(g);
      }, C.prototype.c = function(g) {
        return this.comment(g);
      }, C.prototype.r = function(g) {
        return this.raw(g);
      }, C.prototype.i = function(g, v) {
        return this.instruction(g, v);
      }, C.prototype.u = function() {
        return this.up();
      }, C.prototype.importXMLBuilder = function(g) {
        return this.importDocument(g);
      }, C.prototype.replaceChild = function(g, v) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, C.prototype.removeChild = function(g) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, C.prototype.appendChild = function(g) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, C.prototype.hasChildNodes = function() {
        return this.children.length !== 0;
      }, C.prototype.cloneNode = function(g) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, C.prototype.normalize = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, C.prototype.isSupported = function(g, v) {
        return !0;
      }, C.prototype.hasAttributes = function() {
        return this.attribs.length !== 0;
      }, C.prototype.compareDocumentPosition = function(g) {
        var v, M;
        return v = this, v === g ? 0 : this.document() !== g.document() ? (M = a.Disconnected | a.ImplementationSpecific, Math.random() < 0.5 ? M |= a.Preceding : M |= a.Following, M) : v.isAncestor(g) ? a.Contains | a.Preceding : v.isDescendant(g) ? a.Contains | a.Following : v.isPreceding(g) ? a.Preceding : a.Following;
      }, C.prototype.isSameNode = function(g) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, C.prototype.lookupPrefix = function(g) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, C.prototype.isDefaultNamespace = function(g) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, C.prototype.lookupNamespaceURI = function(g) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, C.prototype.isEqualNode = function(g) {
        var v, M, X;
        if (g.nodeType !== this.nodeType || g.children.length !== this.children.length)
          return !1;
        for (v = M = 0, X = this.children.length - 1; 0 <= X ? M <= X : M >= X; v = 0 <= X ? ++M : --M)
          if (!this.children[v].isEqualNode(g.children[v]))
            return !1;
        return !0;
      }, C.prototype.getFeature = function(g, v) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, C.prototype.setUserData = function(g, v, M) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, C.prototype.getUserData = function(g) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, C.prototype.contains = function(g) {
        return g ? g === this || this.isDescendant(g) : !1;
      }, C.prototype.isDescendant = function(g) {
        var v, M, X, W, U;
        for (U = this.children, X = 0, W = U.length; X < W; X++)
          if (v = U[X], g === v || (M = v.isDescendant(g), M))
            return !0;
        return !1;
      }, C.prototype.isAncestor = function(g) {
        return g.isDescendant(this);
      }, C.prototype.isPreceding = function(g) {
        var v, M;
        return v = this.treePosition(g), M = this.treePosition(this), v === -1 || M === -1 ? !1 : v < M;
      }, C.prototype.isFollowing = function(g) {
        var v, M;
        return v = this.treePosition(g), M = this.treePosition(this), v === -1 || M === -1 ? !1 : v > M;
      }, C.prototype.treePosition = function(g) {
        var v, M;
        return M = 0, v = !1, this.foreachTreeNode(this.document(), function(X) {
          if (M++, !v && X === g)
            return v = !0;
        }), v ? M : -1;
      }, C.prototype.foreachTreeNode = function(g, v) {
        var M, X, W, U, d;
        for (g || (g = this.document()), U = g.children, X = 0, W = U.length; X < W; X++) {
          if (M = U[X], d = v(M))
            return d;
          if (d = this.foreachTreeNode(M, v), d)
            return d;
        }
      }, C;
    }();
  }.call(it)), hn.exports;
}
var Pn = { exports: {} }, xi;
function cs() {
  return xi || (xi = 1, function() {
    var a = function(e, n) {
      return function() {
        return e.apply(n, arguments);
      };
    }, t = {}.hasOwnProperty;
    Pn.exports = function() {
      function e(n) {
        this.assertLegalName = a(this.assertLegalName, this), this.assertLegalChar = a(this.assertLegalChar, this);
        var s, i, r;
        n || (n = {}), this.options = n, this.options.version || (this.options.version = "1.0"), i = n.stringify || {};
        for (s in i)
          t.call(i, s) && (r = i[s], this[s] = r);
      }
      return e.prototype.name = function(n) {
        return this.options.noValidation ? n : this.assertLegalName("" + n || "");
      }, e.prototype.text = function(n) {
        return this.options.noValidation ? n : this.assertLegalChar(this.textEscape("" + n || ""));
      }, e.prototype.cdata = function(n) {
        return this.options.noValidation ? n : (n = "" + n || "", n = n.replace("]]>", "]]]]><![CDATA[>"), this.assertLegalChar(n));
      }, e.prototype.comment = function(n) {
        if (this.options.noValidation)
          return n;
        if (n = "" + n || "", n.match(/--/))
          throw new Error("Comment text cannot contain double-hypen: " + n);
        return this.assertLegalChar(n);
      }, e.prototype.raw = function(n) {
        return this.options.noValidation ? n : "" + n || "";
      }, e.prototype.attValue = function(n) {
        return this.options.noValidation ? n : this.assertLegalChar(this.attEscape(n = "" + n || ""));
      }, e.prototype.insTarget = function(n) {
        return this.options.noValidation ? n : this.assertLegalChar("" + n || "");
      }, e.prototype.insValue = function(n) {
        if (this.options.noValidation)
          return n;
        if (n = "" + n || "", n.match(/\?>/))
          throw new Error("Invalid processing instruction value: " + n);
        return this.assertLegalChar(n);
      }, e.prototype.xmlVersion = function(n) {
        if (this.options.noValidation)
          return n;
        if (n = "" + n || "", !n.match(/1\.[0-9]+/))
          throw new Error("Invalid version number: " + n);
        return n;
      }, e.prototype.xmlEncoding = function(n) {
        if (this.options.noValidation)
          return n;
        if (n = "" + n || "", !n.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/))
          throw new Error("Invalid encoding: " + n);
        return this.assertLegalChar(n);
      }, e.prototype.xmlStandalone = function(n) {
        return this.options.noValidation ? n : n ? "yes" : "no";
      }, e.prototype.dtdPubID = function(n) {
        return this.options.noValidation ? n : this.assertLegalChar("" + n || "");
      }, e.prototype.dtdSysID = function(n) {
        return this.options.noValidation ? n : this.assertLegalChar("" + n || "");
      }, e.prototype.dtdElementValue = function(n) {
        return this.options.noValidation ? n : this.assertLegalChar("" + n || "");
      }, e.prototype.dtdAttType = function(n) {
        return this.options.noValidation ? n : this.assertLegalChar("" + n || "");
      }, e.prototype.dtdAttDefault = function(n) {
        return this.options.noValidation ? n : this.assertLegalChar("" + n || "");
      }, e.prototype.dtdEntityValue = function(n) {
        return this.options.noValidation ? n : this.assertLegalChar("" + n || "");
      }, e.prototype.dtdNData = function(n) {
        return this.options.noValidation ? n : this.assertLegalChar("" + n || "");
      }, e.prototype.convertAttKey = "@", e.prototype.convertPIKey = "?", e.prototype.convertTextKey = "#text", e.prototype.convertCDataKey = "#cdata", e.prototype.convertCommentKey = "#comment", e.prototype.convertRawKey = "#raw", e.prototype.assertLegalChar = function(n) {
        var s, i;
        if (this.options.noValidation)
          return n;
        if (s = "", this.options.version === "1.0") {
          if (s = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, i = n.match(s))
            throw new Error("Invalid character in string: " + n + " at index " + i.index);
        } else if (this.options.version === "1.1" && (s = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, i = n.match(s)))
          throw new Error("Invalid character in string: " + n + " at index " + i.index);
        return n;
      }, e.prototype.assertLegalName = function(n) {
        var s;
        if (this.options.noValidation)
          return n;
        if (this.assertLegalChar(n), s = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/, !n.match(s))
          throw new Error("Invalid character in name");
        return n;
      }, e.prototype.textEscape = function(n) {
        var s;
        return this.options.noValidation ? n : (s = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, n.replace(s, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;"));
      }, e.prototype.attEscape = function(n) {
        var s;
        return this.options.noValidation ? n : (s = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, n.replace(s, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;"));
      }, e;
    }();
  }.call(it)), Pn.exports;
}
var Ln = { exports: {} }, Sn = { exports: {} }, Fn = { exports: {} }, Oi;
function qe() {
  return Oi || (Oi = 1, function() {
    Fn.exports = {
      None: 0,
      OpenTag: 1,
      InsideTag: 2,
      CloseTag: 3
    };
  }.call(it)), Fn.exports;
}
var Ii;
function ls() {
  return Ii || (Ii = 1, function() {
    var a, t, e, n = {}.hasOwnProperty;
    e = qt().assign, a = bt(), rr(), ur(), er(), nr(), tr(), cr(), lr(), fr(), us(), ir(), or(), sr(), ar(), t = qe(), Sn.exports = function() {
      function s(i) {
        var r, o, l;
        i || (i = {}), this.options = i, o = i.writer || {};
        for (r in o)
          n.call(o, r) && (l = o[r], this["_" + r] = this[r], this[r] = l);
      }
      return s.prototype.filterOptions = function(i) {
        var r, o, l, E, m, p, b, w;
        return i || (i = {}), i = e({}, this.options, i), r = {
          writer: this
        }, r.pretty = i.pretty || !1, r.allowEmpty = i.allowEmpty || !1, r.indent = (o = i.indent) != null ? o : "  ", r.newline = (l = i.newline) != null ? l : `
`, r.offset = (E = i.offset) != null ? E : 0, r.dontPrettyTextNodes = (m = (p = i.dontPrettyTextNodes) != null ? p : i.dontprettytextnodes) != null ? m : 0, r.spaceBeforeSlash = (b = (w = i.spaceBeforeSlash) != null ? w : i.spacebeforeslash) != null ? b : "", r.spaceBeforeSlash === !0 && (r.spaceBeforeSlash = " "), r.suppressPrettyCount = 0, r.user = {}, r.state = t.None, r;
      }, s.prototype.indent = function(i, r, o) {
        var l;
        return !r.pretty || r.suppressPrettyCount ? "" : r.pretty && (l = (o || 0) + r.offset + 1, l > 0) ? new Array(l).join(r.indent) : "";
      }, s.prototype.endline = function(i, r, o) {
        return !r.pretty || r.suppressPrettyCount ? "" : r.newline;
      }, s.prototype.attribute = function(i, r, o) {
        var l;
        return this.openAttribute(i, r, o), l = " " + i.name + '="' + i.value + '"', this.closeAttribute(i, r, o), l;
      }, s.prototype.cdata = function(i, r, o) {
        var l;
        return this.openNode(i, r, o), r.state = t.OpenTag, l = this.indent(i, r, o) + "<![CDATA[", r.state = t.InsideTag, l += i.value, r.state = t.CloseTag, l += "]]>" + this.endline(i, r, o), r.state = t.None, this.closeNode(i, r, o), l;
      }, s.prototype.comment = function(i, r, o) {
        var l;
        return this.openNode(i, r, o), r.state = t.OpenTag, l = this.indent(i, r, o) + "<!-- ", r.state = t.InsideTag, l += i.value, r.state = t.CloseTag, l += " -->" + this.endline(i, r, o), r.state = t.None, this.closeNode(i, r, o), l;
      }, s.prototype.declaration = function(i, r, o) {
        var l;
        return this.openNode(i, r, o), r.state = t.OpenTag, l = this.indent(i, r, o) + "<?xml", r.state = t.InsideTag, l += ' version="' + i.version + '"', i.encoding != null && (l += ' encoding="' + i.encoding + '"'), i.standalone != null && (l += ' standalone="' + i.standalone + '"'), r.state = t.CloseTag, l += r.spaceBeforeSlash + "?>", l += this.endline(i, r, o), r.state = t.None, this.closeNode(i, r, o), l;
      }, s.prototype.docType = function(i, r, o) {
        var l, E, m, p, b;
        if (o || (o = 0), this.openNode(i, r, o), r.state = t.OpenTag, p = this.indent(i, r, o), p += "<!DOCTYPE " + i.root().name, i.pubID && i.sysID ? p += ' PUBLIC "' + i.pubID + '" "' + i.sysID + '"' : i.sysID && (p += ' SYSTEM "' + i.sysID + '"'), i.children.length > 0) {
          for (p += " [", p += this.endline(i, r, o), r.state = t.InsideTag, b = i.children, E = 0, m = b.length; E < m; E++)
            l = b[E], p += this.writeChildNode(l, r, o + 1);
          r.state = t.CloseTag, p += "]";
        }
        return r.state = t.CloseTag, p += r.spaceBeforeSlash + ">", p += this.endline(i, r, o), r.state = t.None, this.closeNode(i, r, o), p;
      }, s.prototype.element = function(i, r, o) {
        var l, E, m, p, b, w, D, _, I, T, C, g, v, M;
        o || (o = 0), T = !1, C = "", this.openNode(i, r, o), r.state = t.OpenTag, C += this.indent(i, r, o) + "<" + i.name, g = i.attribs;
        for (I in g)
          n.call(g, I) && (l = g[I], C += this.attribute(l, r, o));
        if (m = i.children.length, p = m === 0 ? null : i.children[0], m === 0 || i.children.every(function(X) {
          return (X.type === a.Text || X.type === a.Raw) && X.value === "";
        }))
          r.allowEmpty ? (C += ">", r.state = t.CloseTag, C += "</" + i.name + ">" + this.endline(i, r, o)) : (r.state = t.CloseTag, C += r.spaceBeforeSlash + "/>" + this.endline(i, r, o));
        else if (r.pretty && m === 1 && (p.type === a.Text || p.type === a.Raw) && p.value != null)
          C += ">", r.state = t.InsideTag, r.suppressPrettyCount++, T = !0, C += this.writeChildNode(p, r, o + 1), r.suppressPrettyCount--, T = !1, r.state = t.CloseTag, C += "</" + i.name + ">" + this.endline(i, r, o);
        else {
          if (r.dontPrettyTextNodes) {
            for (v = i.children, b = 0, D = v.length; b < D; b++)
              if (E = v[b], (E.type === a.Text || E.type === a.Raw) && E.value != null) {
                r.suppressPrettyCount++, T = !0;
                break;
              }
          }
          for (C += ">" + this.endline(i, r, o), r.state = t.InsideTag, M = i.children, w = 0, _ = M.length; w < _; w++)
            E = M[w], C += this.writeChildNode(E, r, o + 1);
          r.state = t.CloseTag, C += this.indent(i, r, o) + "</" + i.name + ">", T && r.suppressPrettyCount--, C += this.endline(i, r, o), r.state = t.None;
        }
        return this.closeNode(i, r, o), C;
      }, s.prototype.writeChildNode = function(i, r, o) {
        switch (i.type) {
          case a.CData:
            return this.cdata(i, r, o);
          case a.Comment:
            return this.comment(i, r, o);
          case a.Element:
            return this.element(i, r, o);
          case a.Raw:
            return this.raw(i, r, o);
          case a.Text:
            return this.text(i, r, o);
          case a.ProcessingInstruction:
            return this.processingInstruction(i, r, o);
          case a.Dummy:
            return "";
          case a.Declaration:
            return this.declaration(i, r, o);
          case a.DocType:
            return this.docType(i, r, o);
          case a.AttributeDeclaration:
            return this.dtdAttList(i, r, o);
          case a.ElementDeclaration:
            return this.dtdElement(i, r, o);
          case a.EntityDeclaration:
            return this.dtdEntity(i, r, o);
          case a.NotationDeclaration:
            return this.dtdNotation(i, r, o);
          default:
            throw new Error("Unknown XML node type: " + i.constructor.name);
        }
      }, s.prototype.processingInstruction = function(i, r, o) {
        var l;
        return this.openNode(i, r, o), r.state = t.OpenTag, l = this.indent(i, r, o) + "<?", r.state = t.InsideTag, l += i.target, i.value && (l += " " + i.value), r.state = t.CloseTag, l += r.spaceBeforeSlash + "?>", l += this.endline(i, r, o), r.state = t.None, this.closeNode(i, r, o), l;
      }, s.prototype.raw = function(i, r, o) {
        var l;
        return this.openNode(i, r, o), r.state = t.OpenTag, l = this.indent(i, r, o), r.state = t.InsideTag, l += i.value, r.state = t.CloseTag, l += this.endline(i, r, o), r.state = t.None, this.closeNode(i, r, o), l;
      }, s.prototype.text = function(i, r, o) {
        var l;
        return this.openNode(i, r, o), r.state = t.OpenTag, l = this.indent(i, r, o), r.state = t.InsideTag, l += i.value, r.state = t.CloseTag, l += this.endline(i, r, o), r.state = t.None, this.closeNode(i, r, o), l;
      }, s.prototype.dtdAttList = function(i, r, o) {
        var l;
        return this.openNode(i, r, o), r.state = t.OpenTag, l = this.indent(i, r, o) + "<!ATTLIST", r.state = t.InsideTag, l += " " + i.elementName + " " + i.attributeName + " " + i.attributeType, i.defaultValueType !== "#DEFAULT" && (l += " " + i.defaultValueType), i.defaultValue && (l += ' "' + i.defaultValue + '"'), r.state = t.CloseTag, l += r.spaceBeforeSlash + ">" + this.endline(i, r, o), r.state = t.None, this.closeNode(i, r, o), l;
      }, s.prototype.dtdElement = function(i, r, o) {
        var l;
        return this.openNode(i, r, o), r.state = t.OpenTag, l = this.indent(i, r, o) + "<!ELEMENT", r.state = t.InsideTag, l += " " + i.name + " " + i.value, r.state = t.CloseTag, l += r.spaceBeforeSlash + ">" + this.endline(i, r, o), r.state = t.None, this.closeNode(i, r, o), l;
      }, s.prototype.dtdEntity = function(i, r, o) {
        var l;
        return this.openNode(i, r, o), r.state = t.OpenTag, l = this.indent(i, r, o) + "<!ENTITY", r.state = t.InsideTag, i.pe && (l += " %"), l += " " + i.name, i.value ? l += ' "' + i.value + '"' : (i.pubID && i.sysID ? l += ' PUBLIC "' + i.pubID + '" "' + i.sysID + '"' : i.sysID && (l += ' SYSTEM "' + i.sysID + '"'), i.nData && (l += " NDATA " + i.nData)), r.state = t.CloseTag, l += r.spaceBeforeSlash + ">" + this.endline(i, r, o), r.state = t.None, this.closeNode(i, r, o), l;
      }, s.prototype.dtdNotation = function(i, r, o) {
        var l;
        return this.openNode(i, r, o), r.state = t.OpenTag, l = this.indent(i, r, o) + "<!NOTATION", r.state = t.InsideTag, l += " " + i.name, i.pubID && i.sysID ? l += ' PUBLIC "' + i.pubID + '" "' + i.sysID + '"' : i.pubID ? l += ' PUBLIC "' + i.pubID + '"' : i.sysID && (l += ' SYSTEM "' + i.sysID + '"'), r.state = t.CloseTag, l += r.spaceBeforeSlash + ">" + this.endline(i, r, o), r.state = t.None, this.closeNode(i, r, o), l;
      }, s.prototype.openNode = function(i, r, o) {
      }, s.prototype.closeNode = function(i, r, o) {
      }, s.prototype.openAttribute = function(i, r, o) {
      }, s.prototype.closeAttribute = function(i, r, o) {
      }, s;
    }();
  }.call(it)), Sn.exports;
}
var Ci;
function hr() {
  return Ci || (Ci = 1, function() {
    var a, t = function(n, s) {
      for (var i in s)
        e.call(s, i) && (n[i] = s[i]);
      function r() {
        this.constructor = n;
      }
      return r.prototype = s.prototype, n.prototype = new r(), n.__super__ = s.prototype, n;
    }, e = {}.hasOwnProperty;
    a = ls(), Ln.exports = function(n) {
      t(s, n);
      function s(i) {
        s.__super__.constructor.call(this, i);
      }
      return s.prototype.document = function(i, r) {
        var o, l, E, m, p;
        for (r = this.filterOptions(r), m = "", p = i.children, l = 0, E = p.length; l < E; l++)
          o = p[l], m += this.writeChildNode(o, r, 0);
        return r.pretty && m.slice(-r.newline.length) === r.newline && (m = m.slice(0, -r.newline.length)), m;
      }, s;
    }(a);
  }.call(it)), Ln.exports;
}
var Di;
function fs() {
  return Di || (Di = 1, function() {
    var a, t, e, n, s, i, r, o = function(E, m) {
      for (var p in m)
        l.call(m, p) && (E[p] = m[p]);
      function b() {
        this.constructor = E;
      }
      return b.prototype = m.prototype, E.prototype = new b(), E.__super__ = m.prototype, E;
    }, l = {}.hasOwnProperty;
    r = qt().isPlainObject, e = os(), t = zo(), n = Lt(), a = bt(), i = cs(), s = hr(), un.exports = function(E) {
      o(m, E);
      function m(p) {
        m.__super__.constructor.call(this, null), this.name = "#document", this.type = a.Document, this.documentURI = null, this.domConfig = new t(), p || (p = {}), p.writer || (p.writer = new s()), this.options = p, this.stringify = new i(p);
      }
      return Object.defineProperty(m.prototype, "implementation", {
        value: new e()
      }), Object.defineProperty(m.prototype, "doctype", {
        get: function() {
          var p, b, w, D;
          for (D = this.children, b = 0, w = D.length; b < w; b++)
            if (p = D[b], p.type === a.DocType)
              return p;
          return null;
        }
      }), Object.defineProperty(m.prototype, "documentElement", {
        get: function() {
          return this.rootObject || null;
        }
      }), Object.defineProperty(m.prototype, "inputEncoding", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(m.prototype, "strictErrorChecking", {
        get: function() {
          return !1;
        }
      }), Object.defineProperty(m.prototype, "xmlEncoding", {
        get: function() {
          return this.children.length !== 0 && this.children[0].type === a.Declaration ? this.children[0].encoding : null;
        }
      }), Object.defineProperty(m.prototype, "xmlStandalone", {
        get: function() {
          return this.children.length !== 0 && this.children[0].type === a.Declaration ? this.children[0].standalone === "yes" : !1;
        }
      }), Object.defineProperty(m.prototype, "xmlVersion", {
        get: function() {
          return this.children.length !== 0 && this.children[0].type === a.Declaration ? this.children[0].version : "1.0";
        }
      }), Object.defineProperty(m.prototype, "URL", {
        get: function() {
          return this.documentURI;
        }
      }), Object.defineProperty(m.prototype, "origin", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(m.prototype, "compatMode", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(m.prototype, "characterSet", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(m.prototype, "contentType", {
        get: function() {
          return null;
        }
      }), m.prototype.end = function(p) {
        var b;
        return b = {}, p ? r(p) && (b = p, p = this.options.writer) : p = this.options.writer, p.document(this, p.filterOptions(b));
      }, m.prototype.toString = function(p) {
        return this.options.writer.document(this, this.options.writer.filterOptions(p));
      }, m.prototype.createElement = function(p) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, m.prototype.createDocumentFragment = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, m.prototype.createTextNode = function(p) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, m.prototype.createComment = function(p) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, m.prototype.createCDATASection = function(p) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, m.prototype.createProcessingInstruction = function(p, b) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, m.prototype.createAttribute = function(p) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, m.prototype.createEntityReference = function(p) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, m.prototype.getElementsByTagName = function(p) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, m.prototype.importNode = function(p, b) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, m.prototype.createElementNS = function(p, b) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, m.prototype.createAttributeNS = function(p, b) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, m.prototype.getElementsByTagNameNS = function(p, b) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, m.prototype.getElementById = function(p) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, m.prototype.adoptNode = function(p) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, m.prototype.normalizeDocument = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, m.prototype.renameNode = function(p, b, w) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, m.prototype.getElementsByClassName = function(p) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, m.prototype.createEvent = function(p) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, m.prototype.createRange = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, m.prototype.createNodeIterator = function(p, b, w) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, m.prototype.createTreeWalker = function(p, b, w) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, m;
    }(n);
  }.call(it)), un.exports;
}
var jn = { exports: {} }, Ti;
function Ko() {
  return Ti || (Ti = 1, function() {
    var a, t, e, n, s, i, r, o, l, E, m, p, b, w, D, _, I, T, C, g, v, M, X, W = {}.hasOwnProperty;
    X = qt(), v = X.isObject, g = X.isFunction, M = X.isPlainObject, C = X.getValue, a = bt(), p = fs(), b = tr(), n = er(), s = nr(), D = cr(), T = lr(), w = fr(), E = rr(), m = ur(), i = ir(), o = sr(), r = or(), l = ar(), e = as(), I = cs(), _ = hr(), t = qe(), jn.exports = function() {
      function U(d, B, S) {
        var R;
        this.name = "?xml", this.type = a.Document, d || (d = {}), R = {}, d.writer ? M(d.writer) && (R = d.writer, d.writer = new _()) : d.writer = new _(), this.options = d, this.writer = d.writer, this.writerOptions = this.writer.filterOptions(R), this.stringify = new I(d), this.onDataCallback = B || function() {
        }, this.onEndCallback = S || function() {
        }, this.currentNode = null, this.currentLevel = -1, this.openTags = {}, this.documentStarted = !1, this.documentCompleted = !1, this.root = null;
      }
      return U.prototype.createChildNode = function(d) {
        var B, S, R, $, q, z, k, V;
        switch (d.type) {
          case a.CData:
            this.cdata(d.value);
            break;
          case a.Comment:
            this.comment(d.value);
            break;
          case a.Element:
            R = {}, k = d.attribs;
            for (S in k)
              W.call(k, S) && (B = k[S], R[S] = B.value);
            this.node(d.name, R);
            break;
          case a.Dummy:
            this.dummy();
            break;
          case a.Raw:
            this.raw(d.value);
            break;
          case a.Text:
            this.text(d.value);
            break;
          case a.ProcessingInstruction:
            this.instruction(d.target, d.value);
            break;
          default:
            throw new Error("This XML node type is not supported in a JS object: " + d.constructor.name);
        }
        for (V = d.children, q = 0, z = V.length; q < z; q++)
          $ = V[q], this.createChildNode($), $.type === a.Element && this.up();
        return this;
      }, U.prototype.dummy = function() {
        return this;
      }, U.prototype.node = function(d, B, S) {
        var R;
        if (d == null)
          throw new Error("Missing node name.");
        if (this.root && this.currentLevel === -1)
          throw new Error("Document can only have one root node. " + this.debugInfo(d));
        return this.openCurrent(), d = C(d), B == null && (B = {}), B = C(B), v(B) || (R = [B, S], S = R[0], B = R[1]), this.currentNode = new b(this, d, B), this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, S != null && this.text(S), this;
      }, U.prototype.element = function(d, B, S) {
        var R, $, q, z, k, V;
        if (this.currentNode && this.currentNode.type === a.DocType)
          this.dtdElement.apply(this, arguments);
        else if (Array.isArray(d) || v(d) || g(d))
          for (z = this.options.noValidation, this.options.noValidation = !0, V = new p(this.options).element("TEMP_ROOT"), V.element(d), this.options.noValidation = z, k = V.children, $ = 0, q = k.length; $ < q; $++)
            R = k[$], this.createChildNode(R), R.type === a.Element && this.up();
        else
          this.node(d, B, S);
        return this;
      }, U.prototype.attribute = function(d, B) {
        var S, R;
        if (!this.currentNode || this.currentNode.children)
          throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(d));
        if (d != null && (d = C(d)), v(d))
          for (S in d)
            W.call(d, S) && (R = d[S], this.attribute(S, R));
        else
          g(B) && (B = B.apply()), this.options.keepNullAttributes && B == null ? this.currentNode.attribs[d] = new e(this, d, "") : B != null && (this.currentNode.attribs[d] = new e(this, d, B));
        return this;
      }, U.prototype.text = function(d) {
        var B;
        return this.openCurrent(), B = new T(this, d), this.onData(this.writer.text(B, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, U.prototype.cdata = function(d) {
        var B;
        return this.openCurrent(), B = new n(this, d), this.onData(this.writer.cdata(B, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, U.prototype.comment = function(d) {
        var B;
        return this.openCurrent(), B = new s(this, d), this.onData(this.writer.comment(B, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, U.prototype.raw = function(d) {
        var B;
        return this.openCurrent(), B = new D(this, d), this.onData(this.writer.raw(B, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, U.prototype.instruction = function(d, B) {
        var S, R, $, q, z;
        if (this.openCurrent(), d != null && (d = C(d)), B != null && (B = C(B)), Array.isArray(d))
          for (S = 0, q = d.length; S < q; S++)
            R = d[S], this.instruction(R);
        else if (v(d))
          for (R in d)
            W.call(d, R) && ($ = d[R], this.instruction(R, $));
        else
          g(B) && (B = B.apply()), z = new w(this, d, B), this.onData(this.writer.processingInstruction(z, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      }, U.prototype.declaration = function(d, B, S) {
        var R;
        if (this.openCurrent(), this.documentStarted)
          throw new Error("declaration() must be the first node.");
        return R = new E(this, d, B, S), this.onData(this.writer.declaration(R, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, U.prototype.doctype = function(d, B, S) {
        if (this.openCurrent(), d == null)
          throw new Error("Missing root node name.");
        if (this.root)
          throw new Error("dtd() must come before the root node.");
        return this.currentNode = new m(this, B, S), this.currentNode.rootNodeName = d, this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, this;
      }, U.prototype.dtdElement = function(d, B) {
        var S;
        return this.openCurrent(), S = new r(this, d, B), this.onData(this.writer.dtdElement(S, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, U.prototype.attList = function(d, B, S, R, $) {
        var q;
        return this.openCurrent(), q = new i(this, d, B, S, R, $), this.onData(this.writer.dtdAttList(q, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, U.prototype.entity = function(d, B) {
        var S;
        return this.openCurrent(), S = new o(this, !1, d, B), this.onData(this.writer.dtdEntity(S, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, U.prototype.pEntity = function(d, B) {
        var S;
        return this.openCurrent(), S = new o(this, !0, d, B), this.onData(this.writer.dtdEntity(S, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, U.prototype.notation = function(d, B) {
        var S;
        return this.openCurrent(), S = new l(this, d, B), this.onData(this.writer.dtdNotation(S, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, U.prototype.up = function() {
        if (this.currentLevel < 0)
          throw new Error("The document node has no parent.");
        return this.currentNode ? (this.currentNode.children ? this.closeNode(this.currentNode) : this.openNode(this.currentNode), this.currentNode = null) : this.closeNode(this.openTags[this.currentLevel]), delete this.openTags[this.currentLevel], this.currentLevel--, this;
      }, U.prototype.end = function() {
        for (; this.currentLevel >= 0; )
          this.up();
        return this.onEnd();
      }, U.prototype.openCurrent = function() {
        if (this.currentNode)
          return this.currentNode.children = !0, this.openNode(this.currentNode);
      }, U.prototype.openNode = function(d) {
        var B, S, R, $;
        if (!d.isOpen) {
          if (!this.root && this.currentLevel === 0 && d.type === a.Element && (this.root = d), S = "", d.type === a.Element) {
            this.writerOptions.state = t.OpenTag, S = this.writer.indent(d, this.writerOptions, this.currentLevel) + "<" + d.name, $ = d.attribs;
            for (R in $)
              W.call($, R) && (B = $[R], S += this.writer.attribute(B, this.writerOptions, this.currentLevel));
            S += (d.children ? ">" : "/>") + this.writer.endline(d, this.writerOptions, this.currentLevel), this.writerOptions.state = t.InsideTag;
          } else
            this.writerOptions.state = t.OpenTag, S = this.writer.indent(d, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + d.rootNodeName, d.pubID && d.sysID ? S += ' PUBLIC "' + d.pubID + '" "' + d.sysID + '"' : d.sysID && (S += ' SYSTEM "' + d.sysID + '"'), d.children ? (S += " [", this.writerOptions.state = t.InsideTag) : (this.writerOptions.state = t.CloseTag, S += ">"), S += this.writer.endline(d, this.writerOptions, this.currentLevel);
          return this.onData(S, this.currentLevel), d.isOpen = !0;
        }
      }, U.prototype.closeNode = function(d) {
        var B;
        if (!d.isClosed)
          return B = "", this.writerOptions.state = t.CloseTag, d.type === a.Element ? B = this.writer.indent(d, this.writerOptions, this.currentLevel) + "</" + d.name + ">" + this.writer.endline(d, this.writerOptions, this.currentLevel) : B = this.writer.indent(d, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(d, this.writerOptions, this.currentLevel), this.writerOptions.state = t.None, this.onData(B, this.currentLevel), d.isClosed = !0;
      }, U.prototype.onData = function(d, B) {
        return this.documentStarted = !0, this.onDataCallback(d, B + 1);
      }, U.prototype.onEnd = function() {
        return this.documentCompleted = !0, this.onEndCallback();
      }, U.prototype.debugInfo = function(d) {
        return d == null ? "" : "node: <" + d + ">";
      }, U.prototype.ele = function() {
        return this.element.apply(this, arguments);
      }, U.prototype.nod = function(d, B, S) {
        return this.node(d, B, S);
      }, U.prototype.txt = function(d) {
        return this.text(d);
      }, U.prototype.dat = function(d) {
        return this.cdata(d);
      }, U.prototype.com = function(d) {
        return this.comment(d);
      }, U.prototype.ins = function(d, B) {
        return this.instruction(d, B);
      }, U.prototype.dec = function(d, B, S) {
        return this.declaration(d, B, S);
      }, U.prototype.dtd = function(d, B, S) {
        return this.doctype(d, B, S);
      }, U.prototype.e = function(d, B, S) {
        return this.element(d, B, S);
      }, U.prototype.n = function(d, B, S) {
        return this.node(d, B, S);
      }, U.prototype.t = function(d) {
        return this.text(d);
      }, U.prototype.d = function(d) {
        return this.cdata(d);
      }, U.prototype.c = function(d) {
        return this.comment(d);
      }, U.prototype.r = function(d) {
        return this.raw(d);
      }, U.prototype.i = function(d, B) {
        return this.instruction(d, B);
      }, U.prototype.att = function() {
        return this.currentNode && this.currentNode.type === a.DocType ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
      }, U.prototype.a = function() {
        return this.currentNode && this.currentNode.type === a.DocType ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
      }, U.prototype.ent = function(d, B) {
        return this.entity(d, B);
      }, U.prototype.pent = function(d, B) {
        return this.pEntity(d, B);
      }, U.prototype.not = function(d, B) {
        return this.notation(d, B);
      }, U;
    }();
  }.call(it)), jn.exports;
}
var Bn = { exports: {} }, vi;
function Qo() {
  return vi || (vi = 1, function() {
    var a, t, e, n = function(i, r) {
      for (var o in r)
        s.call(r, o) && (i[o] = r[o]);
      function l() {
        this.constructor = i;
      }
      return l.prototype = r.prototype, i.prototype = new l(), i.__super__ = r.prototype, i;
    }, s = {}.hasOwnProperty;
    a = bt(), e = ls(), t = qe(), Bn.exports = function(i) {
      n(r, i);
      function r(o, l) {
        this.stream = o, r.__super__.constructor.call(this, l);
      }
      return r.prototype.endline = function(o, l, E) {
        return o.isLastRootNode && l.state === t.CloseTag ? "" : r.__super__.endline.call(this, o, l, E);
      }, r.prototype.document = function(o, l) {
        var E, m, p, b, w, D, _, I, T;
        for (_ = o.children, m = p = 0, w = _.length; p < w; m = ++p)
          E = _[m], E.isLastRootNode = m === o.children.length - 1;
        for (l = this.filterOptions(l), I = o.children, T = [], b = 0, D = I.length; b < D; b++)
          E = I[b], T.push(this.writeChildNode(E, l, 0));
        return T;
      }, r.prototype.attribute = function(o, l, E) {
        return this.stream.write(r.__super__.attribute.call(this, o, l, E));
      }, r.prototype.cdata = function(o, l, E) {
        return this.stream.write(r.__super__.cdata.call(this, o, l, E));
      }, r.prototype.comment = function(o, l, E) {
        return this.stream.write(r.__super__.comment.call(this, o, l, E));
      }, r.prototype.declaration = function(o, l, E) {
        return this.stream.write(r.__super__.declaration.call(this, o, l, E));
      }, r.prototype.docType = function(o, l, E) {
        var m, p, b, w;
        if (E || (E = 0), this.openNode(o, l, E), l.state = t.OpenTag, this.stream.write(this.indent(o, l, E)), this.stream.write("<!DOCTYPE " + o.root().name), o.pubID && o.sysID ? this.stream.write(' PUBLIC "' + o.pubID + '" "' + o.sysID + '"') : o.sysID && this.stream.write(' SYSTEM "' + o.sysID + '"'), o.children.length > 0) {
          for (this.stream.write(" ["), this.stream.write(this.endline(o, l, E)), l.state = t.InsideTag, w = o.children, p = 0, b = w.length; p < b; p++)
            m = w[p], this.writeChildNode(m, l, E + 1);
          l.state = t.CloseTag, this.stream.write("]");
        }
        return l.state = t.CloseTag, this.stream.write(l.spaceBeforeSlash + ">"), this.stream.write(this.endline(o, l, E)), l.state = t.None, this.closeNode(o, l, E);
      }, r.prototype.element = function(o, l, E) {
        var m, p, b, w, D, _, I, T, C;
        E || (E = 0), this.openNode(o, l, E), l.state = t.OpenTag, this.stream.write(this.indent(o, l, E) + "<" + o.name), T = o.attribs;
        for (I in T)
          s.call(T, I) && (m = T[I], this.attribute(m, l, E));
        if (b = o.children.length, w = b === 0 ? null : o.children[0], b === 0 || o.children.every(function(g) {
          return (g.type === a.Text || g.type === a.Raw) && g.value === "";
        }))
          l.allowEmpty ? (this.stream.write(">"), l.state = t.CloseTag, this.stream.write("</" + o.name + ">")) : (l.state = t.CloseTag, this.stream.write(l.spaceBeforeSlash + "/>"));
        else if (l.pretty && b === 1 && (w.type === a.Text || w.type === a.Raw) && w.value != null)
          this.stream.write(">"), l.state = t.InsideTag, l.suppressPrettyCount++, this.writeChildNode(w, l, E + 1), l.suppressPrettyCount--, l.state = t.CloseTag, this.stream.write("</" + o.name + ">");
        else {
          for (this.stream.write(">" + this.endline(o, l, E)), l.state = t.InsideTag, C = o.children, D = 0, _ = C.length; D < _; D++)
            p = C[D], this.writeChildNode(p, l, E + 1);
          l.state = t.CloseTag, this.stream.write(this.indent(o, l, E) + "</" + o.name + ">");
        }
        return this.stream.write(this.endline(o, l, E)), l.state = t.None, this.closeNode(o, l, E);
      }, r.prototype.processingInstruction = function(o, l, E) {
        return this.stream.write(r.__super__.processingInstruction.call(this, o, l, E));
      }, r.prototype.raw = function(o, l, E) {
        return this.stream.write(r.__super__.raw.call(this, o, l, E));
      }, r.prototype.text = function(o, l, E) {
        return this.stream.write(r.__super__.text.call(this, o, l, E));
      }, r.prototype.dtdAttList = function(o, l, E) {
        return this.stream.write(r.__super__.dtdAttList.call(this, o, l, E));
      }, r.prototype.dtdElement = function(o, l, E) {
        return this.stream.write(r.__super__.dtdElement.call(this, o, l, E));
      }, r.prototype.dtdEntity = function(o, l, E) {
        return this.stream.write(r.__super__.dtdEntity.call(this, o, l, E));
      }, r.prototype.dtdNotation = function(o, l, E) {
        return this.stream.write(r.__super__.dtdNotation.call(this, o, l, E));
      }, r;
    }(e);
  }.call(it)), Bn.exports;
}
var _i;
function Jo() {
  return _i || (_i = 1, function() {
    var a, t, e, n, s, i, r, o, l, E;
    E = qt(), o = E.assign, l = E.isFunction, e = os(), n = fs(), s = Ko(), r = hr(), i = Qo(), a = bt(), t = qe(), $t.create = function(m, p, b, w) {
      var D, _;
      if (m == null)
        throw new Error("Root element needs a name.");
      return w = o({}, p, b, w), D = new n(w), _ = D.element(m), w.headless || (D.declaration(w), (w.pubID != null || w.sysID != null) && D.dtd(w)), _;
    }, $t.begin = function(m, p, b) {
      var w;
      return l(m) && (w = [m, p], p = w[0], b = w[1], m = {}), p ? new s(m, p, b) : new n(m);
    }, $t.stringWriter = function(m) {
      return new r(m);
    }, $t.streamWriter = function(m, p) {
      return new i(m, p);
    }, $t.implementation = new e(), $t.nodeType = a, $t.writerState = t;
  }.call(it)), $t;
}
var Ni;
function Zo() {
  return Ni || (Ni = 1, function() {
    var a, t, e, n, s, i = {}.hasOwnProperty;
    a = Jo(), t = Jn().defaults, n = function(r) {
      return typeof r == "string" && (r.indexOf("&") >= 0 || r.indexOf(">") >= 0 || r.indexOf("<") >= 0);
    }, s = function(r) {
      return "<![CDATA[" + e(r) + "]]>";
    }, e = function(r) {
      return r.replace("]]>", "]]]]><![CDATA[>");
    }, on.Builder = function() {
      function r(o) {
        var l, E, m;
        this.options = {}, E = t["0.2"];
        for (l in E)
          i.call(E, l) && (m = E[l], this.options[l] = m);
        for (l in o)
          i.call(o, l) && (m = o[l], this.options[l] = m);
      }
      return r.prototype.buildObject = function(o) {
        var l, E, m, p, b;
        return l = this.options.attrkey, E = this.options.charkey, Object.keys(o).length === 1 && this.options.rootName === t["0.2"].rootName ? (b = Object.keys(o)[0], o = o[b]) : b = this.options.rootName, m = /* @__PURE__ */ function(w) {
          return function(D, _) {
            var I, T, C, g, v, M;
            if (typeof _ != "object")
              w.options.cdata && n(_) ? D.raw(s(_)) : D.txt(_);
            else if (Array.isArray(_)) {
              for (g in _)
                if (i.call(_, g)) {
                  T = _[g];
                  for (v in T)
                    C = T[v], D = m(D.ele(v), C).up();
                }
            } else
              for (v in _)
                if (i.call(_, v))
                  if (T = _[v], v === l) {
                    if (typeof T == "object")
                      for (I in T)
                        M = T[I], D = D.att(I, M);
                  } else if (v === E)
                    w.options.cdata && n(T) ? D = D.raw(s(T)) : D = D.txt(T);
                  else if (Array.isArray(T))
                    for (g in T)
                      i.call(T, g) && (C = T[g], typeof C == "string" ? w.options.cdata && n(C) ? D = D.ele(v).raw(s(C)).up() : D = D.ele(v, C).up() : D = m(D.ele(v), C).up());
                  else typeof T == "object" ? D = m(D.ele(v), T).up() : typeof T == "string" && w.options.cdata && n(T) ? D = D.ele(v).raw(s(T)).up() : (T == null && (T = ""), D = D.ele(v, T.toString()).up());
            return D;
          };
        }(this), p = a.create(b, this.options.xmldec, this.options.doctype, {
          headless: this.options.headless,
          allowSurrogateChars: this.options.allowSurrogateChars
        }), m(p, o).end(this.options.renderOpts);
      }, r;
    }();
  }.call(it)), on;
}
var Rn = {}, Un = {}, Xn = {}, Se = { exports: {} }, $n = {}, pe = {}, Ai;
function ta() {
  if (Ai) return pe;
  Ai = 1, pe.byteLength = o, pe.toByteArray = E, pe.fromByteArray = b;
  for (var a = [], t = [], e = typeof Uint8Array < "u" ? Uint8Array : Array, n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0, i = n.length; s < i; ++s)
    a[s] = n[s], t[n.charCodeAt(s)] = s;
  t[45] = 62, t[95] = 63;
  function r(w) {
    var D = w.length;
    if (D % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var _ = w.indexOf("=");
    _ === -1 && (_ = D);
    var I = _ === D ? 0 : 4 - _ % 4;
    return [_, I];
  }
  function o(w) {
    var D = r(w), _ = D[0], I = D[1];
    return (_ + I) * 3 / 4 - I;
  }
  function l(w, D, _) {
    return (D + _) * 3 / 4 - _;
  }
  function E(w) {
    var D, _ = r(w), I = _[0], T = _[1], C = new e(l(w, I, T)), g = 0, v = T > 0 ? I - 4 : I, M;
    for (M = 0; M < v; M += 4)
      D = t[w.charCodeAt(M)] << 18 | t[w.charCodeAt(M + 1)] << 12 | t[w.charCodeAt(M + 2)] << 6 | t[w.charCodeAt(M + 3)], C[g++] = D >> 16 & 255, C[g++] = D >> 8 & 255, C[g++] = D & 255;
    return T === 2 && (D = t[w.charCodeAt(M)] << 2 | t[w.charCodeAt(M + 1)] >> 4, C[g++] = D & 255), T === 1 && (D = t[w.charCodeAt(M)] << 10 | t[w.charCodeAt(M + 1)] << 4 | t[w.charCodeAt(M + 2)] >> 2, C[g++] = D >> 8 & 255, C[g++] = D & 255), C;
  }
  function m(w) {
    return a[w >> 18 & 63] + a[w >> 12 & 63] + a[w >> 6 & 63] + a[w & 63];
  }
  function p(w, D, _) {
    for (var I, T = [], C = D; C < _; C += 3)
      I = (w[C] << 16 & 16711680) + (w[C + 1] << 8 & 65280) + (w[C + 2] & 255), T.push(m(I));
    return T.join("");
  }
  function b(w) {
    for (var D, _ = w.length, I = _ % 3, T = [], C = 16383, g = 0, v = _ - I; g < v; g += C)
      T.push(p(w, g, g + C > v ? v : g + C));
    return I === 1 ? (D = w[_ - 1], T.push(
      a[D >> 2] + a[D << 4 & 63] + "=="
    )) : I === 2 && (D = (w[_ - 2] << 8) + w[_ - 1], T.push(
      a[D >> 10] + a[D >> 4 & 63] + a[D << 2 & 63] + "="
    )), T.join("");
  }
  return pe;
}
var Fe = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var Mi;
function ea() {
  return Mi || (Mi = 1, Fe.read = function(a, t, e, n, s) {
    var i, r, o = s * 8 - n - 1, l = (1 << o) - 1, E = l >> 1, m = -7, p = e ? s - 1 : 0, b = e ? -1 : 1, w = a[t + p];
    for (p += b, i = w & (1 << -m) - 1, w >>= -m, m += o; m > 0; i = i * 256 + a[t + p], p += b, m -= 8)
      ;
    for (r = i & (1 << -m) - 1, i >>= -m, m += n; m > 0; r = r * 256 + a[t + p], p += b, m -= 8)
      ;
    if (i === 0)
      i = 1 - E;
    else {
      if (i === l)
        return r ? NaN : (w ? -1 : 1) * (1 / 0);
      r = r + Math.pow(2, n), i = i - E;
    }
    return (w ? -1 : 1) * r * Math.pow(2, i - n);
  }, Fe.write = function(a, t, e, n, s, i) {
    var r, o, l, E = i * 8 - s - 1, m = (1 << E) - 1, p = m >> 1, b = s === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, w = n ? 0 : i - 1, D = n ? 1 : -1, _ = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
    for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (o = isNaN(t) ? 1 : 0, r = m) : (r = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -r)) < 1 && (r--, l *= 2), r + p >= 1 ? t += b / l : t += b * Math.pow(2, 1 - p), t * l >= 2 && (r++, l /= 2), r + p >= m ? (o = 0, r = m) : r + p >= 1 ? (o = (t * l - 1) * Math.pow(2, s), r = r + p) : (o = t * Math.pow(2, p - 1) * Math.pow(2, s), r = 0)); s >= 8; a[e + w] = o & 255, w += D, o /= 256, s -= 8)
      ;
    for (r = r << s | o, E += s; E > 0; a[e + w] = r & 255, w += D, r /= 256, E -= 8)
      ;
    a[e + w - D] |= _ * 128;
  }), Fe;
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var Pi;
function na() {
  return Pi || (Pi = 1, function(a) {
    var t = ta(), e = ea(), n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    a.Buffer = o, a.SlowBuffer = C, a.INSPECT_MAX_BYTES = 50;
    var s = 2147483647;
    a.kMaxLength = s, o.TYPED_ARRAY_SUPPORT = i(), !o.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function i() {
      try {
        var f = new Uint8Array(1), u = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(u, Uint8Array.prototype), Object.setPrototypeOf(f, u), f.foo() === 42;
      } catch {
        return !1;
      }
    }
    Object.defineProperty(o.prototype, "parent", {
      enumerable: !0,
      get: function() {
        if (o.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(o.prototype, "offset", {
      enumerable: !0,
      get: function() {
        if (o.isBuffer(this))
          return this.byteOffset;
      }
    });
    function r(f) {
      if (f > s)
        throw new RangeError('The value "' + f + '" is invalid for option "size"');
      var u = new Uint8Array(f);
      return Object.setPrototypeOf(u, o.prototype), u;
    }
    function o(f, u, c) {
      if (typeof f == "number") {
        if (typeof u == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return p(f);
      }
      return l(f, u, c);
    }
    o.poolSize = 8192;
    function l(f, u, c) {
      if (typeof f == "string")
        return b(f, u);
      if (ArrayBuffer.isView(f))
        return D(f);
      if (f == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof f
        );
      if (rt(f, ArrayBuffer) || f && rt(f.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (rt(f, SharedArrayBuffer) || f && rt(f.buffer, SharedArrayBuffer)))
        return _(f, u, c);
      if (typeof f == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      var h = f.valueOf && f.valueOf();
      if (h != null && h !== f)
        return o.from(h, u, c);
      var N = I(f);
      if (N) return N;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof f[Symbol.toPrimitive] == "function")
        return o.from(
          f[Symbol.toPrimitive]("string"),
          u,
          c
        );
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof f
      );
    }
    o.from = function(f, u, c) {
      return l(f, u, c);
    }, Object.setPrototypeOf(o.prototype, Uint8Array.prototype), Object.setPrototypeOf(o, Uint8Array);
    function E(f) {
      if (typeof f != "number")
        throw new TypeError('"size" argument must be of type number');
      if (f < 0)
        throw new RangeError('The value "' + f + '" is invalid for option "size"');
    }
    function m(f, u, c) {
      return E(f), f <= 0 ? r(f) : u !== void 0 ? typeof c == "string" ? r(f).fill(u, c) : r(f).fill(u) : r(f);
    }
    o.alloc = function(f, u, c) {
      return m(f, u, c);
    };
    function p(f) {
      return E(f), r(f < 0 ? 0 : T(f) | 0);
    }
    o.allocUnsafe = function(f) {
      return p(f);
    }, o.allocUnsafeSlow = function(f) {
      return p(f);
    };
    function b(f, u) {
      if ((typeof u != "string" || u === "") && (u = "utf8"), !o.isEncoding(u))
        throw new TypeError("Unknown encoding: " + u);
      var c = g(f, u) | 0, h = r(c), N = h.write(f, u);
      return N !== c && (h = h.slice(0, N)), h;
    }
    function w(f) {
      for (var u = f.length < 0 ? 0 : T(f.length) | 0, c = r(u), h = 0; h < u; h += 1)
        c[h] = f[h] & 255;
      return c;
    }
    function D(f) {
      if (rt(f, Uint8Array)) {
        var u = new Uint8Array(f);
        return _(u.buffer, u.byteOffset, u.byteLength);
      }
      return w(f);
    }
    function _(f, u, c) {
      if (u < 0 || f.byteLength < u)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (f.byteLength < u + (c || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      var h;
      return u === void 0 && c === void 0 ? h = new Uint8Array(f) : c === void 0 ? h = new Uint8Array(f, u) : h = new Uint8Array(f, u, c), Object.setPrototypeOf(h, o.prototype), h;
    }
    function I(f) {
      if (o.isBuffer(f)) {
        var u = T(f.length) | 0, c = r(u);
        return c.length === 0 || f.copy(c, 0, 0, u), c;
      }
      if (f.length !== void 0)
        return typeof f.length != "number" || ht(f.length) ? r(0) : w(f);
      if (f.type === "Buffer" && Array.isArray(f.data))
        return w(f.data);
    }
    function T(f) {
      if (f >= s)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s.toString(16) + " bytes");
      return f | 0;
    }
    function C(f) {
      return +f != f && (f = 0), o.alloc(+f);
    }
    o.isBuffer = function(u) {
      return u != null && u._isBuffer === !0 && u !== o.prototype;
    }, o.compare = function(u, c) {
      if (rt(u, Uint8Array) && (u = o.from(u, u.offset, u.byteLength)), rt(c, Uint8Array) && (c = o.from(c, c.offset, c.byteLength)), !o.isBuffer(u) || !o.isBuffer(c))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (u === c) return 0;
      for (var h = u.length, N = c.length, L = 0, j = Math.min(h, N); L < j; ++L)
        if (u[L] !== c[L]) {
          h = u[L], N = c[L];
          break;
        }
      return h < N ? -1 : N < h ? 1 : 0;
    }, o.isEncoding = function(u) {
      switch (String(u).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, o.concat = function(u, c) {
      if (!Array.isArray(u))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (u.length === 0)
        return o.alloc(0);
      var h;
      if (c === void 0)
        for (c = 0, h = 0; h < u.length; ++h)
          c += u[h].length;
      var N = o.allocUnsafe(c), L = 0;
      for (h = 0; h < u.length; ++h) {
        var j = u[h];
        if (rt(j, Uint8Array))
          L + j.length > N.length ? o.from(j).copy(N, L) : Uint8Array.prototype.set.call(
            N,
            j,
            L
          );
        else if (o.isBuffer(j))
          j.copy(N, L);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        L += j.length;
      }
      return N;
    };
    function g(f, u) {
      if (o.isBuffer(f))
        return f.length;
      if (ArrayBuffer.isView(f) || rt(f, ArrayBuffer))
        return f.byteLength;
      if (typeof f != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof f
        );
      var c = f.length, h = arguments.length > 2 && arguments[2] === !0;
      if (!h && c === 0) return 0;
      for (var N = !1; ; )
        switch (u) {
          case "ascii":
          case "latin1":
          case "binary":
            return c;
          case "utf8":
          case "utf-8":
            return y(f).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return c * 2;
          case "hex":
            return c >>> 1;
          case "base64":
            return J(f).length;
          default:
            if (N)
              return h ? -1 : y(f).length;
            u = ("" + u).toLowerCase(), N = !0;
        }
    }
    o.byteLength = g;
    function v(f, u, c) {
      var h = !1;
      if ((u === void 0 || u < 0) && (u = 0), u > this.length || ((c === void 0 || c > this.length) && (c = this.length), c <= 0) || (c >>>= 0, u >>>= 0, c <= u))
        return "";
      for (f || (f = "utf8"); ; )
        switch (f) {
          case "hex":
            return Ot(this, u, c);
          case "utf8":
          case "utf-8":
            return q(this, u, c);
          case "ascii":
            return V(this, u, c);
          case "latin1":
          case "binary":
            return ft(this, u, c);
          case "base64":
            return $(this, u, c);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return at(this, u, c);
          default:
            if (h) throw new TypeError("Unknown encoding: " + f);
            f = (f + "").toLowerCase(), h = !0;
        }
    }
    o.prototype._isBuffer = !0;
    function M(f, u, c) {
      var h = f[u];
      f[u] = f[c], f[c] = h;
    }
    o.prototype.swap16 = function() {
      var u = this.length;
      if (u % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var c = 0; c < u; c += 2)
        M(this, c, c + 1);
      return this;
    }, o.prototype.swap32 = function() {
      var u = this.length;
      if (u % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var c = 0; c < u; c += 4)
        M(this, c, c + 3), M(this, c + 1, c + 2);
      return this;
    }, o.prototype.swap64 = function() {
      var u = this.length;
      if (u % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var c = 0; c < u; c += 8)
        M(this, c, c + 7), M(this, c + 1, c + 6), M(this, c + 2, c + 5), M(this, c + 3, c + 4);
      return this;
    }, o.prototype.toString = function() {
      var u = this.length;
      return u === 0 ? "" : arguments.length === 0 ? q(this, 0, u) : v.apply(this, arguments);
    }, o.prototype.toLocaleString = o.prototype.toString, o.prototype.equals = function(u) {
      if (!o.isBuffer(u)) throw new TypeError("Argument must be a Buffer");
      return this === u ? !0 : o.compare(this, u) === 0;
    }, o.prototype.inspect = function() {
      var u = "", c = a.INSPECT_MAX_BYTES;
      return u = this.toString("hex", 0, c).replace(/(.{2})/g, "$1 ").trim(), this.length > c && (u += " ... "), "<Buffer " + u + ">";
    }, n && (o.prototype[n] = o.prototype.inspect), o.prototype.compare = function(u, c, h, N, L) {
      if (rt(u, Uint8Array) && (u = o.from(u, u.offset, u.byteLength)), !o.isBuffer(u))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof u
        );
      if (c === void 0 && (c = 0), h === void 0 && (h = u ? u.length : 0), N === void 0 && (N = 0), L === void 0 && (L = this.length), c < 0 || h > u.length || N < 0 || L > this.length)
        throw new RangeError("out of range index");
      if (N >= L && c >= h)
        return 0;
      if (N >= L)
        return -1;
      if (c >= h)
        return 1;
      if (c >>>= 0, h >>>= 0, N >>>= 0, L >>>= 0, this === u) return 0;
      for (var j = L - N, Z = h - c, nt = Math.min(j, Z), lt = this.slice(N, L), Et = u.slice(c, h), pt = 0; pt < nt; ++pt)
        if (lt[pt] !== Et[pt]) {
          j = lt[pt], Z = Et[pt];
          break;
        }
      return j < Z ? -1 : Z < j ? 1 : 0;
    };
    function X(f, u, c, h, N) {
      if (f.length === 0) return -1;
      if (typeof c == "string" ? (h = c, c = 0) : c > 2147483647 ? c = 2147483647 : c < -2147483648 && (c = -2147483648), c = +c, ht(c) && (c = N ? 0 : f.length - 1), c < 0 && (c = f.length + c), c >= f.length) {
        if (N) return -1;
        c = f.length - 1;
      } else if (c < 0)
        if (N) c = 0;
        else return -1;
      if (typeof u == "string" && (u = o.from(u, h)), o.isBuffer(u))
        return u.length === 0 ? -1 : W(f, u, c, h, N);
      if (typeof u == "number")
        return u = u & 255, typeof Uint8Array.prototype.indexOf == "function" ? N ? Uint8Array.prototype.indexOf.call(f, u, c) : Uint8Array.prototype.lastIndexOf.call(f, u, c) : W(f, [u], c, h, N);
      throw new TypeError("val must be string, number or Buffer");
    }
    function W(f, u, c, h, N) {
      var L = 1, j = f.length, Z = u.length;
      if (h !== void 0 && (h = String(h).toLowerCase(), h === "ucs2" || h === "ucs-2" || h === "utf16le" || h === "utf-16le")) {
        if (f.length < 2 || u.length < 2)
          return -1;
        L = 2, j /= 2, Z /= 2, c /= 2;
      }
      function nt(pr, dr) {
        return L === 1 ? pr[dr] : pr.readUInt16BE(dr * L);
      }
      var lt;
      if (N) {
        var Et = -1;
        for (lt = c; lt < j; lt++)
          if (nt(f, lt) === nt(u, Et === -1 ? 0 : lt - Et)) {
            if (Et === -1 && (Et = lt), lt - Et + 1 === Z) return Et * L;
          } else
            Et !== -1 && (lt -= lt - Et), Et = -1;
      } else
        for (c + Z > j && (c = j - Z), lt = c; lt >= 0; lt--) {
          for (var pt = !0, Ie = 0; Ie < Z; Ie++)
            if (nt(f, lt + Ie) !== nt(u, Ie)) {
              pt = !1;
              break;
            }
          if (pt) return lt;
        }
      return -1;
    }
    o.prototype.includes = function(u, c, h) {
      return this.indexOf(u, c, h) !== -1;
    }, o.prototype.indexOf = function(u, c, h) {
      return X(this, u, c, h, !0);
    }, o.prototype.lastIndexOf = function(u, c, h) {
      return X(this, u, c, h, !1);
    };
    function U(f, u, c, h) {
      c = Number(c) || 0;
      var N = f.length - c;
      h ? (h = Number(h), h > N && (h = N)) : h = N;
      var L = u.length;
      h > L / 2 && (h = L / 2);
      for (var j = 0; j < h; ++j) {
        var Z = parseInt(u.substr(j * 2, 2), 16);
        if (ht(Z)) return j;
        f[c + j] = Z;
      }
      return j;
    }
    function d(f, u, c, h) {
      return st(y(u, f.length - c), f, c, h);
    }
    function B(f, u, c, h) {
      return st(F(u), f, c, h);
    }
    function S(f, u, c, h) {
      return st(J(u), f, c, h);
    }
    function R(f, u, c, h) {
      return st(P(u, f.length - c), f, c, h);
    }
    o.prototype.write = function(u, c, h, N) {
      if (c === void 0)
        N = "utf8", h = this.length, c = 0;
      else if (h === void 0 && typeof c == "string")
        N = c, h = this.length, c = 0;
      else if (isFinite(c))
        c = c >>> 0, isFinite(h) ? (h = h >>> 0, N === void 0 && (N = "utf8")) : (N = h, h = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      var L = this.length - c;
      if ((h === void 0 || h > L) && (h = L), u.length > 0 && (h < 0 || c < 0) || c > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      N || (N = "utf8");
      for (var j = !1; ; )
        switch (N) {
          case "hex":
            return U(this, u, c, h);
          case "utf8":
          case "utf-8":
            return d(this, u, c, h);
          case "ascii":
          case "latin1":
          case "binary":
            return B(this, u, c, h);
          case "base64":
            return S(this, u, c, h);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return R(this, u, c, h);
          default:
            if (j) throw new TypeError("Unknown encoding: " + N);
            N = ("" + N).toLowerCase(), j = !0;
        }
    }, o.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function $(f, u, c) {
      return u === 0 && c === f.length ? t.fromByteArray(f) : t.fromByteArray(f.slice(u, c));
    }
    function q(f, u, c) {
      c = Math.min(f.length, c);
      for (var h = [], N = u; N < c; ) {
        var L = f[N], j = null, Z = L > 239 ? 4 : L > 223 ? 3 : L > 191 ? 2 : 1;
        if (N + Z <= c) {
          var nt, lt, Et, pt;
          switch (Z) {
            case 1:
              L < 128 && (j = L);
              break;
            case 2:
              nt = f[N + 1], (nt & 192) === 128 && (pt = (L & 31) << 6 | nt & 63, pt > 127 && (j = pt));
              break;
            case 3:
              nt = f[N + 1], lt = f[N + 2], (nt & 192) === 128 && (lt & 192) === 128 && (pt = (L & 15) << 12 | (nt & 63) << 6 | lt & 63, pt > 2047 && (pt < 55296 || pt > 57343) && (j = pt));
              break;
            case 4:
              nt = f[N + 1], lt = f[N + 2], Et = f[N + 3], (nt & 192) === 128 && (lt & 192) === 128 && (Et & 192) === 128 && (pt = (L & 15) << 18 | (nt & 63) << 12 | (lt & 63) << 6 | Et & 63, pt > 65535 && pt < 1114112 && (j = pt));
          }
        }
        j === null ? (j = 65533, Z = 1) : j > 65535 && (j -= 65536, h.push(j >>> 10 & 1023 | 55296), j = 56320 | j & 1023), h.push(j), N += Z;
      }
      return k(h);
    }
    var z = 4096;
    function k(f) {
      var u = f.length;
      if (u <= z)
        return String.fromCharCode.apply(String, f);
      for (var c = "", h = 0; h < u; )
        c += String.fromCharCode.apply(
          String,
          f.slice(h, h += z)
        );
      return c;
    }
    function V(f, u, c) {
      var h = "";
      c = Math.min(f.length, c);
      for (var N = u; N < c; ++N)
        h += String.fromCharCode(f[N] & 127);
      return h;
    }
    function ft(f, u, c) {
      var h = "";
      c = Math.min(f.length, c);
      for (var N = u; N < c; ++N)
        h += String.fromCharCode(f[N]);
      return h;
    }
    function Ot(f, u, c) {
      var h = f.length;
      (!u || u < 0) && (u = 0), (!c || c < 0 || c > h) && (c = h);
      for (var N = "", L = u; L < c; ++L)
        N += A[f[L]];
      return N;
    }
    function at(f, u, c) {
      for (var h = f.slice(u, c), N = "", L = 0; L < h.length - 1; L += 2)
        N += String.fromCharCode(h[L] + h[L + 1] * 256);
      return N;
    }
    o.prototype.slice = function(u, c) {
      var h = this.length;
      u = ~~u, c = c === void 0 ? h : ~~c, u < 0 ? (u += h, u < 0 && (u = 0)) : u > h && (u = h), c < 0 ? (c += h, c < 0 && (c = 0)) : c > h && (c = h), c < u && (c = u);
      var N = this.subarray(u, c);
      return Object.setPrototypeOf(N, o.prototype), N;
    };
    function ot(f, u, c) {
      if (f % 1 !== 0 || f < 0) throw new RangeError("offset is not uint");
      if (f + u > c) throw new RangeError("Trying to access beyond buffer length");
    }
    o.prototype.readUintLE = o.prototype.readUIntLE = function(u, c, h) {
      u = u >>> 0, c = c >>> 0, h || ot(u, c, this.length);
      for (var N = this[u], L = 1, j = 0; ++j < c && (L *= 256); )
        N += this[u + j] * L;
      return N;
    }, o.prototype.readUintBE = o.prototype.readUIntBE = function(u, c, h) {
      u = u >>> 0, c = c >>> 0, h || ot(u, c, this.length);
      for (var N = this[u + --c], L = 1; c > 0 && (L *= 256); )
        N += this[u + --c] * L;
      return N;
    }, o.prototype.readUint8 = o.prototype.readUInt8 = function(u, c) {
      return u = u >>> 0, c || ot(u, 1, this.length), this[u];
    }, o.prototype.readUint16LE = o.prototype.readUInt16LE = function(u, c) {
      return u = u >>> 0, c || ot(u, 2, this.length), this[u] | this[u + 1] << 8;
    }, o.prototype.readUint16BE = o.prototype.readUInt16BE = function(u, c) {
      return u = u >>> 0, c || ot(u, 2, this.length), this[u] << 8 | this[u + 1];
    }, o.prototype.readUint32LE = o.prototype.readUInt32LE = function(u, c) {
      return u = u >>> 0, c || ot(u, 4, this.length), (this[u] | this[u + 1] << 8 | this[u + 2] << 16) + this[u + 3] * 16777216;
    }, o.prototype.readUint32BE = o.prototype.readUInt32BE = function(u, c) {
      return u = u >>> 0, c || ot(u, 4, this.length), this[u] * 16777216 + (this[u + 1] << 16 | this[u + 2] << 8 | this[u + 3]);
    }, o.prototype.readIntLE = function(u, c, h) {
      u = u >>> 0, c = c >>> 0, h || ot(u, c, this.length);
      for (var N = this[u], L = 1, j = 0; ++j < c && (L *= 256); )
        N += this[u + j] * L;
      return L *= 128, N >= L && (N -= Math.pow(2, 8 * c)), N;
    }, o.prototype.readIntBE = function(u, c, h) {
      u = u >>> 0, c = c >>> 0, h || ot(u, c, this.length);
      for (var N = c, L = 1, j = this[u + --N]; N > 0 && (L *= 256); )
        j += this[u + --N] * L;
      return L *= 128, j >= L && (j -= Math.pow(2, 8 * c)), j;
    }, o.prototype.readInt8 = function(u, c) {
      return u = u >>> 0, c || ot(u, 1, this.length), this[u] & 128 ? (255 - this[u] + 1) * -1 : this[u];
    }, o.prototype.readInt16LE = function(u, c) {
      u = u >>> 0, c || ot(u, 2, this.length);
      var h = this[u] | this[u + 1] << 8;
      return h & 32768 ? h | 4294901760 : h;
    }, o.prototype.readInt16BE = function(u, c) {
      u = u >>> 0, c || ot(u, 2, this.length);
      var h = this[u + 1] | this[u] << 8;
      return h & 32768 ? h | 4294901760 : h;
    }, o.prototype.readInt32LE = function(u, c) {
      return u = u >>> 0, c || ot(u, 4, this.length), this[u] | this[u + 1] << 8 | this[u + 2] << 16 | this[u + 3] << 24;
    }, o.prototype.readInt32BE = function(u, c) {
      return u = u >>> 0, c || ot(u, 4, this.length), this[u] << 24 | this[u + 1] << 16 | this[u + 2] << 8 | this[u + 3];
    }, o.prototype.readFloatLE = function(u, c) {
      return u = u >>> 0, c || ot(u, 4, this.length), e.read(this, u, !0, 23, 4);
    }, o.prototype.readFloatBE = function(u, c) {
      return u = u >>> 0, c || ot(u, 4, this.length), e.read(this, u, !1, 23, 4);
    }, o.prototype.readDoubleLE = function(u, c) {
      return u = u >>> 0, c || ot(u, 8, this.length), e.read(this, u, !0, 52, 8);
    }, o.prototype.readDoubleBE = function(u, c) {
      return u = u >>> 0, c || ot(u, 8, this.length), e.read(this, u, !1, 52, 8);
    };
    function ut(f, u, c, h, N, L) {
      if (!o.isBuffer(f)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (u > N || u < L) throw new RangeError('"value" argument is out of bounds');
      if (c + h > f.length) throw new RangeError("Index out of range");
    }
    o.prototype.writeUintLE = o.prototype.writeUIntLE = function(u, c, h, N) {
      if (u = +u, c = c >>> 0, h = h >>> 0, !N) {
        var L = Math.pow(2, 8 * h) - 1;
        ut(this, u, c, h, L, 0);
      }
      var j = 1, Z = 0;
      for (this[c] = u & 255; ++Z < h && (j *= 256); )
        this[c + Z] = u / j & 255;
      return c + h;
    }, o.prototype.writeUintBE = o.prototype.writeUIntBE = function(u, c, h, N) {
      if (u = +u, c = c >>> 0, h = h >>> 0, !N) {
        var L = Math.pow(2, 8 * h) - 1;
        ut(this, u, c, h, L, 0);
      }
      var j = h - 1, Z = 1;
      for (this[c + j] = u & 255; --j >= 0 && (Z *= 256); )
        this[c + j] = u / Z & 255;
      return c + h;
    }, o.prototype.writeUint8 = o.prototype.writeUInt8 = function(u, c, h) {
      return u = +u, c = c >>> 0, h || ut(this, u, c, 1, 255, 0), this[c] = u & 255, c + 1;
    }, o.prototype.writeUint16LE = o.prototype.writeUInt16LE = function(u, c, h) {
      return u = +u, c = c >>> 0, h || ut(this, u, c, 2, 65535, 0), this[c] = u & 255, this[c + 1] = u >>> 8, c + 2;
    }, o.prototype.writeUint16BE = o.prototype.writeUInt16BE = function(u, c, h) {
      return u = +u, c = c >>> 0, h || ut(this, u, c, 2, 65535, 0), this[c] = u >>> 8, this[c + 1] = u & 255, c + 2;
    }, o.prototype.writeUint32LE = o.prototype.writeUInt32LE = function(u, c, h) {
      return u = +u, c = c >>> 0, h || ut(this, u, c, 4, 4294967295, 0), this[c + 3] = u >>> 24, this[c + 2] = u >>> 16, this[c + 1] = u >>> 8, this[c] = u & 255, c + 4;
    }, o.prototype.writeUint32BE = o.prototype.writeUInt32BE = function(u, c, h) {
      return u = +u, c = c >>> 0, h || ut(this, u, c, 4, 4294967295, 0), this[c] = u >>> 24, this[c + 1] = u >>> 16, this[c + 2] = u >>> 8, this[c + 3] = u & 255, c + 4;
    }, o.prototype.writeIntLE = function(u, c, h, N) {
      if (u = +u, c = c >>> 0, !N) {
        var L = Math.pow(2, 8 * h - 1);
        ut(this, u, c, h, L - 1, -L);
      }
      var j = 0, Z = 1, nt = 0;
      for (this[c] = u & 255; ++j < h && (Z *= 256); )
        u < 0 && nt === 0 && this[c + j - 1] !== 0 && (nt = 1), this[c + j] = (u / Z >> 0) - nt & 255;
      return c + h;
    }, o.prototype.writeIntBE = function(u, c, h, N) {
      if (u = +u, c = c >>> 0, !N) {
        var L = Math.pow(2, 8 * h - 1);
        ut(this, u, c, h, L - 1, -L);
      }
      var j = h - 1, Z = 1, nt = 0;
      for (this[c + j] = u & 255; --j >= 0 && (Z *= 256); )
        u < 0 && nt === 0 && this[c + j + 1] !== 0 && (nt = 1), this[c + j] = (u / Z >> 0) - nt & 255;
      return c + h;
    }, o.prototype.writeInt8 = function(u, c, h) {
      return u = +u, c = c >>> 0, h || ut(this, u, c, 1, 127, -128), u < 0 && (u = 255 + u + 1), this[c] = u & 255, c + 1;
    }, o.prototype.writeInt16LE = function(u, c, h) {
      return u = +u, c = c >>> 0, h || ut(this, u, c, 2, 32767, -32768), this[c] = u & 255, this[c + 1] = u >>> 8, c + 2;
    }, o.prototype.writeInt16BE = function(u, c, h) {
      return u = +u, c = c >>> 0, h || ut(this, u, c, 2, 32767, -32768), this[c] = u >>> 8, this[c + 1] = u & 255, c + 2;
    }, o.prototype.writeInt32LE = function(u, c, h) {
      return u = +u, c = c >>> 0, h || ut(this, u, c, 4, 2147483647, -2147483648), this[c] = u & 255, this[c + 1] = u >>> 8, this[c + 2] = u >>> 16, this[c + 3] = u >>> 24, c + 4;
    }, o.prototype.writeInt32BE = function(u, c, h) {
      return u = +u, c = c >>> 0, h || ut(this, u, c, 4, 2147483647, -2147483648), u < 0 && (u = 4294967295 + u + 1), this[c] = u >>> 24, this[c + 1] = u >>> 16, this[c + 2] = u >>> 8, this[c + 3] = u & 255, c + 4;
    };
    function vt(f, u, c, h, N, L) {
      if (c + h > f.length) throw new RangeError("Index out of range");
      if (c < 0) throw new RangeError("Index out of range");
    }
    function K(f, u, c, h, N) {
      return u = +u, c = c >>> 0, N || vt(f, u, c, 4), e.write(f, u, c, h, 23, 4), c + 4;
    }
    o.prototype.writeFloatLE = function(u, c, h) {
      return K(this, u, c, !0, h);
    }, o.prototype.writeFloatBE = function(u, c, h) {
      return K(this, u, c, !1, h);
    };
    function Bt(f, u, c, h, N) {
      return u = +u, c = c >>> 0, N || vt(f, u, c, 8), e.write(f, u, c, h, 52, 8), c + 8;
    }
    o.prototype.writeDoubleLE = function(u, c, h) {
      return Bt(this, u, c, !0, h);
    }, o.prototype.writeDoubleBE = function(u, c, h) {
      return Bt(this, u, c, !1, h);
    }, o.prototype.copy = function(u, c, h, N) {
      if (!o.isBuffer(u)) throw new TypeError("argument should be a Buffer");
      if (h || (h = 0), !N && N !== 0 && (N = this.length), c >= u.length && (c = u.length), c || (c = 0), N > 0 && N < h && (N = h), N === h || u.length === 0 || this.length === 0) return 0;
      if (c < 0)
        throw new RangeError("targetStart out of bounds");
      if (h < 0 || h >= this.length) throw new RangeError("Index out of range");
      if (N < 0) throw new RangeError("sourceEnd out of bounds");
      N > this.length && (N = this.length), u.length - c < N - h && (N = u.length - c + h);
      var L = N - h;
      return this === u && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(c, h, N) : Uint8Array.prototype.set.call(
        u,
        this.subarray(h, N),
        c
      ), L;
    }, o.prototype.fill = function(u, c, h, N) {
      if (typeof u == "string") {
        if (typeof c == "string" ? (N = c, c = 0, h = this.length) : typeof h == "string" && (N = h, h = this.length), N !== void 0 && typeof N != "string")
          throw new TypeError("encoding must be a string");
        if (typeof N == "string" && !o.isEncoding(N))
          throw new TypeError("Unknown encoding: " + N);
        if (u.length === 1) {
          var L = u.charCodeAt(0);
          (N === "utf8" && L < 128 || N === "latin1") && (u = L);
        }
      } else typeof u == "number" ? u = u & 255 : typeof u == "boolean" && (u = Number(u));
      if (c < 0 || this.length < c || this.length < h)
        throw new RangeError("Out of range index");
      if (h <= c)
        return this;
      c = c >>> 0, h = h === void 0 ? this.length : h >>> 0, u || (u = 0);
      var j;
      if (typeof u == "number")
        for (j = c; j < h; ++j)
          this[j] = u;
      else {
        var Z = o.isBuffer(u) ? u : o.from(u, N), nt = Z.length;
        if (nt === 0)
          throw new TypeError('The value "' + u + '" is invalid for argument "value"');
        for (j = 0; j < h - c; ++j)
          this[j + c] = Z[j % nt];
      }
      return this;
    };
    var Q = /[^+/0-9A-Za-z-_]/g;
    function x(f) {
      if (f = f.split("=")[0], f = f.trim().replace(Q, ""), f.length < 2) return "";
      for (; f.length % 4 !== 0; )
        f = f + "=";
      return f;
    }
    function y(f, u) {
      u = u || 1 / 0;
      for (var c, h = f.length, N = null, L = [], j = 0; j < h; ++j) {
        if (c = f.charCodeAt(j), c > 55295 && c < 57344) {
          if (!N) {
            if (c > 56319) {
              (u -= 3) > -1 && L.push(239, 191, 189);
              continue;
            } else if (j + 1 === h) {
              (u -= 3) > -1 && L.push(239, 191, 189);
              continue;
            }
            N = c;
            continue;
          }
          if (c < 56320) {
            (u -= 3) > -1 && L.push(239, 191, 189), N = c;
            continue;
          }
          c = (N - 55296 << 10 | c - 56320) + 65536;
        } else N && (u -= 3) > -1 && L.push(239, 191, 189);
        if (N = null, c < 128) {
          if ((u -= 1) < 0) break;
          L.push(c);
        } else if (c < 2048) {
          if ((u -= 2) < 0) break;
          L.push(
            c >> 6 | 192,
            c & 63 | 128
          );
        } else if (c < 65536) {
          if ((u -= 3) < 0) break;
          L.push(
            c >> 12 | 224,
            c >> 6 & 63 | 128,
            c & 63 | 128
          );
        } else if (c < 1114112) {
          if ((u -= 4) < 0) break;
          L.push(
            c >> 18 | 240,
            c >> 12 & 63 | 128,
            c >> 6 & 63 | 128,
            c & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return L;
    }
    function F(f) {
      for (var u = [], c = 0; c < f.length; ++c)
        u.push(f.charCodeAt(c) & 255);
      return u;
    }
    function P(f, u) {
      for (var c, h, N, L = [], j = 0; j < f.length && !((u -= 2) < 0); ++j)
        c = f.charCodeAt(j), h = c >> 8, N = c % 256, L.push(N), L.push(h);
      return L;
    }
    function J(f) {
      return t.toByteArray(x(f));
    }
    function st(f, u, c, h) {
      for (var N = 0; N < h && !(N + c >= u.length || N >= f.length); ++N)
        u[N + c] = f[N];
      return N;
    }
    function rt(f, u) {
      return f instanceof u || f != null && f.constructor != null && f.constructor.name != null && f.constructor.name === u.name;
    }
    function ht(f) {
      return f !== f;
    }
    var A = function() {
      for (var f = "0123456789abcdef", u = new Array(256), c = 0; c < 16; ++c)
        for (var h = c * 16, N = 0; N < 16; ++N)
          u[h + N] = f[c] + f[N];
      return u;
    }();
  }($n)), $n;
}
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var Li;
function ra() {
  return Li || (Li = 1, function(a, t) {
    var e = na(), n = e.Buffer;
    function s(r, o) {
      for (var l in r)
        o[l] = r[l];
    }
    n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? a.exports = e : (s(e, t), t.Buffer = i);
    function i(r, o, l) {
      return n(r, o, l);
    }
    i.prototype = Object.create(n.prototype), s(n, i), i.from = function(r, o, l) {
      if (typeof r == "number")
        throw new TypeError("Argument must not be a number");
      return n(r, o, l);
    }, i.alloc = function(r, o, l) {
      if (typeof r != "number")
        throw new TypeError("Argument must be a number");
      var E = n(r);
      return o !== void 0 ? typeof l == "string" ? E.fill(o, l) : E.fill(o) : E.fill(0), E;
    }, i.allocUnsafe = function(r) {
      if (typeof r != "number")
        throw new TypeError("Argument must be a number");
      return n(r);
    }, i.allocUnsafeSlow = function(r) {
      if (typeof r != "number")
        throw new TypeError("Argument must be a number");
      return e.SlowBuffer(r);
    };
  }(Se, Se.exports)), Se.exports;
}
var Si;
function ia() {
  if (Si) return Xn;
  Si = 1;
  var a = ra().Buffer, t = a.isEncoding || function(T) {
    switch (T = "" + T, T && T.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function e(T) {
    if (!T) return "utf8";
    for (var C; ; )
      switch (T) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return T;
        default:
          if (C) return;
          T = ("" + T).toLowerCase(), C = !0;
      }
  }
  function n(T) {
    var C = e(T);
    if (typeof C != "string" && (a.isEncoding === t || !t(T))) throw new Error("Unknown encoding: " + T);
    return C || T;
  }
  Xn.StringDecoder = s;
  function s(T) {
    this.encoding = n(T);
    var C;
    switch (this.encoding) {
      case "utf16le":
        this.text = p, this.end = b, C = 4;
        break;
      case "utf8":
        this.fillLast = l, C = 4;
        break;
      case "base64":
        this.text = w, this.end = D, C = 3;
        break;
      default:
        this.write = _, this.end = I;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = a.allocUnsafe(C);
  }
  s.prototype.write = function(T) {
    if (T.length === 0) return "";
    var C, g;
    if (this.lastNeed) {
      if (C = this.fillLast(T), C === void 0) return "";
      g = this.lastNeed, this.lastNeed = 0;
    } else
      g = 0;
    return g < T.length ? C ? C + this.text(T, g) : this.text(T, g) : C || "";
  }, s.prototype.end = m, s.prototype.text = E, s.prototype.fillLast = function(T) {
    if (this.lastNeed <= T.length)
      return T.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    T.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, T.length), this.lastNeed -= T.length;
  };
  function i(T) {
    return T <= 127 ? 0 : T >> 5 === 6 ? 2 : T >> 4 === 14 ? 3 : T >> 3 === 30 ? 4 : T >> 6 === 2 ? -1 : -2;
  }
  function r(T, C, g) {
    var v = C.length - 1;
    if (v < g) return 0;
    var M = i(C[v]);
    return M >= 0 ? (M > 0 && (T.lastNeed = M - 1), M) : --v < g || M === -2 ? 0 : (M = i(C[v]), M >= 0 ? (M > 0 && (T.lastNeed = M - 2), M) : --v < g || M === -2 ? 0 : (M = i(C[v]), M >= 0 ? (M > 0 && (M === 2 ? M = 0 : T.lastNeed = M - 3), M) : 0));
  }
  function o(T, C, g) {
    if ((C[0] & 192) !== 128)
      return T.lastNeed = 0, "";
    if (T.lastNeed > 1 && C.length > 1) {
      if ((C[1] & 192) !== 128)
        return T.lastNeed = 1, "";
      if (T.lastNeed > 2 && C.length > 2 && (C[2] & 192) !== 128)
        return T.lastNeed = 2, "";
    }
  }
  function l(T) {
    var C = this.lastTotal - this.lastNeed, g = o(this, T);
    if (g !== void 0) return g;
    if (this.lastNeed <= T.length)
      return T.copy(this.lastChar, C, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    T.copy(this.lastChar, C, 0, T.length), this.lastNeed -= T.length;
  }
  function E(T, C) {
    var g = r(this, T, C);
    if (!this.lastNeed) return T.toString("utf8", C);
    this.lastTotal = g;
    var v = T.length - (g - this.lastNeed);
    return T.copy(this.lastChar, 0, v), T.toString("utf8", C, v);
  }
  function m(T) {
    var C = T && T.length ? this.write(T) : "";
    return this.lastNeed ? C + "" : C;
  }
  function p(T, C) {
    if ((T.length - C) % 2 === 0) {
      var g = T.toString("utf16le", C);
      if (g) {
        var v = g.charCodeAt(g.length - 1);
        if (v >= 55296 && v <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = T[T.length - 2], this.lastChar[1] = T[T.length - 1], g.slice(0, -1);
      }
      return g;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = T[T.length - 1], T.toString("utf16le", C, T.length - 1);
  }
  function b(T) {
    var C = T && T.length ? this.write(T) : "";
    if (this.lastNeed) {
      var g = this.lastTotal - this.lastNeed;
      return C + this.lastChar.toString("utf16le", 0, g);
    }
    return C;
  }
  function w(T, C) {
    var g = (T.length - C) % 3;
    return g === 0 ? T.toString("base64", C) : (this.lastNeed = 3 - g, this.lastTotal = 3, g === 1 ? this.lastChar[0] = T[T.length - 1] : (this.lastChar[0] = T[T.length - 2], this.lastChar[1] = T[T.length - 1]), T.toString("base64", C, T.length - g));
  }
  function D(T) {
    var C = T && T.length ? this.write(T) : "";
    return this.lastNeed ? C + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : C;
  }
  function _(T) {
    return T.toString(this.encoding);
  }
  function I(T) {
    return T && T.length ? this.write(T) : "";
  }
  return Xn;
}
var Fi;
function sa() {
  return Fi || (Fi = 1, function(a) {
    (function(t) {
      t.parser = function(x, y) {
        return new n(x, y);
      }, t.SAXParser = n, t.SAXStream = m, t.createStream = E, t.MAX_BUFFER_LENGTH = 64 * 1024;
      var e = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      t.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function n(x, y) {
        if (!(this instanceof n))
          return new n(x, y);
        var F = this;
        i(F), F.q = F.c = "", F.bufferCheckPosition = t.MAX_BUFFER_LENGTH, F.opt = y || {}, F.opt.lowercase = F.opt.lowercase || F.opt.lowercasetags, F.looseCase = F.opt.lowercase ? "toLowerCase" : "toUpperCase", F.tags = [], F.closed = F.closedRoot = F.sawRoot = !1, F.tag = F.error = null, F.strict = !!x, F.noscript = !!(x || F.opt.noscript), F.state = d.BEGIN, F.strictEntities = F.opt.strictEntities, F.ENTITIES = F.strictEntities ? Object.create(t.XML_ENTITIES) : Object.create(t.ENTITIES), F.attribList = [], F.opt.xmlns && (F.ns = Object.create(_)), F.opt.unquotedAttributeValues === void 0 && (F.opt.unquotedAttributeValues = !x), F.trackPosition = F.opt.position !== !1, F.trackPosition && (F.position = F.line = F.column = 0), S(F, "onready");
      }
      Object.create || (Object.create = function(x) {
        function y() {
        }
        y.prototype = x;
        var F = new y();
        return F;
      }), Object.keys || (Object.keys = function(x) {
        var y = [];
        for (var F in x) x.hasOwnProperty(F) && y.push(F);
        return y;
      });
      function s(x) {
        for (var y = Math.max(t.MAX_BUFFER_LENGTH, 10), F = 0, P = 0, J = e.length; P < J; P++) {
          var st = x[e[P]].length;
          if (st > y)
            switch (e[P]) {
              case "textNode":
                $(x);
                break;
              case "cdata":
                R(x, "oncdata", x.cdata), x.cdata = "";
                break;
              case "script":
                R(x, "onscript", x.script), x.script = "";
                break;
              default:
                z(x, "Max buffer length exceeded: " + e[P]);
            }
          F = Math.max(F, st);
        }
        var rt = t.MAX_BUFFER_LENGTH - F;
        x.bufferCheckPosition = rt + x.position;
      }
      function i(x) {
        for (var y = 0, F = e.length; y < F; y++)
          x[e[y]] = "";
      }
      function r(x) {
        $(x), x.cdata !== "" && (R(x, "oncdata", x.cdata), x.cdata = ""), x.script !== "" && (R(x, "onscript", x.script), x.script = "");
      }
      n.prototype = {
        end: function() {
          k(this);
        },
        write: Q,
        resume: function() {
          return this.error = null, this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          r(this);
        }
      };
      var o;
      try {
        o = require("stream").Stream;
      } catch {
        o = function() {
        };
      }
      o || (o = function() {
      });
      var l = t.EVENTS.filter(function(x) {
        return x !== "error" && x !== "end";
      });
      function E(x, y) {
        return new m(x, y);
      }
      function m(x, y) {
        if (!(this instanceof m))
          return new m(x, y);
        o.apply(this), this._parser = new n(x, y), this.writable = !0, this.readable = !0;
        var F = this;
        this._parser.onend = function() {
          F.emit("end");
        }, this._parser.onerror = function(P) {
          F.emit("error", P), F._parser.error = null;
        }, this._decoder = null, l.forEach(function(P) {
          Object.defineProperty(F, "on" + P, {
            get: function() {
              return F._parser["on" + P];
            },
            set: function(J) {
              if (!J)
                return F.removeAllListeners(P), F._parser["on" + P] = J, J;
              F.on(P, J);
            },
            enumerable: !0,
            configurable: !1
          });
        });
      }
      m.prototype = Object.create(o.prototype, {
        constructor: {
          value: m
        }
      }), m.prototype.write = function(x) {
        if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(x)) {
          if (!this._decoder) {
            var y = ia().StringDecoder;
            this._decoder = new y("utf8");
          }
          x = this._decoder.write(x);
        }
        return this._parser.write(x.toString()), this.emit("data", x), !0;
      }, m.prototype.end = function(x) {
        return x && x.length && this.write(x), this._parser.end(), !0;
      }, m.prototype.on = function(x, y) {
        var F = this;
        return !F._parser["on" + x] && l.indexOf(x) !== -1 && (F._parser["on" + x] = function() {
          var P = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          P.splice(0, 0, x), F.emit.apply(F, P);
        }), o.prototype.on.call(F, x, y);
      };
      var p = "[CDATA[", b = "DOCTYPE", w = "http://www.w3.org/XML/1998/namespace", D = "http://www.w3.org/2000/xmlns/", _ = { xml: w, xmlns: D }, I = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, T = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, C = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, g = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function v(x) {
        return x === " " || x === `
` || x === "\r" || x === "	";
      }
      function M(x) {
        return x === '"' || x === "'";
      }
      function X(x) {
        return x === ">" || v(x);
      }
      function W(x, y) {
        return x.test(y);
      }
      function U(x, y) {
        return !W(x, y);
      }
      var d = 0;
      t.STATE = {
        BEGIN: d++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: d++,
        // leading whitespace
        TEXT: d++,
        // general stuff
        TEXT_ENTITY: d++,
        // &amp and such.
        OPEN_WAKA: d++,
        // <
        SGML_DECL: d++,
        // <!BLARG
        SGML_DECL_QUOTED: d++,
        // <!BLARG foo "bar
        DOCTYPE: d++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: d++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: d++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: d++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: d++,
        // <!-
        COMMENT: d++,
        // <!--
        COMMENT_ENDING: d++,
        // <!-- blah -
        COMMENT_ENDED: d++,
        // <!-- blah --
        CDATA: d++,
        // <![CDATA[ something
        CDATA_ENDING: d++,
        // ]
        CDATA_ENDING_2: d++,
        // ]]
        PROC_INST: d++,
        // <?hi
        PROC_INST_BODY: d++,
        // <?hi there
        PROC_INST_ENDING: d++,
        // <?hi "there" ?
        OPEN_TAG: d++,
        // <strong
        OPEN_TAG_SLASH: d++,
        // <strong /
        ATTRIB: d++,
        // <a
        ATTRIB_NAME: d++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: d++,
        // <a foo _
        ATTRIB_VALUE: d++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: d++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: d++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: d++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: d++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: d++,
        // <foo bar=&quot
        CLOSE_TAG: d++,
        // </a
        CLOSE_TAG_SAW_WHITE: d++,
        // </a   >
        SCRIPT: d++,
        // <script> ...
        SCRIPT_ENDING: d++
        // <script> ... <
      }, t.XML_ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      }, t.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
      }, Object.keys(t.ENTITIES).forEach(function(x) {
        var y = t.ENTITIES[x], F = typeof y == "number" ? String.fromCharCode(y) : y;
        t.ENTITIES[x] = F;
      });
      for (var B in t.STATE)
        t.STATE[t.STATE[B]] = B;
      d = t.STATE;
      function S(x, y, F) {
        x[y] && x[y](F);
      }
      function R(x, y, F) {
        x.textNode && $(x), S(x, y, F);
      }
      function $(x) {
        x.textNode = q(x.opt, x.textNode), x.textNode && S(x, "ontext", x.textNode), x.textNode = "";
      }
      function q(x, y) {
        return x.trim && (y = y.trim()), x.normalize && (y = y.replace(/\s+/g, " ")), y;
      }
      function z(x, y) {
        return $(x), x.trackPosition && (y += `
Line: ` + x.line + `
Column: ` + x.column + `
Char: ` + x.c), y = new Error(y), x.error = y, S(x, "onerror", y), x;
      }
      function k(x) {
        return x.sawRoot && !x.closedRoot && V(x, "Unclosed root tag"), x.state !== d.BEGIN && x.state !== d.BEGIN_WHITESPACE && x.state !== d.TEXT && z(x, "Unexpected end"), $(x), x.c = "", x.closed = !0, S(x, "onend"), n.call(x, x.strict, x.opt), x;
      }
      function V(x, y) {
        if (typeof x != "object" || !(x instanceof n))
          throw new Error("bad call to strictFail");
        x.strict && z(x, y);
      }
      function ft(x) {
        x.strict || (x.tagName = x.tagName[x.looseCase]());
        var y = x.tags[x.tags.length - 1] || x, F = x.tag = { name: x.tagName, attributes: {} };
        x.opt.xmlns && (F.ns = y.ns), x.attribList.length = 0, R(x, "onopentagstart", F);
      }
      function Ot(x, y) {
        var F = x.indexOf(":"), P = F < 0 ? ["", x] : x.split(":"), J = P[0], st = P[1];
        return y && x === "xmlns" && (J = "xmlns", st = ""), { prefix: J, local: st };
      }
      function at(x) {
        if (x.strict || (x.attribName = x.attribName[x.looseCase]()), x.attribList.indexOf(x.attribName) !== -1 || x.tag.attributes.hasOwnProperty(x.attribName)) {
          x.attribName = x.attribValue = "";
          return;
        }
        if (x.opt.xmlns) {
          var y = Ot(x.attribName, !0), F = y.prefix, P = y.local;
          if (F === "xmlns")
            if (P === "xml" && x.attribValue !== w)
              V(
                x,
                "xml: prefix must be bound to " + w + `
Actual: ` + x.attribValue
              );
            else if (P === "xmlns" && x.attribValue !== D)
              V(
                x,
                "xmlns: prefix must be bound to " + D + `
Actual: ` + x.attribValue
              );
            else {
              var J = x.tag, st = x.tags[x.tags.length - 1] || x;
              J.ns === st.ns && (J.ns = Object.create(st.ns)), J.ns[P] = x.attribValue;
            }
          x.attribList.push([x.attribName, x.attribValue]);
        } else
          x.tag.attributes[x.attribName] = x.attribValue, R(x, "onattribute", {
            name: x.attribName,
            value: x.attribValue
          });
        x.attribName = x.attribValue = "";
      }
      function ot(x, y) {
        if (x.opt.xmlns) {
          var F = x.tag, P = Ot(x.tagName);
          F.prefix = P.prefix, F.local = P.local, F.uri = F.ns[P.prefix] || "", F.prefix && !F.uri && (V(
            x,
            "Unbound namespace prefix: " + JSON.stringify(x.tagName)
          ), F.uri = P.prefix);
          var J = x.tags[x.tags.length - 1] || x;
          F.ns && J.ns !== F.ns && Object.keys(F.ns).forEach(function(j) {
            R(x, "onopennamespace", {
              prefix: j,
              uri: F.ns[j]
            });
          });
          for (var st = 0, rt = x.attribList.length; st < rt; st++) {
            var ht = x.attribList[st], A = ht[0], f = ht[1], u = Ot(A, !0), c = u.prefix, h = u.local, N = c === "" ? "" : F.ns[c] || "", L = {
              name: A,
              value: f,
              prefix: c,
              local: h,
              uri: N
            };
            c && c !== "xmlns" && !N && (V(
              x,
              "Unbound namespace prefix: " + JSON.stringify(c)
            ), L.uri = c), x.tag.attributes[A] = L, R(x, "onattribute", L);
          }
          x.attribList.length = 0;
        }
        x.tag.isSelfClosing = !!y, x.sawRoot = !0, x.tags.push(x.tag), R(x, "onopentag", x.tag), y || (!x.noscript && x.tagName.toLowerCase() === "script" ? x.state = d.SCRIPT : x.state = d.TEXT, x.tag = null, x.tagName = ""), x.attribName = x.attribValue = "", x.attribList.length = 0;
      }
      function ut(x) {
        if (!x.tagName) {
          V(x, "Weird empty close tag."), x.textNode += "</>", x.state = d.TEXT;
          return;
        }
        if (x.script) {
          if (x.tagName !== "script") {
            x.script += "</" + x.tagName + ">", x.tagName = "", x.state = d.SCRIPT;
            return;
          }
          R(x, "onscript", x.script), x.script = "";
        }
        var y = x.tags.length, F = x.tagName;
        x.strict || (F = F[x.looseCase]());
        for (var P = F; y--; ) {
          var J = x.tags[y];
          if (J.name !== P)
            V(x, "Unexpected close tag");
          else
            break;
        }
        if (y < 0) {
          V(x, "Unmatched closing tag: " + x.tagName), x.textNode += "</" + x.tagName + ">", x.state = d.TEXT;
          return;
        }
        x.tagName = F;
        for (var st = x.tags.length; st-- > y; ) {
          var rt = x.tag = x.tags.pop();
          x.tagName = x.tag.name, R(x, "onclosetag", x.tagName);
          var ht = {};
          for (var A in rt.ns)
            ht[A] = rt.ns[A];
          var f = x.tags[x.tags.length - 1] || x;
          x.opt.xmlns && rt.ns !== f.ns && Object.keys(rt.ns).forEach(function(u) {
            var c = rt.ns[u];
            R(x, "onclosenamespace", { prefix: u, uri: c });
          });
        }
        y === 0 && (x.closedRoot = !0), x.tagName = x.attribValue = x.attribName = "", x.attribList.length = 0, x.state = d.TEXT;
      }
      function vt(x) {
        var y = x.entity, F = y.toLowerCase(), P, J = "";
        return x.ENTITIES[y] ? x.ENTITIES[y] : x.ENTITIES[F] ? x.ENTITIES[F] : (y = F, y.charAt(0) === "#" && (y.charAt(1) === "x" ? (y = y.slice(2), P = parseInt(y, 16), J = P.toString(16)) : (y = y.slice(1), P = parseInt(y, 10), J = P.toString(10))), y = y.replace(/^0+/, ""), isNaN(P) || J.toLowerCase() !== y || P < 0 || P > 1114111 ? (V(x, "Invalid character entity"), "&" + x.entity + ";") : String.fromCodePoint(P));
      }
      function K(x, y) {
        y === "<" ? (x.state = d.OPEN_WAKA, x.startTagPosition = x.position) : v(y) || (V(x, "Non-whitespace before first tag."), x.textNode = y, x.state = d.TEXT);
      }
      function Bt(x, y) {
        var F = "";
        return y < x.length && (F = x.charAt(y)), F;
      }
      function Q(x) {
        var y = this;
        if (this.error)
          throw this.error;
        if (y.closed)
          return z(
            y,
            "Cannot write after close. Assign an onready handler."
          );
        if (x === null)
          return k(y);
        typeof x == "object" && (x = x.toString());
        for (var F = 0, P = ""; P = Bt(x, F++), y.c = P, !!P; )
          switch (y.trackPosition && (y.position++, P === `
` ? (y.line++, y.column = 0) : y.column++), y.state) {
            case d.BEGIN:
              if (y.state = d.BEGIN_WHITESPACE, P === "\uFEFF")
                continue;
              K(y, P);
              continue;
            case d.BEGIN_WHITESPACE:
              K(y, P);
              continue;
            case d.TEXT:
              if (y.sawRoot && !y.closedRoot) {
                for (var st = F - 1; P && P !== "<" && P !== "&"; )
                  P = Bt(x, F++), P && y.trackPosition && (y.position++, P === `
` ? (y.line++, y.column = 0) : y.column++);
                y.textNode += x.substring(st, F - 1);
              }
              P === "<" && !(y.sawRoot && y.closedRoot && !y.strict) ? (y.state = d.OPEN_WAKA, y.startTagPosition = y.position) : (!v(P) && (!y.sawRoot || y.closedRoot) && V(y, "Text data outside of root node."), P === "&" ? y.state = d.TEXT_ENTITY : y.textNode += P);
              continue;
            case d.SCRIPT:
              P === "<" ? y.state = d.SCRIPT_ENDING : y.script += P;
              continue;
            case d.SCRIPT_ENDING:
              P === "/" ? y.state = d.CLOSE_TAG : (y.script += "<" + P, y.state = d.SCRIPT);
              continue;
            case d.OPEN_WAKA:
              if (P === "!")
                y.state = d.SGML_DECL, y.sgmlDecl = "";
              else if (!v(P)) if (W(I, P))
                y.state = d.OPEN_TAG, y.tagName = P;
              else if (P === "/")
                y.state = d.CLOSE_TAG, y.tagName = "";
              else if (P === "?")
                y.state = d.PROC_INST, y.procInstName = y.procInstBody = "";
              else {
                if (V(y, "Unencoded <"), y.startTagPosition + 1 < y.position) {
                  var J = y.position - y.startTagPosition;
                  P = new Array(J).join(" ") + P;
                }
                y.textNode += "<" + P, y.state = d.TEXT;
              }
              continue;
            case d.SGML_DECL:
              if (y.sgmlDecl + P === "--") {
                y.state = d.COMMENT, y.comment = "", y.sgmlDecl = "";
                continue;
              }
              y.doctype && y.doctype !== !0 && y.sgmlDecl ? (y.state = d.DOCTYPE_DTD, y.doctype += "<!" + y.sgmlDecl + P, y.sgmlDecl = "") : (y.sgmlDecl + P).toUpperCase() === p ? (R(y, "onopencdata"), y.state = d.CDATA, y.sgmlDecl = "", y.cdata = "") : (y.sgmlDecl + P).toUpperCase() === b ? (y.state = d.DOCTYPE, (y.doctype || y.sawRoot) && V(
                y,
                "Inappropriately located doctype declaration"
              ), y.doctype = "", y.sgmlDecl = "") : P === ">" ? (R(y, "onsgmldeclaration", y.sgmlDecl), y.sgmlDecl = "", y.state = d.TEXT) : (M(P) && (y.state = d.SGML_DECL_QUOTED), y.sgmlDecl += P);
              continue;
            case d.SGML_DECL_QUOTED:
              P === y.q && (y.state = d.SGML_DECL, y.q = ""), y.sgmlDecl += P;
              continue;
            case d.DOCTYPE:
              P === ">" ? (y.state = d.TEXT, R(y, "ondoctype", y.doctype), y.doctype = !0) : (y.doctype += P, P === "[" ? y.state = d.DOCTYPE_DTD : M(P) && (y.state = d.DOCTYPE_QUOTED, y.q = P));
              continue;
            case d.DOCTYPE_QUOTED:
              y.doctype += P, P === y.q && (y.q = "", y.state = d.DOCTYPE);
              continue;
            case d.DOCTYPE_DTD:
              P === "]" ? (y.doctype += P, y.state = d.DOCTYPE) : P === "<" ? (y.state = d.OPEN_WAKA, y.startTagPosition = y.position) : M(P) ? (y.doctype += P, y.state = d.DOCTYPE_DTD_QUOTED, y.q = P) : y.doctype += P;
              continue;
            case d.DOCTYPE_DTD_QUOTED:
              y.doctype += P, P === y.q && (y.state = d.DOCTYPE_DTD, y.q = "");
              continue;
            case d.COMMENT:
              P === "-" ? y.state = d.COMMENT_ENDING : y.comment += P;
              continue;
            case d.COMMENT_ENDING:
              P === "-" ? (y.state = d.COMMENT_ENDED, y.comment = q(y.opt, y.comment), y.comment && R(y, "oncomment", y.comment), y.comment = "") : (y.comment += "-" + P, y.state = d.COMMENT);
              continue;
            case d.COMMENT_ENDED:
              P !== ">" ? (V(y, "Malformed comment"), y.comment += "--" + P, y.state = d.COMMENT) : y.doctype && y.doctype !== !0 ? y.state = d.DOCTYPE_DTD : y.state = d.TEXT;
              continue;
            case d.CDATA:
              for (var st = F - 1; P && P !== "]"; )
                P = Bt(x, F++), P && y.trackPosition && (y.position++, P === `
` ? (y.line++, y.column = 0) : y.column++);
              y.cdata += x.substring(st, F - 1), P === "]" && (y.state = d.CDATA_ENDING);
              continue;
            case d.CDATA_ENDING:
              P === "]" ? y.state = d.CDATA_ENDING_2 : (y.cdata += "]" + P, y.state = d.CDATA);
              continue;
            case d.CDATA_ENDING_2:
              P === ">" ? (y.cdata && R(y, "oncdata", y.cdata), R(y, "onclosecdata"), y.cdata = "", y.state = d.TEXT) : P === "]" ? y.cdata += "]" : (y.cdata += "]]" + P, y.state = d.CDATA);
              continue;
            case d.PROC_INST:
              P === "?" ? y.state = d.PROC_INST_ENDING : v(P) ? y.state = d.PROC_INST_BODY : y.procInstName += P;
              continue;
            case d.PROC_INST_BODY:
              if (!y.procInstBody && v(P))
                continue;
              P === "?" ? y.state = d.PROC_INST_ENDING : y.procInstBody += P;
              continue;
            case d.PROC_INST_ENDING:
              P === ">" ? (R(y, "onprocessinginstruction", {
                name: y.procInstName,
                body: y.procInstBody
              }), y.procInstName = y.procInstBody = "", y.state = d.TEXT) : (y.procInstBody += "?" + P, y.state = d.PROC_INST_BODY);
              continue;
            case d.OPEN_TAG:
              W(T, P) ? y.tagName += P : (ft(y), P === ">" ? ot(y) : P === "/" ? y.state = d.OPEN_TAG_SLASH : (v(P) || V(y, "Invalid character in tag name"), y.state = d.ATTRIB));
              continue;
            case d.OPEN_TAG_SLASH:
              P === ">" ? (ot(y, !0), ut(y)) : (V(
                y,
                "Forward-slash in opening tag not followed by >"
              ), y.state = d.ATTRIB);
              continue;
            case d.ATTRIB:
              if (v(P))
                continue;
              P === ">" ? ot(y) : P === "/" ? y.state = d.OPEN_TAG_SLASH : W(I, P) ? (y.attribName = P, y.attribValue = "", y.state = d.ATTRIB_NAME) : V(y, "Invalid attribute name");
              continue;
            case d.ATTRIB_NAME:
              P === "=" ? y.state = d.ATTRIB_VALUE : P === ">" ? (V(y, "Attribute without value"), y.attribValue = y.attribName, at(y), ot(y)) : v(P) ? y.state = d.ATTRIB_NAME_SAW_WHITE : W(T, P) ? y.attribName += P : V(y, "Invalid attribute name");
              continue;
            case d.ATTRIB_NAME_SAW_WHITE:
              if (P === "=")
                y.state = d.ATTRIB_VALUE;
              else {
                if (v(P))
                  continue;
                V(y, "Attribute without value"), y.tag.attributes[y.attribName] = "", y.attribValue = "", R(y, "onattribute", {
                  name: y.attribName,
                  value: ""
                }), y.attribName = "", P === ">" ? ot(y) : W(I, P) ? (y.attribName = P, y.state = d.ATTRIB_NAME) : (V(y, "Invalid attribute name"), y.state = d.ATTRIB);
              }
              continue;
            case d.ATTRIB_VALUE:
              if (v(P))
                continue;
              M(P) ? (y.q = P, y.state = d.ATTRIB_VALUE_QUOTED) : (y.opt.unquotedAttributeValues || z(y, "Unquoted attribute value"), y.state = d.ATTRIB_VALUE_UNQUOTED, y.attribValue = P);
              continue;
            case d.ATTRIB_VALUE_QUOTED:
              if (P !== y.q) {
                P === "&" ? y.state = d.ATTRIB_VALUE_ENTITY_Q : y.attribValue += P;
                continue;
              }
              at(y), y.q = "", y.state = d.ATTRIB_VALUE_CLOSED;
              continue;
            case d.ATTRIB_VALUE_CLOSED:
              v(P) ? y.state = d.ATTRIB : P === ">" ? ot(y) : P === "/" ? y.state = d.OPEN_TAG_SLASH : W(I, P) ? (V(y, "No whitespace between attributes"), y.attribName = P, y.attribValue = "", y.state = d.ATTRIB_NAME) : V(y, "Invalid attribute name");
              continue;
            case d.ATTRIB_VALUE_UNQUOTED:
              if (!X(P)) {
                P === "&" ? y.state = d.ATTRIB_VALUE_ENTITY_U : y.attribValue += P;
                continue;
              }
              at(y), P === ">" ? ot(y) : y.state = d.ATTRIB;
              continue;
            case d.CLOSE_TAG:
              if (y.tagName)
                P === ">" ? ut(y) : W(T, P) ? y.tagName += P : y.script ? (y.script += "</" + y.tagName, y.tagName = "", y.state = d.SCRIPT) : (v(P) || V(y, "Invalid tagname in closing tag"), y.state = d.CLOSE_TAG_SAW_WHITE);
              else {
                if (v(P))
                  continue;
                U(I, P) ? y.script ? (y.script += "</" + P, y.state = d.SCRIPT) : V(y, "Invalid tagname in closing tag.") : y.tagName = P;
              }
              continue;
            case d.CLOSE_TAG_SAW_WHITE:
              if (v(P))
                continue;
              P === ">" ? ut(y) : V(y, "Invalid characters in closing tag");
              continue;
            case d.TEXT_ENTITY:
            case d.ATTRIB_VALUE_ENTITY_Q:
            case d.ATTRIB_VALUE_ENTITY_U:
              var rt, ht;
              switch (y.state) {
                case d.TEXT_ENTITY:
                  rt = d.TEXT, ht = "textNode";
                  break;
                case d.ATTRIB_VALUE_ENTITY_Q:
                  rt = d.ATTRIB_VALUE_QUOTED, ht = "attribValue";
                  break;
                case d.ATTRIB_VALUE_ENTITY_U:
                  rt = d.ATTRIB_VALUE_UNQUOTED, ht = "attribValue";
                  break;
              }
              if (P === ";") {
                var A = vt(y);
                y.opt.unparsedEntities && !Object.values(t.XML_ENTITIES).includes(A) ? (y.entity = "", y.state = rt, y.write(A)) : (y[ht] += A, y.entity = "", y.state = rt);
              } else W(y.entity.length ? g : C, P) ? y.entity += P : (V(y, "Invalid character in entity name"), y[ht] += "&" + y.entity + P, y.entity = "", y.state = rt);
              continue;
            default:
              throw new Error(y, "Unknown state: " + y.state);
          }
        return y.position >= y.bufferCheckPosition && s(y), y;
      }
      /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
      String.fromCodePoint || function() {
        var x = String.fromCharCode, y = Math.floor, F = function() {
          var P = 16384, J = [], st, rt, ht = -1, A = arguments.length;
          if (!A)
            return "";
          for (var f = ""; ++ht < A; ) {
            var u = Number(arguments[ht]);
            if (!isFinite(u) || // `NaN`, `+Infinity`, or `-Infinity`
            u < 0 || // not a valid Unicode code point
            u > 1114111 || // not a valid Unicode code point
            y(u) !== u)
              throw RangeError("Invalid code point: " + u);
            u <= 65535 ? J.push(u) : (u -= 65536, st = (u >> 10) + 55296, rt = u % 1024 + 56320, J.push(st, rt)), (ht + 1 === A || J.length > P) && (f += x.apply(null, J), J.length = 0);
          }
          return f;
        };
        Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
          value: F,
          configurable: !0,
          writable: !0
        }) : String.fromCodePoint = F;
      }();
    })(a);
  }(Un)), Un;
}
var Wn = {}, ji;
function oa() {
  return ji || (ji = 1, function() {
    Wn.stripBOM = function(a) {
      return a[0] === "\uFEFF" ? a.substring(1) : a;
    };
  }.call(it)), Wn;
}
var re = {}, Bi;
function hs() {
  return Bi || (Bi = 1, function() {
    var a;
    a = new RegExp(/(?!xmlns)^.*:/), re.normalize = function(t) {
      return t.toLowerCase();
    }, re.firstCharLowerCase = function(t) {
      return t.charAt(0).toLowerCase() + t.slice(1);
    }, re.stripPrefix = function(t) {
      return t.replace(a, "");
    }, re.parseNumbers = function(t) {
      return isNaN(t) || (t = t % 1 === 0 ? parseInt(t, 10) : parseFloat(t)), t;
    }, re.parseBooleans = function(t) {
      return /^(?:true|false)$/i.test(t) && (t = t.toLowerCase() === "true"), t;
    };
  }.call(it)), re;
}
var Ri;
function aa() {
  return Ri || (Ri = 1, function(a) {
    (function() {
      var t, e, n, s, i, r, o, l, E, m = function(w, D) {
        return function() {
          return w.apply(D, arguments);
        };
      }, p = function(w, D) {
        for (var _ in D)
          b.call(D, _) && (w[_] = D[_]);
        function I() {
          this.constructor = w;
        }
        return I.prototype = D.prototype, w.prototype = new I(), w.__super__ = D.prototype, w;
      }, b = {}.hasOwnProperty;
      l = sa(), s = Kn, t = oa(), o = hs(), E = _s.setImmediate, e = Jn().defaults, i = function(w) {
        return typeof w == "object" && w != null && Object.keys(w).length === 0;
      }, r = function(w, D, _) {
        var I, T, C;
        for (I = 0, T = w.length; I < T; I++)
          C = w[I], D = C(D, _);
        return D;
      }, n = function(w, D, _) {
        var I;
        return I = /* @__PURE__ */ Object.create(null), I.value = _, I.writable = !0, I.enumerable = !0, I.configurable = !0, Object.defineProperty(w, D, I);
      }, a.Parser = function(w) {
        p(D, w);
        function D(_) {
          this.parseStringPromise = m(this.parseStringPromise, this), this.parseString = m(this.parseString, this), this.reset = m(this.reset, this), this.assignOrPush = m(this.assignOrPush, this), this.processAsync = m(this.processAsync, this);
          var I, T, C;
          if (!(this instanceof a.Parser))
            return new a.Parser(_);
          this.options = {}, T = e["0.2"];
          for (I in T)
            b.call(T, I) && (C = T[I], this.options[I] = C);
          for (I in _)
            b.call(_, I) && (C = _[I], this.options[I] = C);
          this.options.xmlns && (this.options.xmlnskey = this.options.attrkey + "ns"), this.options.normalizeTags && (this.options.tagNameProcessors || (this.options.tagNameProcessors = []), this.options.tagNameProcessors.unshift(o.normalize)), this.reset();
        }
        return D.prototype.processAsync = function() {
          var _, I;
          try {
            return this.remaining.length <= this.options.chunkSize ? (_ = this.remaining, this.remaining = "", this.saxParser = this.saxParser.write(_), this.saxParser.close()) : (_ = this.remaining.substr(0, this.options.chunkSize), this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length), this.saxParser = this.saxParser.write(_), E(this.processAsync));
          } catch (T) {
            if (I = T, !this.saxParser.errThrown)
              return this.saxParser.errThrown = !0, this.emit(I);
          }
        }, D.prototype.assignOrPush = function(_, I, T) {
          return I in _ ? (_[I] instanceof Array || n(_, I, [_[I]]), _[I].push(T)) : this.options.explicitArray ? n(_, I, [T]) : n(_, I, T);
        }, D.prototype.reset = function() {
          var _, I, T, C;
          return this.removeAllListeners(), this.saxParser = l.parser(this.options.strict, {
            trim: !1,
            normalize: !1,
            xmlns: this.options.xmlns
          }), this.saxParser.errThrown = !1, this.saxParser.onerror = /* @__PURE__ */ function(g) {
            return function(v) {
              if (g.saxParser.resume(), !g.saxParser.errThrown)
                return g.saxParser.errThrown = !0, g.emit("error", v);
            };
          }(this), this.saxParser.onend = /* @__PURE__ */ function(g) {
            return function() {
              if (!g.saxParser.ended)
                return g.saxParser.ended = !0, g.emit("end", g.resultObject);
            };
          }(this), this.saxParser.ended = !1, this.EXPLICIT_CHARKEY = this.options.explicitCharkey, this.resultObject = null, C = [], _ = this.options.attrkey, I = this.options.charkey, this.saxParser.onopentag = /* @__PURE__ */ function(g) {
            return function(v) {
              var M, X, W, U, d;
              if (W = {}, W[I] = "", !g.options.ignoreAttrs) {
                d = v.attributes;
                for (M in d)
                  b.call(d, M) && (!(_ in W) && !g.options.mergeAttrs && (W[_] = {}), X = g.options.attrValueProcessors ? r(g.options.attrValueProcessors, v.attributes[M], M) : v.attributes[M], U = g.options.attrNameProcessors ? r(g.options.attrNameProcessors, M) : M, g.options.mergeAttrs ? g.assignOrPush(W, U, X) : n(W[_], U, X));
              }
              return W["#name"] = g.options.tagNameProcessors ? r(g.options.tagNameProcessors, v.name) : v.name, g.options.xmlns && (W[g.options.xmlnskey] = {
                uri: v.uri,
                local: v.local
              }), C.push(W);
            };
          }(this), this.saxParser.onclosetag = /* @__PURE__ */ function(g) {
            return function() {
              var v, M, X, W, U, d, B, S, R, $;
              if (d = C.pop(), U = d["#name"], (!g.options.explicitChildren || !g.options.preserveChildrenOrder) && delete d["#name"], d.cdata === !0 && (v = d.cdata, delete d.cdata), R = C[C.length - 1], d[I].match(/^\s*$/) && !v ? (M = d[I], delete d[I]) : (g.options.trim && (d[I] = d[I].trim()), g.options.normalize && (d[I] = d[I].replace(/\s{2,}/g, " ").trim()), d[I] = g.options.valueProcessors ? r(g.options.valueProcessors, d[I], U) : d[I], Object.keys(d).length === 1 && I in d && !g.EXPLICIT_CHARKEY && (d = d[I])), i(d) && (typeof g.options.emptyTag == "function" ? d = g.options.emptyTag() : d = g.options.emptyTag !== "" ? g.options.emptyTag : M), g.options.validator != null && ($ = "/" + function() {
                var q, z, k;
                for (k = [], q = 0, z = C.length; q < z; q++)
                  W = C[q], k.push(W["#name"]);
                return k;
              }().concat(U).join("/"), function() {
                var q;
                try {
                  return d = g.options.validator($, R && R[U], d);
                } catch (z) {
                  return q = z, g.emit("error", q);
                }
              }()), g.options.explicitChildren && !g.options.mergeAttrs && typeof d == "object") {
                if (!g.options.preserveChildrenOrder)
                  W = {}, g.options.attrkey in d && (W[g.options.attrkey] = d[g.options.attrkey], delete d[g.options.attrkey]), !g.options.charsAsChildren && g.options.charkey in d && (W[g.options.charkey] = d[g.options.charkey], delete d[g.options.charkey]), Object.getOwnPropertyNames(d).length > 0 && (W[g.options.childkey] = d), d = W;
                else if (R) {
                  R[g.options.childkey] = R[g.options.childkey] || [], B = {};
                  for (X in d)
                    b.call(d, X) && n(B, X, d[X]);
                  R[g.options.childkey].push(B), delete d["#name"], Object.keys(d).length === 1 && I in d && !g.EXPLICIT_CHARKEY && (d = d[I]);
                }
              }
              return C.length > 0 ? g.assignOrPush(R, U, d) : (g.options.explicitRoot && (S = d, d = {}, n(d, U, S)), g.resultObject = d, g.saxParser.ended = !0, g.emit("end", g.resultObject));
            };
          }(this), T = /* @__PURE__ */ function(g) {
            return function(v) {
              var M, X;
              if (X = C[C.length - 1], X)
                return X[I] += v, g.options.explicitChildren && g.options.preserveChildrenOrder && g.options.charsAsChildren && (g.options.includeWhiteChars || v.replace(/\\n/g, "").trim() !== "") && (X[g.options.childkey] = X[g.options.childkey] || [], M = {
                  "#name": "__text__"
                }, M[I] = v, g.options.normalize && (M[I] = M[I].replace(/\s{2,}/g, " ").trim()), X[g.options.childkey].push(M)), X;
            };
          }(this), this.saxParser.ontext = T, this.saxParser.oncdata = /* @__PURE__ */ function(g) {
            return function(v) {
              var M;
              if (M = T(v), M)
                return M.cdata = !0;
            };
          }();
        }, D.prototype.parseString = function(_, I) {
          var T;
          I != null && typeof I == "function" && (this.on("end", function(C) {
            return this.reset(), I(null, C);
          }), this.on("error", function(C) {
            return this.reset(), I(C);
          }));
          try {
            return _ = _.toString(), _.trim() === "" ? (this.emit("end", null), !0) : (_ = t.stripBOM(_), this.options.async ? (this.remaining = _, E(this.processAsync), this.saxParser) : this.saxParser.write(_).close());
          } catch (C) {
            if (T = C, this.saxParser.errThrown || this.saxParser.ended) {
              if (this.saxParser.ended)
                throw T;
            } else return this.emit("error", T), this.saxParser.errThrown = !0;
          }
        }, D.prototype.parseStringPromise = function(_) {
          return new Promise(/* @__PURE__ */ function(I) {
            return function(T, C) {
              return I.parseString(_, function(g, v) {
                return g ? C(g) : T(v);
              });
            };
          }(this));
        }, D;
      }(s), a.parseString = function(w, D, _) {
        var I, T, C;
        return _ != null ? (typeof _ == "function" && (I = _), typeof D == "object" && (T = D)) : (typeof D == "function" && (I = D), T = {}), C = new a.Parser(T), C.parseString(w, I);
      }, a.parseStringPromise = function(w, D) {
        var _, I;
        return typeof D == "object" && (_ = D), I = new a.Parser(_), I.parseStringPromise(w);
      };
    }).call(it);
  }(Rn)), Rn;
}
var ps;
(function() {
  var a, t, e, n = function(i, r) {
    for (var o in r)
      s.call(r, o) && (i[o] = r[o]);
    function l() {
      this.constructor = i;
    }
    return l.prototype = r.prototype, i.prototype = new l(), i.__super__ = r.prototype, i;
  }, s = {}.hasOwnProperty;
  t = Jn(), a = Zo(), e = aa(), hs(), t.defaults, function(i) {
    n(r, i);
    function r(o) {
      this.message = o;
    }
    return r;
  }(Error), a.Builder, e.Parser, e.parseString, ps = e.parseStringPromise;
}).call(it);
class ua {
  constructor(t, e, n) {
    this.nextTxnId = 1, this.pendingCommands = /* @__PURE__ */ new Map(), this.breakpoints = /* @__PURE__ */ new Map(), this.scriptIdByUrl = /* @__PURE__ */ new Map(), this.nextScriptId = 1, this.objectHandles = /* @__PURE__ */ new Map(), this.nextObjectId = 1, this.callFramesMap = /* @__PURE__ */ new Map(), this.xdebugConnected = !1, this.dbgp = t, this.cdp = e, this.readPHPFile = n.getPHPFile, this.phpRoot = n.phpRoot || "";
    for (const s of n.knownScriptUrls)
      this.scriptIdByUrl.set(s, this.getOrCreateScriptId(s));
    this.breakOnFirstLine = n.breakOnFirstLine || !1;
  }
  start() {
    this.dbgp.on("connected", () => {
      this.xdebugConnected = !0, this.sendDbgpCommand("stdout", "-c 1"), this.sendDbgpCommand("stderr", "-c 1");
    }), this.dbgp.on("message", async (t) => {
      try {
        const e = await ps(t, {
          explicitArray: !1
        });
        await this.handleDbgpMessage(e);
      } catch {
      }
    }), this.dbgp.on("disconnected", () => {
      this.xdebugConnected = !1, this.cdp.sendMessage({
        method: "Debugger.paused",
        params: { reason: "terminated", callFrames: [] }
      });
    }), this.cdp.on("message", (t) => {
      this.handleCdpMessage(t);
    }), this.cdp.on("clientDisconnected", () => {
      this.xdebugConnected && this.sendDbgpCommand("detach");
    }), this.sendInitialScripts().then(() => {
      if (!this.breakOnFirstLine) {
        const t = this.scriptIdByUrl.entries().next().value;
        t && (this.cdp.sendMessage({
          method: "Debugger.paused",
          params: {
            callFrames: [
              {
                location: {
                  scriptId: t[1],
                  lineNumber: 0
                },
                scopeChain: [],
                this: { type: "undefined" }
              }
            ],
            reason: "other"
          }
        }), setTimeout(() => {
          this.cdp.sendMessage({ method: "Debugger.resumed" });
        }, 50));
      }
      this.cdp.sendMessage({
        method: "Log.entryAdded",
        params: {
          entry: {
            source: "other",
            level: "info",
            text: ` Welcome to WordPress Playground DevTools! 
   

1. Add breakpoints in your files to start step debugging.

2. Run your php file, project, plugin or theme using PHP.wasm or Playground CLI.

3. Witness the magic break.`,
            timestamp: Date.now()
          }
        }
      }), this.cdp.sendMessage({
        method: "Log.entryAdded",
        params: {
          entry: {
            source: "other",
            level: "info",
            text: " ",
            timestamp: Date.now()
          }
        }
      });
    });
  }
  stop() {
    this.dbgp.close(), this.cdp.close();
  }
  async sendInitialScripts() {
    for (const [t, e] of this.scriptIdByUrl.entries())
      await this.sendScriptToCDP(t, e);
  }
  async sendScriptToCDP(t, e) {
    const n = this.uriFromBridgeToCDPSyntaxHighlight(t), s = this.uriFromBridgeToCDP(t);
    try {
      const i = await this.readPHPFile(t), r = i.split(`
`), o = r.map((p, b) => b === 0 ? "AAAA" : "AACA").join(";"), l = {
        version: 3,
        // File uri has to match the script parsed url
        // While the sources url has to match the syntax
        // highlighted file displayed in Devtools.
        file: s,
        sources: [n],
        sourcesContent: [i],
        mappings: o
      }, m = `data:application/json;base64,${Buffer.from(
        JSON.stringify(l),
        "utf-8"
      ).toString("base64")}`;
      this.cdp.sendMessage({
        method: "Debugger.scriptParsed",
        params: {
          scriptId: e,
          url: s,
          startLine: 0,
          startColumn: 0,
          endLine: r.length,
          endColumn: 0,
          executionContextId: 1,
          sourceMapURL: m
        }
      });
    } catch (i) {
      this.cdp.sendMessage({
        method: "Log.entryAdded",
        params: {
          entry: {
            source: "other",
            level: "warning",
            text: i.message,
            timestamp: Date.now()
          }
        }
      });
    }
  }
  getOrCreateScriptId(t) {
    let e = this.scriptIdByUrl.get(t);
    return e || (e = vs("sha256").update(String(this.nextScriptId++)).digest("hex").slice(0, 16), this.scriptIdByUrl.set(t, e)), e;
  }
  // Utility: escape and quote Xdebug fullname for property_get
  formatPropertyFullName(t) {
    let e = !1, n = "";
    for (const s of t)
      s === '"' || s === "\\" || s === "\0" ? (n += "\\" + s, e = !0) : s === " " ? (n += s, e = !0) : n += s;
    return (e || t.includes("'")) && (n = `"${n}"`), n;
  }
  sendDbgpCommand(t, e) {
    const s = (this.nextTxnId++).toString();
    let i = `${t} -i ${s}`;
    return e !== void 0 && (i += ` ${e}`), this.dbgp.sendCommand(i), s;
  }
  async handleCdpMessage(t) {
    const { id: e, method: n, params: s } = t;
    let i = {}, r = !0;
    switch (n) {
      case "Debugger.enable":
      case "Runtime.enable":
        i = {};
        break;
      case "Debugger.setBreakpointByUrl": {
        const { url: o, lineNumber: l } = s;
        if (!o) {
          r = !1;
          break;
        }
        const E = this.uriFromCDPToBridge(o), m = this.uriFromBridgeToDBGP(E), p = (typeof l == "number" ? l : 0) + 1, b = String(this.breakpoints.size + 1);
        if (this.xdebugConnected) {
          const w = `breakpoint_set -t line -f ${this.formatPropertyFullName(
            m
          )} -n ${p}`, D = this.sendDbgpCommand(w);
          this.pendingCommands.set(D, {
            cdpId: e,
            cdpMethod: n,
            params: {
              breakpointId: b,
              fileUri: E,
              lineNumber: p
            }
          }), r = !1;
        } else
          this.breakpoints.set(b, {
            cdpId: b,
            xdebugId: null,
            fileUri: E,
            lineNumber: p
          }), i = {
            breakpointId: b,
            locations: [
              {
                scriptId: this.getOrCreateScriptId(E),
                lineNumber: p - 1,
                columnNumber: 0
              }
            ]
          };
        break;
      }
      case "Debugger.removeBreakpoint": {
        const { breakpointId: o } = s, l = String(o), E = this.breakpoints.get(l);
        if (E) {
          if (E.xdebugId && this.xdebugConnected) {
            const m = `breakpoint_remove -d ${E.xdebugId}`, p = this.sendDbgpCommand(m);
            this.pendingCommands.set(p, {
              cdpId: e,
              cdpMethod: n
            }), r = !1;
          }
          this.breakpoints.delete(l);
        }
        i = {};
        break;
      }
      case "Debugger.resume": {
        this.xdebugConnected && this.sendDbgpCommand("run"), i = {};
        break;
      }
      case "Debugger.stepOver": {
        this.xdebugConnected && this.sendDbgpCommand("step_over"), i = {};
        break;
      }
      case "Debugger.stepInto": {
        this.xdebugConnected && this.sendDbgpCommand("step_into"), i = {};
        break;
      }
      case "Debugger.stepOut": {
        this.xdebugConnected && this.sendDbgpCommand("step_out"), i = {};
        break;
      }
      case "Debugger.pause": {
        this.xdebugConnected && this.sendDbgpCommand("break"), i = {};
        break;
      }
      case "Runtime.evaluate":
      case "Debugger.evaluateOnCallFrame": {
        const o = s.expression || "", l = s.callFrameId;
        if (n === "Debugger.evaluateOnCallFrame") {
          if (l === void 0 || !this.callFramesMap.has(l)) {
            this.cdp.sendMessage({
              id: e,
              error: {
                code: -32e3,
                message: "No such call frame"
              }
            });
            return;
          }
          if (this.callFramesMap.get(l) !== 0) {
            this.cdp.sendMessage({
              id: e,
              error: {
                code: -32e3,
                message: "Evaluation in this frame not supported"
              }
            });
            return;
          }
        }
        if (this.xdebugConnected) {
          const E = Buffer.from(o).toString("base64"), m = this.sendDbgpCommand("eval", `-- ${E}`);
          this.pendingCommands.set(m, {
            cdpId: e,
            cdpMethod: n
          }), r = !1;
        } else
          i = {
            result: { type: "undefined", value: void 0 }
          };
        break;
      }
      case "Runtime.getProperties": {
        const { objectId: o } = s, l = this.objectHandles.get(o);
        if (l && this.xdebugConnected)
          if (l.type === "context") {
            const E = l.contextId ?? 0, p = `context_get -d ${l.depth} -c ${E} -p 0 -m 32`, b = this.sendDbgpCommand(p), w = {
              ...l,
              currentPage: 0,
              aggregatedProps: []
            };
            this.objectHandles.set(o, w), this.pendingCommands.set(b, {
              cdpId: e,
              cdpMethod: n,
              params: { objectId: o }
            }), r = !1;
          } else if (l.type === "property") {
            const E = l.depth, m = l.fullname, p = this.formatPropertyFullName(m), b = `property_get -d ${E} -n ${p} -p 0 -m 32`, w = this.sendDbgpCommand(b), D = {
              ...l,
              currentPage: 0,
              aggregatedProps: []
            };
            this.objectHandles.set(o, D), this.pendingCommands.set(w, {
              cdpId: e,
              cdpMethod: n,
              params: { parentObjectId: o }
            }), r = !1;
          } else
            i = { result: [] };
        else
          i = { result: [] };
        break;
      }
      case "Debugger.getScriptSource": {
        const o = s.scriptId, l = [...this.scriptIdByUrl.entries()].find(
          ([, m]) => m === o
        )?.[0], E = [];
        l && E.push(
          `Here's the full path for your convenience:
`,
          `${this.uriFromBridgeToCDPSyntaxHighlight(
            l
          ).replace("file://", "")}
`
        ), i = {
          scriptSource: [
            "`Are you looking for your source code?",
            "Go to PHP.wasm group in the navigator and find it there.",
            ...E,
            "What is this file, then? It's a placeholder required due to the dev tools limitations.",
            "The XDebug <-> Devtools bridge implement PHP syntax highlighting using source maps,",
            'and the unfortunate side effect is having a "source" file and a "target" file.',
            `This is the "source". If you're interested in even more details, see the discussion at:
`,
            "https://github.com/WordPress/wordpress-playground/pull/2566`"
          ].join(`
`)
        };
        break;
      }
      default:
        i = {};
        break;
    }
    r && this.cdp.sendMessage({ id: e, result: i });
  }
  /* ---------- uri mapping ---------- */
  uriFromBridgeToCDPSyntaxHighlight(t) {
    return `file://PHP.wasm/${t}`;
  }
  uriFromBridgeToCDP(t) {
    return t = this.scriptIdByUrl.get(t) ?? "", `file://placeholders/${t}`;
  }
  uriFromCDPToBridge(t) {
    const e = "file://placeholders/";
    return [...this.scriptIdByUrl.entries()].find(
      ([, n]) => n === t.slice(e.length)
    )?.[0] ?? "";
  }
  uriFromBridgeToDBGP(t) {
    return Ui.resolve(process.cwd(), t);
  }
  uriFromDBGPToBridge(t) {
    t = t.startsWith("file://") ? t.slice(7) : t;
    const e = t.indexOf(this.phpRoot);
    return e !== -1 ? t.slice(e) : t;
  }
  async handleDbgpMessage(t) {
    if (t.init) {
      this.breakpoints.forEach((n) => {
        this.handleCdpMessage({
          id: n.cdpId,
          method: "Debugger.setBreakpointByUrl",
          params: {
            url: this.uriFromBridgeToCDP(n.fileUri),
            lineNumber: n.lineNumber - 1
          }
        });
      });
      const e = this.breakOnFirstLine ? this.sendDbgpCommand("step_into") : this.sendDbgpCommand("run");
      this.pendingCommands.set(e, {
        /* auto run after init */
      });
      return;
    }
    if (t.response) {
      const e = t.response, n = e.$, s = n.command, i = n.transaction_id, r = this.pendingCommands.get(i);
      switch (s) {
        case "breakpoint_set": {
          if (r && r.cdpId !== void 0 && r.cdpMethod === "Debugger.setBreakpointByUrl") {
            const o = n.id, l = r.params;
            if (l) {
              const {
                breakpointId: E,
                fileUri: m,
                lineNumber: p
              } = l;
              this.breakpoints.set(E, {
                cdpId: E,
                xdebugId: o,
                fileUri: m,
                lineNumber: p
              });
              const b = this.getOrCreateScriptId(m), w = {
                breakpointId: E,
                locations: [
                  {
                    scriptId: b,
                    lineNumber: p - 1,
                    columnNumber: 0
                  }
                ]
              };
              this.cdp.sendMessage({ id: r.cdpId, result: w });
            }
            this.pendingCommands.delete(i);
          }
          break;
        }
        case "breakpoint_remove": {
          r && r.cdpId !== void 0 && (this.cdp.sendMessage({ id: r.cdpId, result: {} }), this.pendingCommands.delete(i));
          break;
        }
        case "run":
        case "step_into":
        case "step_over":
        case "step_out": {
          const o = n.status;
          if (e["xdebug:message"]) {
            const l = this.uriFromDBGPToBridge(
              e["xdebug:message"].$.filename
            );
            l && !this.scriptIdByUrl.has(l) && await this.sendScriptToCDP(
              l,
              this.getOrCreateScriptId(l)
            );
          }
          if (o === "break") {
            const l = this.sendDbgpCommand("stack_get");
            this.pendingCommands.set(l, {
              /* internal stack get */
            }), this.pendingCommands.delete(i);
          } else (o === "stopping" || o === "stopped") && this.cdp.sendMessage({
            method: "Debugger.resumed",
            params: {}
          });
          break;
        }
        case "eval": {
          if (r && r.cdpId !== void 0) {
            let o;
            if (e.property) {
              const E = e.property, m = E.$.type, p = E.$.encoding;
              let b = null;
              if (Object.prototype.hasOwnProperty.call(
                E,
                "_"
              ) ? b = E._ : typeof E.$value < "u" && (b = E.$value), p === "base64" && b !== null)
                try {
                  b = Buffer.from(b, "base64").toString();
                } catch {
                }
              if (m === "string")
                o = {
                  type: "string",
                  value: b ?? ""
                };
              else if (m === "int" || m === "float" || m === "bool" || m === "boolen" || m === "integer" || m === "double") {
                let w = b;
                m.startsWith("int") || m === "integer" ? w = parseInt(b || "0", 10) : m === "float" || m === "double" ? w = parseFloat(b || "0") : m.startsWith("bool") && (w = b === "1" || b === "true"), o = { type: "number", value: w };
              } else if (m === "array" || m === "object") {
                const w = E.$.classname || (m === "array" ? "Array" : "Object"), D = String(this.nextObjectId++), _ = E.$.fullname || "";
                this.objectHandles.set(D, {
                  type: "property",
                  depth: 0,
                  contextId: 0,
                  fullname: _
                }), o = {
                  type: "object",
                  objectId: D,
                  className: w,
                  description: w
                };
              } else m === "null" ? o = {
                type: "object",
                subtype: "null",
                value: null
              } : o = {
                type: "undefined",
                value: void 0
              };
            } else
              o = {
                type: "undefined",
                value: void 0
              };
            const l = { result: o };
            this.cdp.sendMessage({ id: r.cdpId, result: l }), this.pendingCommands.delete(i);
          }
          break;
        }
        case "context_get":
        case "property_get": {
          if (r && r.cdpId !== void 0) {
            const o = r.params?.objectId || r.params?.parentObjectId, l = o ? this.objectHandles.get(o) : null, E = e.property?.property ?? e.property, m = [];
            if (E) {
              const p = Array.isArray(E) ? E : [E];
              for (const b of p) {
                const w = b.$.name || b.$.fullname || "";
                let D = b.$.type || "undefined";
                const _ = b.$.children === "1", I = b.$.encoding;
                let T = null;
                if (typeof b._ < "u" && (T = b._), I === "base64" && T !== null)
                  try {
                    T = Buffer.from(
                      T,
                      "base64"
                    ).toString();
                  } catch {
                  }
                if (_) {
                  const C = b.$.classname || (D === "array" ? "Array" : "Object"), g = String(
                    this.nextObjectId++
                  ), v = r.cdpMethod === "Runtime.getProperties" && r.params?.parentObjectId && this.objectHandles.get(
                    r.params.parentObjectId
                  )?.contextId || 0, M = r.cdpMethod === "Runtime.getProperties" && r.params?.parentObjectId && this.objectHandles.get(
                    r.params.parentObjectId
                  )?.depth || 0;
                  this.objectHandles.set(g, {
                    type: "property",
                    depth: M,
                    contextId: v,
                    fullname: b.$.fullname || w
                  }), m.push({
                    name: b.$.key || w,
                    value: {
                      type: "object",
                      className: C,
                      description: C,
                      objectId: g
                    },
                    writable: !1,
                    configurable: !1,
                    enumerable: !0
                  });
                } else {
                  let C, g;
                  D === "string" ? C = T ?? "" : D === "int" || D === "integer" ? C = parseInt(T || "0", 10) : D === "float" || D === "double" ? C = parseFloat(T || "0") : D === "bool" || D === "boolean" ? (C = T === "1" || T === "true", D = "boolean") : D === "null" ? (C = null, g = "null") : C = T;
                  const v = {
                    type: D === "integer" ? "number" : D
                  };
                  g && (v.subtype = g), v.value = C, m.push({
                    name: b.$.key || w,
                    value: v,
                    writable: !1,
                    configurable: !1,
                    enumerable: !0
                  });
                }
              }
            }
            if (l) {
              const p = (l.aggregatedProps || []).concat(m), b = 32;
              if (m.length === b) {
                const D = (l.currentPage || 0) + 1, _ = {
                  ...l,
                  currentPage: D,
                  aggregatedProps: p
                };
                this.objectHandles.set(
                  o,
                  _
                );
                let I;
                if (s === "context_get") {
                  const C = l.contextId ?? 0;
                  I = `context_get -d ${l.depth} -c ${C} -p ${D} -m ${b}`;
                } else {
                  const C = l.depth, g = l.fullname, v = this.formatPropertyFullName(g);
                  I = `property_get -d ${C} -n ${v} -p ${D} -m ${b}`;
                }
                const T = this.sendDbgpCommand(I);
                this.pendingCommands.set(T, {
                  cdpId: r.cdpId,
                  cdpMethod: r.cdpMethod,
                  params: r.params
                }), this.pendingCommands.delete(i);
                return;
              } else {
                const D = { result: p };
                this.cdp.sendMessage({
                  id: r.cdpId,
                  result: D
                }), this.pendingCommands.delete(i);
              }
            } else {
              const p = { result: m };
              this.cdp.sendMessage({ id: r.cdpId, result: p }), this.pendingCommands.delete(i);
            }
          }
          break;
        }
        case "stack_get": {
          if (e.stack) {
            const o = Array.isArray(e.stack) ? e.stack : [e.stack], l = [];
            this.callFramesMap.clear();
            for (const m of o) {
              const p = this.uriFromDBGPToBridge(
                m.$.filename
              ), b = this.getOrCreateScriptId(p);
              this.scriptIdByUrl.has(p) || (this.scriptIdByUrl.set(p, b), await this.sendScriptToCDP(p, b));
            }
            for (const m of o) {
              const p = parseInt(m.$.level, 10), b = this.uriFromDBGPToBridge(
                m.$.filename
              ), w = parseInt(m.$.lineno, 10), D = m.$.where && m.$.where !== "{main}" ? m.$.where : "(anonymous)", _ = `frame:${p}`;
              this.callFramesMap.set(_, p);
              const I = [], T = String(this.nextObjectId++);
              this.objectHandles.set(T, {
                type: "context",
                contextId: 0,
                depth: p
              }), I.push({
                type: "local",
                object: {
                  objectId: T,
                  className: "Object",
                  description: "Local"
                }
              });
              const C = String(this.nextObjectId++);
              this.objectHandles.set(C, {
                type: "context",
                contextId: 1,
                depth: p
              }), I.push({
                type: "global",
                object: {
                  objectId: C,
                  className: "Object",
                  description: "Global"
                }
              }), l.push({
                callFrameId: _,
                functionName: D,
                location: {
                  scriptId: this.getOrCreateScriptId(b),
                  lineNumber: w - 1,
                  columnNumber: 0
                },
                scopeChain: I,
                this: {
                  type: "object",
                  className: "Object",
                  description: "Object",
                  objectId: C
                }
              });
            }
            let E = "pause";
            if (o.length > 0) {
              const m = o[0];
              if (m.$.filename && m.$.lineno) {
                const p = this.uriFromDBGPToBridge(
                  m.$.filename
                ), b = parseInt(
                  m.$.lineno,
                  10
                );
                for (const w of this.breakpoints.values())
                  if (w.fileUri === p && w.lineNumber === b) {
                    E = "breakpoint";
                    break;
                  }
              }
            }
            this.cdp.sendMessage({
              method: "Debugger.paused",
              params: {
                reason: E,
                callFrames: l,
                hitBreakpoints: E === "breakpoint" ? [""] : []
              }
            });
          }
          this.pendingCommands.delete(i);
          break;
        }
        default: {
          r && r.cdpId !== void 0 && (this.cdp.sendMessage({ id: r.cdpId, result: {} }), this.pendingCommands.delete(i));
          break;
        }
      }
    } else if (t.stream) {
      const e = t.stream, n = e.$.type, s = e.$.encoding || "none";
      let i = typeof e._ == "string" ? e._ : "";
      s === "base64" && (i = Buffer.from(i, "base64").toString()), this.cdp.sendMessage({
        method: "Log.entryAdded",
        params: {
          entry: {
            source: "other",
            level: n === "stderr" ? "error" : "info",
            text: i,
            timestamp: Date.now(),
            stackTrace: { callFrames: [] }
          }
        }
      });
    } else t.notify;
  }
}
async function ca(a) {
  const t = a.cdpPort ?? 9229, e = a.dbgpPort ?? 9003, n = a.cdpHost ?? "localhost", s = a.phpRoot ?? process.cwd(), i = a.breakOnFirstLine ?? !1;
  Pt.log("Starting XDebug Bridge...");
  const r = new $s(t);
  Pt.log("Connect Chrome DevTools to CDP at:"), Pt.log(
    `devtools://devtools/bundled/inspector.html?ws=${n}:${t}
`
  ), await new Promise((p) => r.on("clientConnected", p)), await new Promise((p) => setTimeout(p, 2e3)), Pt.log("Chrome connected! Initializing Xdebug receiver...");
  const o = new Ws(e);
  Pt.log(`XDebug receiver running on port ${e}`), Pt.log("Running a PHP script with Xdebug enabled...");
  async function l(p) {
    const b = [], w = a.phpInstance ? await a.phpInstance.listFiles(p) : $i(p);
    for (const D of w) {
      const _ = Ui.join(p, D);
      try {
        (a.phpInstance ? await a.phpInstance.isDir(_) : Os(_).isDirectory()) ? b.push(...await l(_)) : D.endsWith(".php") && b.push(_);
      } catch {
      }
    }
    return b;
  }
  const E = a.phpInstance ? (p) => a.phpInstance.readFileAsText(p) : a.getPHPFile ? a.getPHPFile : (p) => Xe(p, "utf-8"), m = await l(s);
  return new ua(o, r, {
    knownScriptUrls: m,
    phpRoot: s,
    getPHPFile: E,
    breakOnFirstLine: i
  });
}
const ds = {
  Quiet: { name: "quiet", severity: xt.Fatal },
  Normal: { name: "normal", severity: xt.Info },
  Debug: { name: "debug", severity: xt.Debug }
};
function la() {
  return Vo(uo(process.argv)).usage(
    `
XDebug Bridge Server CLI

Usage: xdebug-bridge [options]
		`
  ).option("port", {
    alias: "p",
    type: "number",
    description: "Xdebug port to listen on",
    default: 9003
  }).option("host", {
    alias: "h",
    type: "string",
    description: "Xdebug host to bind to",
    default: "localhost"
  }).option("php-root", {
    type: "string",
    description: "Path to PHP root directory"
  }).option("verbosity", {
    type: "string",
    describe: "Output logs",
    choices: Object.values(ds).map(
      (a) => a.name
    ),
    default: "normal"
  }).help().epilog(
    `
Examples:
  xdebug-bridge                                    # Start with default settings
  xdebug-bridge --port 9000 --verbosity debug      # Custom port with debug logs
  xdebug-bridge --php-root /path/to/php/files      # Specify PHP root directory
		`
  ).wrap(null).strict().parseSync();
}
async function Ea() {
  const a = la();
  if (a.help)
    return;
  if (a.verbosity) {
    const e = Object.values(ds).find(
      (n) => n.name === a.verbosity
    ).severity;
    Pt.setSeverityFilterLevel(e);
  }
  (await ca({
    cdpPort: 9229,
    cdpHost: a.host,
    dbgpPort: a.port,
    phpRoot: a.phpRoot
  })).start();
}
export {
  $s as C,
  Ws as D,
  ua as X,
  Ea as m,
  ca as s
};
