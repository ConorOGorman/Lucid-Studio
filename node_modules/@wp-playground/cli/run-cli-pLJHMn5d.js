import { logger as u, LogSeverity as V, errorLogPath as Z } from "@php-wasm/logger";
import { PHPResponse as _, consumeAPI as D, SupportedPHPVersions as he, printDebugDetails as me, exposeAPI as we, exposeSyncAPI as ge } from "@php-wasm/universal";
import { resolveRemoteBlueprint as ye, resolveRuntimeConfiguration as Y, compileBlueprintV1 as be, isBlueprintBundle as Pe, runBlueprintV1Steps as ve } from "@wp-playground/blueprints";
import { zipDirectory as ke, RecommendedPHPVersion as re } from "@wp-playground/common";
import p, { existsSync as se, mkdirSync as G } from "fs";
import { Worker as Q, MessageChannel as xe } from "worker_threads";
import { createNodeFsMountHandler as Se, FileLockManagerForNode as Ie } from "@php-wasm/node";
import w, { basename as R, join as ne } from "path";
import Te from "express";
import ie, { cpus as $e } from "os";
import { jspi as Ee } from "wasm-feature-detect";
import Ce from "yargs";
import { NodeJsFilesystem as We, OverlayFilesystem as Be, InMemoryFilesystem as Le, ZipFilesystem as Me } from "@wp-playground/storage";
import { EmscriptenDownloadMonitor as Re, ProgressTracker as De } from "@php-wasm/progress";
import { resolveWordPressRelease as Fe } from "@wp-playground/wordpress";
import C from "fs-extra";
import { startBridge as Ue } from "@php-wasm/xdebug-bridge";
import { dir as Ae, setGracefulCleanup as He } from "tmp-promise";
import Ve from "ps-man";
import { removeTempDirSymlink as Ne, createTempDirSymlink as _e, clearXdebugIDEConfig as Oe, addXdebugIDEConfig as je } from "@php-wasm/cli-util";
function J(e) {
  const t = [];
  for (const o of e) {
    const n = o.split(":");
    if (n.length !== 2)
      throw new Error(`Invalid mount format: ${o}.
				Expected format: /host/path:/vfs/path.
				If your path contains a colon, e.g. C:\\myplugin, use the --mount-dir option instead.
				Example: --mount-dir C:\\my-plugin /wordpress/wp-content/plugins/my-plugin`);
    const [r, s] = n;
    if (!se(r))
      throw new Error(`Host path does not exist: ${r}`);
    t.push({ hostPath: r, vfsPath: s });
  }
  return t;
}
function K(e) {
  if (e.length % 2 !== 0)
    throw new Error("Invalid mount format. Expected: /host/path /vfs/path");
  const t = [];
  for (let o = 0; o < e.length; o += 2) {
    const n = e[o], r = e[o + 1];
    if (!se(n))
      throw new Error(`Host path does not exist: ${n}`);
    t.push({
      hostPath: w.resolve(process.cwd(), n),
      vfsPath: r
    });
  }
  return t;
}
async function At(e, t) {
  for (const o of t)
    await e.mount(
      o.vfsPath,
      Se(o.hostPath)
    );
}
const ee = {
  step: "runPHP",
  code: {
    filename: "activate-theme.php",
    // @TODO: Remove DOCROOT check after moving totally to Blueprints v2.
    content: `<?php
			$docroot = getenv('DOCROOT') ? getenv('DOCROOT') : '/wordpress';
			require_once "$docroot/wp-load.php";
			$theme = wp_get_theme();
			if (!$theme->exists()) {
				$themes = wp_get_themes();
				if (count($themes) > 0) {
					$themeName = array_keys($themes)[0];
					switch_theme($themeName);
				}
			}
		`
  }
};
function qe(e) {
  const t = e.autoMount, o = [...e.mount || []], n = [...e["mount-before-install"] || []], r = {
    ...e,
    mount: o,
    "mount-before-install": n,
    "additional-blueprint-steps": [
      ...e["additional-blueprint-steps"] || []
    ]
  };
  if (Ye(t)) {
    const s = R(t);
    o.push({
      hostPath: t,
      vfsPath: `/wordpress/wp-content/plugins/${s}`
    }), r["additional-blueprint-steps"].push({
      step: "activatePlugin",
      pluginPath: `/wordpress/wp-content/plugins/${R(t)}`
    });
  } else if (Ze(t)) {
    const s = R(t);
    o.push({
      hostPath: t,
      vfsPath: `/wordpress/wp-content/themes/${s}`
    }), r["additional-blueprint-steps"].push(
      e["experimental-blueprints-v2-runner"] ? {
        step: "activateTheme",
        themeDirectoryName: s
      } : {
        step: "activateTheme",
        themeFolderName: s
      }
    );
  } else if (Xe(t)) {
    const s = p.readdirSync(t);
    for (const a of s)
      a !== "index.php" && o.push({
        hostPath: `${t}/${a}`,
        vfsPath: `/wordpress/wp-content/${a}`
      });
    r["additional-blueprint-steps"].push(ee);
  } else ze(t) ? (n.push({ hostPath: t, vfsPath: "/wordpress" }), r.mode = "apply-to-existing-site", r["additional-blueprint-steps"].push(ee), r.wordpressInstallMode || (r.wordpressInstallMode = "install-from-existing-files-if-needed")) : (o.push({ hostPath: t, vfsPath: "/wordpress" }), r.mode = "mount-only");
  return r;
}
function ze(e) {
  const t = p.readdirSync(e);
  return t.includes("wp-admin") && t.includes("wp-includes") && t.includes("wp-content");
}
function Xe(e) {
  const t = p.readdirSync(e);
  return t.includes("themes") || t.includes("plugins") || t.includes("mu-plugins") || t.includes("uploads");
}
function Ze(e) {
  if (!p.readdirSync(e).includes("style.css"))
    return !1;
  const o = p.readFileSync(ne(e, "style.css"), "utf8");
  return !!/^(?:[ \t]*<\?php)?[ \t/*#@]*Theme Name:(.*)$/im.exec(o);
}
function Ye(e) {
  const t = p.readdirSync(e), o = /^(?:[ \t]*<\?php)?[ \t/*#@]*Plugin Name:(.*)$/im;
  return !!t.filter((r) => r.endsWith(".php")).find((r) => {
    const s = p.readFileSync(ne(e, r), "utf8");
    return !!o.exec(s);
  });
}
async function Ge(e) {
  const t = Te(), o = await new Promise((s, a) => {
    const l = t.listen(e.port, () => {
      const d = l.address();
      d === null || typeof d == "string" ? a(new Error("Server address is not available")) : s(l);
    });
  });
  t.use("/", async (s, a) => {
    let l;
    try {
      l = await e.handleRequest({
        url: s.url,
        headers: Je(s),
        method: s.method,
        body: await Qe(s)
      });
    } catch (d) {
      u.error(d), l = _.forHttpCode(500);
    }
    a.statusCode = l.httpStatusCode;
    for (const d in l.headers)
      a.setHeader(d, l.headers[d]);
    a.end(l.bytes);
  });
  const r = o.address().port;
  return await e.onBind(o, r);
}
const Qe = async (e) => await new Promise((t) => {
  const o = [];
  e.on("data", (n) => {
    o.push(n);
  }), e.on("end", () => {
    t(new Uint8Array(Buffer.concat(o)));
  });
}), Je = (e) => {
  const t = {};
  if (e.rawHeaders && e.rawHeaders.length)
    for (let o = 0; o < e.rawHeaders.length; o += 2)
      t[e.rawHeaders[o].toLowerCase()] = e.rawHeaders[o + 1];
  return t;
};
class Ke {
  constructor(t) {
    this.workerLoads = [], this.addWorker(t);
  }
  addWorker(t) {
    this.workerLoads.push({
      worker: t,
      activeRequests: /* @__PURE__ */ new Set()
    });
  }
  async removeWorker(t) {
    const o = this.workerLoads.findIndex(
      (r) => r.worker === t
    );
    if (o === -1)
      return;
    const [n] = this.workerLoads.splice(o, 1);
    await Promise.allSettled(n.activeRequests);
  }
  async handleRequest(t) {
    let o = this.workerLoads[0];
    for (let r = 1; r < this.workerLoads.length; r++) {
      const s = this.workerLoads[r];
      s.activeRequests.size < o.activeRequests.size && (o = s);
    }
    const n = o.worker.request(t);
    return o.activeRequests.add(n), n.url = t.url, n.finally(() => {
      o.activeRequests.delete(n);
    });
  }
}
function et(e) {
  return /^latest$|^trunk$|^nightly$|^(?:(\d+)\.(\d+)(?:\.(\d+))?)((?:-beta(?:\d+)?)|(?:-RC(?:\d+)?))?$/.test(e);
}
async function tt({
  sourceString: e,
  blueprintMayReadAdjacentFiles: t
}) {
  if (!e)
    return;
  if (e.startsWith("http://") || e.startsWith("https://"))
    return await ye(e);
  let o = w.resolve(process.cwd(), e);
  if (!p.existsSync(o))
    throw new Error(`Blueprint file does not exist: ${o}`);
  const n = p.statSync(o);
  if (n.isDirectory() && (o = w.join(o, "blueprint.json")), !n.isFile() && n.isSymbolicLink())
    throw new Error(
      `Blueprint path is neither a file nor a directory: ${o}`
    );
  const r = w.extname(o);
  switch (r) {
    case ".zip":
      return Me.fromArrayBuffer(
        p.readFileSync(o).buffer
      );
    case ".json": {
      const s = p.readFileSync(o, "utf-8");
      try {
        JSON.parse(s);
      } catch {
        throw new Error(
          `Blueprint file at ${o} is not a valid JSON file`
        );
      }
      const a = w.dirname(o), l = new We(a);
      return new Be([
        new Le({
          "blueprint.json": s
        }),
        /**
         * Wrap the NodeJS filesystem to prevent access to local files
         * unless the user explicitly allowed it.
         */
        {
          read(d) {
            if (!t)
              throw new Error(
                `Error: Blueprint contained tried to read a local file at path "${d}" (via a resource of type "bundled"). Playground restricts access to local resources by default as a security measure. 

You can allow this Blueprint to read files from the same parent directory by explicitly adding the --blueprint-may-read-adjacent-files option to your command.`
              );
            return l.read(d);
          }
        }
      ]);
    }
    default:
      throw new Error(
        `Unsupported blueprint file extension: ${r}. Only .zip and .json files are supported.`
      );
  }
}
function ae(e) {
  return process.env.CI === "true" || process.env.CI === "1" || process.env.GITHUB_ACTIONS === "true" || process.env.GITHUB_ACTIONS === "1" || (process.env.TERM || "").toLowerCase() === "dumb" ? !1 : e ? !!e.isTTY : process.stdout.isTTY;
}
class ot {
  constructor(t, o) {
    this.lastProgressMessage = "", this.args = t, this.siteUrl = o.siteUrl, this.processIdSpaceLength = o.processIdSpaceLength, this.phpVersion = t.php;
  }
  getWorkerType() {
    return "v2";
  }
  async bootAndSetUpInitialPlayground(t, o, n) {
    const r = D(t);
    await r.useFileLockManager(o);
    const s = {
      ...this.args,
      phpVersion: this.phpVersion,
      siteUrl: this.siteUrl,
      firstProcessId: 1,
      processIdSpaceLength: this.processIdSpaceLength,
      trace: this.args.debug || !1,
      blueprint: this.args.blueprint,
      withIntl: this.args.intl,
      // We do not enable Xdebug by default for the initial worker
      // because we do not imagine users expect to hit breakpoints
      // until Playground has fully booted.
      // TODO: Consider supporting Xdebug for the initial worker via a dedicated flag.
      withXdebug: !1,
      xdebug: void 0,
      nativeInternalDirPath: n,
      mountsBeforeWpInstall: this.args["mount-before-install"] || [],
      mountsAfterWpInstall: this.args.mount || []
    };
    return await r.bootAndSetUpInitialWorker(s), r;
  }
  async bootPlayground({
    worker: t,
    fileLockManagerPort: o,
    firstProcessId: n,
    nativeInternalDirPath: r
  }) {
    const s = D(t.phpPort);
    await s.useFileLockManager(o);
    const a = {
      ...this.args,
      phpVersion: this.phpVersion,
      siteUrl: this.siteUrl,
      firstProcessId: n,
      processIdSpaceLength: this.processIdSpaceLength,
      trace: this.args.debug || !1,
      withIntl: this.args.intl,
      withXdebug: !!this.args.xdebug,
      nativeInternalDirPath: r,
      mountsBeforeWpInstall: this.args["mount-before-install"] || [],
      mountsAfterWpInstall: this.args.mount || []
    };
    return await s.bootWorker(a), s;
  }
  writeProgressUpdate(t, o, n) {
    ae(t) && o !== this.lastProgressMessage && (this.lastProgressMessage = o, t.isTTY ? (t.cursorTo(0), t.write(o), t.clearLine(1), n && t.write(`
`)) : t.write(`${o}
`));
  }
}
const O = w.join(ie.homedir(), ".wordpress-playground");
async function rt(e) {
  return await le(
    "https://github.com/WordPress/sqlite-database-integration/archive/refs/heads/develop.zip",
    "sqlite.zip",
    e
  );
}
async function le(e, t, o) {
  const n = w.join(O, t);
  return C.existsSync(n) || (C.ensureDirSync(O), await st(e, n, o)), de(n);
}
async function st(e, t, o) {
  const r = (await o.monitorFetch(fetch(e))).body.getReader(), s = `${t}.partial`, a = C.createWriteStream(s);
  for (; ; ) {
    const { done: l, value: d } = await r.read();
    if (d && a.write(d), l)
      break;
  }
  a.close(), a.closed || await new Promise((l, d) => {
    a.on("finish", () => {
      C.renameSync(s, t), l(null);
    }), a.on("error", (f) => {
      C.removeSync(s), d(f);
    });
  });
}
function de(e, t) {
  return new File([C.readFileSync(e)], R(e));
}
class nt {
  constructor(t, o) {
    this.lastProgressMessage = "", this.args = t, this.siteUrl = o.siteUrl, this.processIdSpaceLength = o.processIdSpaceLength;
  }
  getWorkerType() {
    return "v1";
  }
  async bootAndSetUpInitialPlayground(t, o, n) {
    let r, s, a;
    const l = new Re();
    if (this.args.wordpressInstallMode === "download-and-install") {
      let I = !1;
      l.addEventListener("progress", (q) => {
        if (I)
          return;
        const { loaded: F, total: x } = q.detail, W = Math.floor(
          Math.min(100, 100 * F / x)
        );
        I = W === 100, this.writeProgressUpdate(
          process.stdout,
          `Downloading WordPress ${W}%...`,
          I
        );
      }), r = await Fe(this.args.wp), a = w.join(
        O,
        `prebuilt-wp-content-for-wp-${r.version}.zip`
      ), s = p.existsSync(a) ? de(a) : await le(
        r.releaseUrl,
        `${r.version}.zip`,
        l
      ), u.log(
        `Resolved WordPress release URL: ${r?.releaseUrl}`
      );
    }
    let d;
    this.args.skipSqliteSetup ? (u.log("Skipping SQLite integration plugin setup..."), d = void 0) : (u.log("Fetching SQLite integration plugin..."), d = await rt(l));
    const f = this.args.followSymlinks === !0, i = this.args.experimentalTrace === !0, y = this.args["mount-before-install"] || [], g = this.args.mount || [], P = D(t);
    await P.isConnected(), u.log("Booting WordPress...");
    const k = await Y(
      this.getEffectiveBlueprint()
    );
    return await P.useFileLockManager(o), await P.bootAndSetUpInitialWorker({
      phpVersion: k.phpVersion,
      wpVersion: k.wpVersion,
      siteUrl: this.siteUrl,
      mountsBeforeWpInstall: y,
      mountsAfterWpInstall: g,
      wordpressInstallMode: this.args.wordpressInstallMode || "download-and-install",
      wordPressZip: s && await s.arrayBuffer(),
      sqliteIntegrationPluginZip: await d?.arrayBuffer(),
      firstProcessId: 0,
      processIdSpaceLength: this.processIdSpaceLength,
      followSymlinks: f,
      trace: i,
      internalCookieStore: this.args.internalCookieStore,
      withIntl: this.args.intl,
      // We do not enable Xdebug by default for the initial worker
      // because we do not imagine users expect to hit breakpoints
      // until Playground has fully booted.
      // TODO: Consider supporting Xdebug for the initial worker via a dedicated flag.
      withXdebug: !1,
      nativeInternalDirPath: n
    }), a && !this.args["mount-before-install"] && !p.existsSync(a) && (u.log("Caching preinstalled WordPress for the next boot..."), p.writeFileSync(
      a,
      await ke(P, "/wordpress")
    ), u.log("Cached!")), P;
  }
  async bootPlayground({
    worker: t,
    fileLockManagerPort: o,
    firstProcessId: n,
    nativeInternalDirPath: r
  }) {
    const s = D(
      t.phpPort
    );
    await s.isConnected();
    const a = await Y(
      this.getEffectiveBlueprint()
    );
    return await s.useFileLockManager(o), await s.bootWorker({
      phpVersion: a.phpVersion,
      siteUrl: this.siteUrl,
      mountsBeforeWpInstall: this.args["mount-before-install"] || [],
      mountsAfterWpInstall: this.args.mount || [],
      firstProcessId: n,
      processIdSpaceLength: this.processIdSpaceLength,
      followSymlinks: this.args.followSymlinks === !0,
      trace: this.args.experimentalTrace === !0,
      // @TODO: Move this to the request handler or else every worker
      //        will have a separate cookie store.
      internalCookieStore: this.args.internalCookieStore,
      withIntl: this.args.intl,
      withXdebug: !!this.args.xdebug,
      nativeInternalDirPath: r
    }), await s.isReady(), s;
  }
  async compileInputBlueprint(t) {
    const o = this.getEffectiveBlueprint(), n = new De();
    let r = "", s = !1;
    return n.addEventListener("progress", (a) => {
      if (s)
        return;
      s = a.detail.progress === 100;
      const l = Math.floor(a.detail.progress);
      r = a.detail.caption || r || "Running the Blueprint";
      const d = `${r.trim()} – ${l}%`;
      this.writeProgressUpdate(
        process.stdout,
        d,
        s
      );
    }), await be(o, {
      progress: n,
      additionalSteps: t
    });
  }
  getEffectiveBlueprint() {
    const t = this.args.blueprint;
    return Pe(t) ? t : {
      login: this.args.login,
      ...t || {},
      preferredVersions: {
        php: this.args.php ?? t?.preferredVersions?.php ?? re,
        wp: this.args.wp ?? t?.preferredVersions?.wp ?? "latest",
        ...t?.preferredVersions || {}
      }
    };
  }
  writeProgressUpdate(t, o, n) {
    this.args.verbosity !== j.Quiet.name && ae(t) && o !== this.lastProgressMessage && (this.lastProgressMessage = o, t.isTTY ? (t.cursorTo(0), t.write(o), t.clearLine(1), n && t.write(`
`)) : t.write(`${o}
`));
  }
}
async function it(e, t = !0) {
  const n = `${w.basename(process.argv0)}${e}${process.pid}-`, r = await Ae({
    prefix: n,
    /*
     * Allow recursive cleanup on process exit.
     *
     * NOTE: I worried about whether this cleanup would follow symlinks
     * and delete target files instead of unlinking the symlink,
     * but this feature uses rimraf under the hood which respects symlinks:
     * https://github.com/raszi/node-tmp/blob/3d2fe387f3f91b13830b9182faa02c3231ea8258/lib/tmp.js#L318
     */
    unsafeCleanup: !0
  });
  return t && He(), r;
}
async function at(e, t, o) {
  const r = (await lt(
    e,
    t,
    o
  )).map(
    (s) => new Promise((a) => {
      p.rm(s, { recursive: !0 }, (l) => {
        l ? u.warn(
          `Failed to delete stale Playground temp dir: ${s}`,
          l
        ) : u.info(
          `Deleted stale Playground temp dir: ${s}`
        ), a();
      });
    })
  );
  await Promise.all(r);
}
async function lt(e, t, o) {
  try {
    const n = p.readdirSync(o).map((s) => w.join(o, s)), r = [];
    for (const s of n)
      await dt(
        e,
        t,
        s
      ) && r.push(s);
    return r;
  } catch (n) {
    return u.warn(`Failed to find stale Playground temp dirs: ${n}`), [];
  }
}
async function dt(e, t, o) {
  if (!p.lstatSync(o).isDirectory())
    return !1;
  const r = w.basename(o);
  if (!r.includes(e))
    return !1;
  const s = r.match(
    new RegExp(`^(.+)${e}(\\d+)-`)
  );
  if (!s)
    return !1;
  const a = {
    executableName: s[1],
    pid: s[2]
  };
  if (await ut(a.pid, a.executableName))
    return !1;
  const l = Date.now() - t;
  return p.statSync(o).mtime.getTime() < l;
}
async function ut(e, t) {
  const [o] = await new Promise(
    (n, r) => {
      Ve.list(
        {
          pid: e,
          name: t,
          // Remove path from executable name in the results.
          clean: !0
        },
        (s, a) => {
          s ? r(s) : n(a);
        }
      );
    }
  );
  return !!o && o.pid === e && o.command === t;
}
const j = {
  Quiet: { name: "quiet", severity: V.Fatal },
  Normal: { name: "normal", severity: V.Info },
  Debug: { name: "debug", severity: V.Debug }
};
async function Ht(e) {
  try {
    const t = {
      "site-url": {
        describe: "Site URL to use for WordPress. Defaults to http://127.0.0.1:{port}",
        type: "string"
      },
      php: {
        describe: "PHP version to use.",
        type: "string",
        default: re,
        choices: he
      },
      wp: {
        describe: "WordPress version to use.",
        type: "string",
        default: "latest"
      },
      // @TODO: Support read-only mounts, e.g. via WORKERFS, a custom
      // ReadOnlyNODEFS, or by copying the files into MEMFS
      mount: {
        describe: "Mount a directory to the PHP runtime (can be used multiple times). Format: /host/path:/vfs/path",
        type: "array",
        string: !0,
        coerce: J
      },
      "mount-before-install": {
        describe: "Mount a directory to the PHP runtime before WordPress installation (can be used multiple times). Format: /host/path:/vfs/path",
        type: "array",
        string: !0,
        coerce: J
      },
      "mount-dir": {
        describe: 'Mount a directory to the PHP runtime (can be used multiple times). Format: "/host/path" "/vfs/path"',
        type: "array",
        nargs: 2,
        array: !0,
        coerce: K
      },
      "mount-dir-before-install": {
        describe: 'Mount a directory before WordPress installation (can be used multiple times). Format: "/host/path" "/vfs/path"',
        type: "string",
        nargs: 2,
        array: !0,
        coerce: K
      },
      login: {
        describe: "Should log the user in",
        type: "boolean",
        default: !1
      },
      blueprint: {
        describe: "Blueprint to execute.",
        type: "string"
      },
      "blueprint-may-read-adjacent-files": {
        describe: 'Consent flag: Allow "bundled" resources in a local blueprint to read files in the same directory as the blueprint file.',
        type: "boolean",
        default: !1
      },
      "wordpress-install-mode": {
        describe: "Control how Playground prepares WordPress before booting.",
        type: "string",
        default: "download-and-install",
        choices: [
          "download-and-install",
          "install-from-existing-files",
          "install-from-existing-files-if-needed",
          "do-not-attempt-installing"
        ]
      },
      "skip-wordpress-install": {
        describe: "[Deprecated] Use --wordpress-install-mode instead.",
        type: "boolean",
        hidden: !0
      },
      "skip-sqlite-setup": {
        describe: "Skip the SQLite integration plugin setup to allow the WordPress site to use MySQL.",
        type: "boolean",
        default: !1
      },
      // Hidden - Deprecated in favor of verbosity
      quiet: {
        describe: "Do not output logs and progress messages.",
        type: "boolean",
        default: !1,
        hidden: !0
      },
      verbosity: {
        describe: "Output logs and progress messages.",
        type: "string",
        choices: Object.values(j).map(
          (i) => i.name
        ),
        default: "normal"
      },
      debug: {
        describe: "Print PHP error log content if an error occurs during Playground boot.",
        type: "boolean",
        default: !1
      },
      "auto-mount": {
        describe: "Automatically mount the specified directory. If no path is provided, mount the current working directory. You can mount a WordPress directory, a plugin directory, a theme directory, a wp-content directory, or any directory containing PHP and HTML files.",
        type: "string"
      },
      "follow-symlinks": {
        describe: `Allow Playground to follow symlinks by automatically mounting symlinked directories and files encountered in mounted directories. 
Warning: Following symlinks will expose files outside mounted directories to Playground and could be a security risk.`,
        type: "boolean",
        default: !1
      },
      "experimental-trace": {
        describe: "Print detailed messages about system behavior to the console. Useful for troubleshooting.",
        type: "boolean",
        default: !1,
        // Hide this option because we want to replace with a more general log-level flag.
        hidden: !0
      },
      "internal-cookie-store": {
        describe: "Enable internal cookie handling. When enabled, Playground will manage cookies internally using an HttpCookieStore that persists cookies across requests. When disabled, cookies are handled externally (e.g., by a browser in Node.js environments).",
        type: "boolean",
        default: !1
      },
      intl: {
        describe: "Enable Intl.",
        type: "boolean",
        default: !0
      },
      xdebug: {
        describe: "Enable Xdebug.",
        type: "boolean",
        default: !1
      },
      "experimental-unsafe-ide-integration": {
        describe: "Enable experimental IDE development tools. This option edits IDE config files to set Xdebug path mappings and web server details. CAUTION: If there are bugs, this feature may break your IDE config files. Please consider backing up your IDE configs before using this feature.",
        type: "string",
        // The empty value means the option is enabled for all
        // supported IDEs and, if needed, will create the relevant
        // config file for each.
        choices: ["", "vscode", "phpstorm"],
        coerce: (i) => i === "" ? ["vscode", "phpstorm"] : [i]
      },
      "experimental-blueprints-v2-runner": {
        describe: "Use the experimental Blueprint V2 runner.",
        type: "boolean",
        default: !1,
        // Remove the "hidden" flag once Blueprint V2 is fully supported
        hidden: !0
      },
      mode: {
        describe: "Blueprints v2 runner mode to use. This option is required when using the --experimental-blueprints-v2-runner flag with a blueprint.",
        type: "string",
        choices: ["create-new-site", "apply-to-existing-site"],
        // Remove the "hidden" flag once Blueprint V2 is fully supported
        hidden: !0
      }
    }, o = {
      port: {
        describe: "Port to listen on when serving.",
        type: "number",
        default: 9400
      },
      "experimental-multi-worker": {
        describe: "Enable experimental multi-worker support which requires a /wordpress directory backed by a real filesystem. Pass a positive number to specify the number of workers to use. Otherwise, default to the number of CPUs minus 1.",
        type: "number",
        coerce: (i) => i ?? $e().length - 1
      },
      "experimental-devtools": {
        describe: "Enable experimental browser development tools.",
        type: "boolean"
      }
    }, n = {
      outfile: {
        describe: "When building, write to this output file.",
        type: "string",
        default: "wordpress.zip"
      }
    }, r = Ce(e).usage("Usage: wp-playground <command> [options]").command(
      "server",
      "Start a local WordPress server",
      (i) => i.options({
        ...t,
        ...o
      })
    ).command(
      "run-blueprint",
      "Execute a Blueprint without starting a server",
      (i) => i.options({ ...t })
    ).command(
      "build-snapshot",
      "Build a ZIP snapshot of a WordPress site based on a Blueprint",
      (i) => i.options({
        ...t,
        ...n
      })
    ).demandCommand(1, "Please specify a command").strictCommands().conflicts(
      "experimental-unsafe-ide-integration",
      "experimental-devtools"
    ).showHelpOnFail(!1).fail((i, y, g) => {
      if (y)
        throw y;
      i && i.includes("Please specify a command") && (g.showHelp(), console.error(`
` + i), process.exit(1)), console.error(i), process.exit(1);
    }).strictOptions().check(async (i) => {
      if (i["skip-wordpress-install"] === !0 && (i["wordpress-install-mode"] = "do-not-attempt-installing", i.wordpressInstallMode = "do-not-attempt-installing"), i.wp !== void 0 && typeof i.wp == "string" && !et(i.wp))
        try {
          new URL(i.wp);
        } catch {
          throw new Error(
            'Unrecognized WordPress version. Please use "latest", a URL, or a numeric version such as "6.2", "6.0.1", "6.2-beta1", or "6.2-RC1"'
          );
        }
      const y = i["site-url"];
      if (typeof y == "string" && y.trim() !== "")
        try {
          new URL(y);
        } catch {
          throw new Error(
            `Invalid site-url "${y}". Please provide a valid URL (e.g., http://localhost:8080 or https://example.com)`
          );
        }
      if (i["auto-mount"]) {
        let g = !1;
        try {
          g = p.statSync(
            i["auto-mount"]
          ).isDirectory();
        } catch {
          g = !1;
        }
        if (!g)
          throw new Error(
            `The specified --auto-mount path is not a directory: '${i["auto-mount"]}'.`
          );
      }
      if (i["experimental-multi-worker"] !== void 0) {
        if (i._[0] !== "server")
          throw new Error(
            "The --experimental-multi-worker flag is only supported when running the server command."
          );
        if (i["experimental-multi-worker"] !== void 0 && typeof i["experimental-multi-worker"] == "number" && i["experimental-multi-worker"] <= 1)
          throw new Error(
            "The --experimental-multi-worker flag must be a positive integer greater than 1."
          );
      }
      if (i["experimental-blueprints-v2-runner"] === !0) {
        if (i.mode !== void 0) {
          if (i["wordpress-install-mode"] !== void 0)
            throw new Error(
              "The --wordpress-install-mode option cannot be used with the --mode option. Use one or the other."
            );
          if ("skip-sqlite-setup" in i)
            throw new Error(
              "The --skipSqliteSetup option is not supported in Blueprint V2 mode."
            );
          if (i["auto-mount"] !== void 0)
            throw new Error(
              "The --mode option cannot be used with --auto-mount because --auto-mount automatically sets the mode."
            );
        } else
          i["wordpress-install-mode"] === "do-not-attempt-installing" ? i.mode = "apply-to-existing-site" : i.mode = "create-new-site";
        const g = i.allow || [];
        i.followSymlinks === !0 && g.push("follow-symlinks"), i["blueprint-may-read-adjacent-files"] === !0 && g.push("read-local-fs"), i.allow = g;
      } else if (i.mode !== void 0)
        throw new Error(
          "The --mode option requires the --experimentalBlueprintsV2Runner flag."
        );
      return !0;
    });
    r.wrap(r.terminalWidth());
    const s = await r.argv, a = s._[0];
    ["run-blueprint", "server", "build-snapshot"].includes(a) || (r.showHelp(), process.exit(1));
    const l = {
      ...s,
      command: a,
      mount: [
        ...s.mount || [],
        ...s["mount-dir"] || []
      ],
      "mount-before-install": [
        ...s["mount-before-install"] || [],
        ...s["mount-dir-before-install"] || []
      ]
    }, d = await ft(l);
    d === void 0 && process.exit(0);
    const f = /* @__PURE__ */ (() => {
      let i;
      return async () => {
        i !== void 0 && (i = d[Symbol.asyncDispose]()), await i, process.exit(0);
      };
    })();
    process.on("SIGINT", f), process.on("SIGTERM", f);
  } catch (t) {
    if (!(t instanceof Error))
      throw t;
    if (process.argv.includes("--debug"))
      me(t);
    else {
      const n = [];
      let r = t;
      do
        n.push(r.message), r = r.cause;
      while (r instanceof Error);
      console.error(
        "\x1B[1m" + n.join(" caused by: ") + "\x1B[0m"
      );
    }
    process.exit(1);
  }
}
const ct = Symbol("playground-cli-testing"), E = (e) => process.stdout.isTTY ? "\x1B[1m" + e + "\x1B[0m" : e, pt = (e) => process.stdout.isTTY ? `\x1B[2m${e}\x1B[0m` : e, N = (e) => process.stdout.isTTY ? `\x1B[3m${e}\x1B[0m` : e, te = (e) => process.stdout.isTTY ? `\x1B[33m${e}\x1B[0m` : e;
async function ft(e) {
  let t, o;
  const n = /* @__PURE__ */ new Map();
  if (e.autoMount !== void 0 && (e.autoMount === "" && (e = { ...e, autoMount: process.cwd() }), e = qe(e)), e.wordpressInstallMode === void 0 && (e.wordpressInstallMode = "download-and-install"), e.quiet && (e.verbosity = "quiet", delete e.quiet), e.debug ? e.verbosity = "debug" : e.verbosity === "debug" && (e.debug = !0), e.verbosity) {
    const f = Object.values(j).find(
      (i) => i.name === e.verbosity
    ).severity;
    u.setSeverityFilterLevel(f);
  }
  e.intl || (e.intl = !0);
  const r = e.command === "server" ? e.port ?? 9400 : 0, s = ie.platform() === "win32" ? (
    // @TODO: Enable fs-ext here when it works with Windows.
    void 0
  ) : await import("fs-ext").then((f) => f.flockSync).catch(() => {
    u.warn(
      "The fs-ext package is not installed. Internal file locking will not be integrated with host OS file locking."
    );
  }), a = new Ie(s);
  let l = !1, d = !0;
  return u.log("Starting a PHP server..."), Ge({
    port: r,
    onBind: async (f, i) => {
      const y = "127.0.0.1", g = `http://${y}:${i}`, P = e["site-url"] || g, k = e.command === "server" ? e.experimentalMultiWorker ?? 1 : 1, I = e.command === "server" ? (
        // Account for the initial worker which is discarded by the server after setup.
        k + 1
      ) : k, F = 2 ** 31 - 1, x = Math.floor(
        F / I
      ), W = "-playground-cli-site-", T = await it(W);
      u.debug(`Native temp dir for VFS root: ${T.path}`);
      const B = "WP Playground CLI - Listen for Xdebug", z = ".playground-xdebug-root", X = w.join(process.cwd(), z);
      if (await Ne(X), e.xdebug && e.experimentalUnsafeIdeIntegration) {
        await _e(
          T.path,
          X,
          process.platform
        );
        const c = {
          hostPath: w.join(".", w.sep, z),
          vfsPath: "/"
        };
        try {
          await Oe(B, process.cwd());
          const m = typeof e.xdebug == "object" ? e.xdebug : void 0, v = await je({
            name: B,
            host: y,
            port: i,
            ides: e.experimentalUnsafeIdeIntegration,
            cwd: process.cwd(),
            mounts: [
              c,
              ...e["mount-before-install"] || [],
              ...e.mount || []
            ],
            ideKey: m?.ideKey
          }), h = e.experimentalUnsafeIdeIntegration, b = h.includes("vscode"), S = h.includes("phpstorm"), M = Object.values(v);
          console.log(""), M.length > 0 ? (console.log(E("Xdebug configured successfully")), console.log(
            te("Updated IDE config: ") + M.join(" ")
          ), console.log(
            te("Playground source root: ") + ".playground-xdebug-root" + N(
              pt(
                " – you can set breakpoints and preview Playground's VFS structure in there."
              )
            )
          )) : (console.log(E("Xdebug configuration failed.")), console.log(
            "No IDE-specific project settings directory was found in the current working directory."
          )), console.log(""), b && v.vscode && (console.log(E("VS Code / Cursor instructions:")), console.log(
            "  1. Ensure you have installed an IDE extension for PHP Debugging"
          ), console.log(
            `     (The ${E("PHP Debug")} extension by ${E(
              "Xdebug"
            )} has been a solid option)`
          ), console.log(
            "  2. Open the Run and Debug panel on the left sidebar"
          ), console.log(
            `  3. Select "${N(
              B
            )}" from the dropdown`
          ), console.log('  3. Click "start debugging"'), console.log(
            "  5. Set a breakpoint. For example, in .playground-xdebug-root/wordpress/index.php"
          ), console.log(
            "  6. Visit Playground in your browser to hit the breakpoint"
          ), S && console.log("")), S && v.phpstorm && (console.log(E("PhpStorm instructions:")), console.log(
            `  1. Choose "${N(
              B
            )}" debug configuration in the toolbar`
          ), console.log("  2. Click the debug button (bug icon)`"), console.log(
            "  3. Set a breakpoint. For example, in .playground-xdebug-root/wordpress/index.php"
          ), console.log(
            "  4. Visit Playground in your browser to hit the breakpoint"
          )), console.log("");
        } catch (m) {
          throw new Error("Could not configure Xdebug", {
            cause: m
          });
        }
      }
      const ue = w.dirname(T.path), ce = 2 * 24 * 60 * 60 * 1e3;
      at(
        W,
        ce,
        ue
      );
      const U = w.join(T.path, "internal");
      G(U);
      const pe = [
        "wordpress",
        // Note: These dirs are from Emscripten's "default dirs" list:
        // https://github.com/emscripten-core/emscripten/blob/f431ec220e472e1f8d3db6b52fe23fb377facf30/src/lib/libfs.js#L1400-L1402
        //
        // Any Playground process with multiple workers may assume
        // these are part of a shared filesystem, so let's recognize
        // them explicitly here.
        "tmp",
        "home"
      ];
      for (const c of pe) {
        const m = (h) => h.vfsPath === `/${c}`;
        if (!(e["mount-before-install"]?.some(m) || e.mount?.some(m))) {
          const h = w.join(
            T.path,
            c
          );
          G(h), e["mount-before-install"] === void 0 && (e["mount-before-install"] = []), e["mount-before-install"].unshift({
            vfsPath: `/${c}`,
            hostPath: h
          });
        }
      }
      if (e["mount-before-install"])
        for (const c of e["mount-before-install"])
          u.debug(
            `Mount before WP install: ${c.vfsPath} -> ${c.hostPath}`
          );
      if (e.mount)
        for (const c of e.mount)
          u.debug(
            `Mount after WP install: ${c.vfsPath} -> ${c.hostPath}`
          );
      let $;
      e["experimental-blueprints-v2-runner"] ? $ = new ot(e, {
        siteUrl: P,
        processIdSpaceLength: x
      }) : ($ = new nt(e, {
        siteUrl: P,
        processIdSpaceLength: x
      }), typeof e.blueprint == "string" && (e.blueprint = await tt({
        sourceString: e.blueprint,
        blueprintMayReadAdjacentFiles: e["blueprint-may-read-adjacent-files"] === !0
      })));
      let A = !1;
      const L = async function() {
        A || (A = !0, await Promise.all(
          [...n].map(
            async ([m, v]) => {
              await v.dispose(), await m.terminate();
            }
          )
        ), f && await new Promise((m) => f.close(m)), await T.cleanup());
      }, fe = ht(
        I,
        $.getWorkerType(),
        ({ exitCode: c, workerIndex: m }) => {
          A || c === 0 && u.error(
            `Worker ${m} exited with code ${c}
`
          );
        }
      );
      u.log("Starting up workers");
      try {
        const c = await fe, m = await oe(a);
        {
          const h = c.shift(), b = await $.bootAndSetUpInitialPlayground(
            h.phpPort,
            m,
            U
          );
          if (n.set(
            h.worker,
            b
          ), await b.isReady(), l = !0, u.log("Booted!"), t = new Ke(b), !e["experimental-blueprints-v2-runner"]) {
            const S = await $.compileInputBlueprint(
              e["additional-blueprint-steps"] || []
            );
            S && (u.log("Running the Blueprint..."), await ve(
              S,
              b
            ), u.log("Finished running the blueprint"));
          }
          if (e.command === "build-snapshot") {
            await wt(o, e.outfile), u.log(`WordPress exported to ${e.outfile}`), await L();
            return;
          } else if (e.command === "run-blueprint") {
            u.log("Blueprint executed"), await L();
            return;
          }
          await t.removeWorker(b), await b.dispose(), await h.worker.terminate(), n.delete(h.worker);
        }
        u.log("Preparing workers...");
        const v = x;
        return [o] = await Promise.all(
          c.map(async (h, b) => {
            const S = v + b * x, M = await oe(a), H = await $.bootPlayground({
              worker: h,
              fileLockManagerPort: M,
              firstProcessId: S,
              nativeInternalDirPath: U
            });
            return n.set(
              h.worker,
              H
            ), t.addWorker(H), H;
          })
        ), u.log(
          `WordPress is running on ${g} with ${k} worker(s)`
        ), e.xdebug && e.experimentalDevtools && (await Ue({
          phpInstance: o,
          phpRoot: "/wordpress"
        })).start(), {
          playground: o,
          server: f,
          serverUrl: g,
          [Symbol.asyncDispose]: L,
          [ct]: {
            workerThreadCount: k,
            getWorkerNumberFromProcessId: (h) => Math.floor(h / x)
          }
        };
      } catch (c) {
        if (!e.debug)
          throw c;
        let m = "";
        throw await o?.fileExists(Z) && (m = await o.readFileAsText(Z)), await L(), new Error(m, { cause: c });
      }
    },
    async handleRequest(f) {
      if (!l)
        return _.forHttpCode(
          502,
          "WordPress is not ready yet"
        );
      if (d) {
        d = !1;
        const i = {
          "Content-Type": ["text/plain"],
          "Content-Length": ["0"],
          Location: [f.url]
        };
        return f.headers?.cookie?.includes(
          "playground_auto_login_already_happened"
        ) && (i["Set-Cookie"] = [
          "playground_auto_login_already_happened=1; Max-Age=0; Expires=Thu, 01 Jan 1970 00:00:00 GMT; Path=/"
        ]), new _(302, i, new Uint8Array());
      }
      return await t.handleRequest(f);
    }
  });
}
async function ht(e, t, o) {
  const n = [];
  for (let r = 0; r < e; r++) {
    const a = mt(t, { onExit: (l) => {
      o({
        exitCode: l,
        workerIndex: r
      });
    } });
    n.push(a);
  }
  return Promise.all(n);
}
function mt(e, { onExit: t } = {}) {
  let o;
  return e === "v1" ? o = new Q(new URL("./worker-thread-v1.js", import.meta.url)) : o = new Q(new URL("./worker-thread-v2.js", import.meta.url)), new Promise((n, r) => {
    o.once("message", function(a) {
      a.command === "worker-script-initialized" && n({ worker: o, phpPort: a.phpPort });
    }), o.once("error", function(a) {
      console.error(a);
      const l = new Error(
        `Worker failed to load worker. ${a.message ? `Original error: ${a.message}` : ""}`
      );
      r(l);
    });
    let s = !1;
    o.once("spawn", () => {
      s = !0;
    }), o.once("exit", (a) => {
      s || r(new Error(`Worker exited before spawning: ${a}`)), t?.(a);
    });
  });
}
async function oe(e) {
  const { port1: t, port2: o } = new xe();
  return await Ee() ? we(e, null, t) : await ge(e, t), o;
}
async function wt(e, t) {
  await e.run({
    code: `<?php
		$zip = new ZipArchive();
		if(false === $zip->open('/tmp/build.zip', ZipArchive::CREATE | ZipArchive::OVERWRITE)) {
			throw new Exception('Failed to create ZIP');
		}
		$files = new RecursiveIteratorIterator(
			new RecursiveDirectoryIterator('/wordpress')
		);
		foreach ($files as $file) {
			echo $file . PHP_EOL;
			if (!$file->isFile()) {
				continue;
			}
			$zip->addFile($file->getPathname(), $file->getPathname());
		}
		$zip->close();

	`
  });
  const o = await e.readFileAsBuffer("/tmp/build.zip");
  p.writeFileSync(t, o);
}
export {
  j as L,
  ae as a,
  ct as i,
  At as m,
  Ht as p,
  ft as r,
  mt as s
};
//# sourceMappingURL=run-cli-pLJHMn5d.js.map
