import { loadNodeRuntime as H } from "@php-wasm/node";
import { EmscriptenDownloadMonitor as W } from "@php-wasm/progress";
import { exposeAPI as S, PHPWorker as R, consumeAPI as g, consumeAPISync as _, sandboxedSpawnHandlerFactory as P } from "@php-wasm/universal";
import { sprintf as q } from "@php-wasm/util";
import { RecommendedPHPVersion as M } from "@wp-playground/common";
import { bootWordPressAndRequestHandler as v, bootRequestHandler as L } from "@wp-playground/wordpress";
import { rootCertificates as A } from "tls";
import { jspi as D } from "wasm-feature-detect";
import { MessageChannel as E, parentPort as F } from "worker_threads";
import { m as n, s as U } from "./run-cli-pLJHMn5d.js";
import { logger as B } from "@php-wasm/logger";
function C(t, e, ...r) {
  console.log(
    performance.now().toFixed(6).padStart(15, "0"),
    t.toString().padStart(16, "0"),
    q(e, ...r)
  );
}
class x extends R {
  constructor(e) {
    super(void 0, e), this.booted = !1;
  }
  /**
   * Call this method before boot() to use file locking.
   *
   * This method is separate from boot() to simplify the related Comlink.transferHandlers
   * setup â€“ if an argument is a MessagePort, we're transferring it, not copying it.
   *
   * @see comlink-sync.ts
   * @see phpwasm-emscripten-library-file-locking-for-node.js
   */
  async useFileLockManager(e) {
    await D() ? this.fileLockManager = g(e) : this.fileLockManager = await _(e);
  }
  async bootAndSetUpInitialWorker(e) {
    const {
      siteUrl: r,
      mountsBeforeWpInstall: a,
      mountsAfterWpInstall: o,
      wordpressInstallMode: I,
      wordPressZip: l,
      sqliteIntegrationPluginZip: c,
      dataSqlPath: k,
      internalCookieStore: b
    } = e;
    if (this.booted)
      throw new Error("Playground already booted");
    this.booted = !0;
    try {
      const s = {
        WP_DEBUG: !0,
        WP_DEBUG_LOG: !0,
        WP_DEBUG_DISPLAY: !1
      };
      let d = !1;
      const p = await v({
        siteUrl: r,
        createPhpRuntime: u(
          e,
          this.fileLockManager
        ),
        wordpressInstallMode: I,
        wordPressZip: l !== void 0 ? new File([l], "wordpress.zip") : void 0,
        sqliteIntegrationPluginZip: c !== void 0 ? new File(
          [c],
          "sqlite-integration-plugin.zip"
        ) : void 0,
        sapiName: "cli",
        createFiles: {
          "/internal/shared/ca-bundle.crt": A.join(`
`)
        },
        constants: s,
        phpIniEntries: {
          "openssl.cafile": "/internal/shared/ca-bundle.crt",
          allow_url_fopen: "1",
          disable_functions: ""
        },
        cookieStore: b ? void 0 : !1,
        dataSqlPath: k,
        spawnHandler: () => P(
          () => w(e, this.fileLockManager)
        ),
        async onPHPInstanceCreated(m) {
          await n(m, a), d && await n(m, o);
        }
      });
      this.__internal_setRequestHandler(p), d = !0;
      const h = await p.getPrimaryPhp();
      await this.setPrimaryPHP(h), await n(h, o), f();
    } catch (s) {
      throw y(s), s;
    }
  }
  async hello() {
    return "hello";
  }
  async bootWorker(e) {
    await this.bootRequestHandler(e);
  }
  async bootRequestHandler(e) {
    if (this.booted)
      throw new Error("Playground already booted");
    this.booted = !0;
    try {
      const r = await L({
        siteUrl: e.siteUrl,
        createPhpRuntime: u(
          e,
          this.fileLockManager
        ),
        onPHPInstanceCreated: async (o) => {
          await n(o, e.mountsBeforeWpInstall), await n(o, e.mountsAfterWpInstall);
        },
        sapiName: "cli",
        cookieStore: !1,
        spawnHandler: () => P(
          () => w(e, this.fileLockManager)
        )
      });
      this.__internal_setRequestHandler(r);
      const a = await r.getPrimaryPhp();
      await this.setPrimaryPHP(a), f();
    } catch (r) {
      throw y(r), r;
    }
  }
  // Provide a named disposal method that can be invoked via comlink.
  async dispose() {
    await this[Symbol.asyncDispose]();
  }
}
function u(t, e) {
  let r = t.firstProcessId;
  const a = t.firstProcessId + t.processIdSpaceLength - 1;
  return async () => {
    const o = r;
    return r < a ? r++ : r = t.firstProcessId, await H(
      t.phpVersion || M,
      {
        emscriptenOptions: {
          fileLockManager: e,
          processId: o,
          trace: t.trace ? C : void 0,
          phpWasmInitOptions: {
            nativeInternalDirPath: t.nativeInternalDirPath
          }
        },
        followSymlinks: t.followSymlinks,
        withIntl: t.withIntl,
        withXdebug: t.withXdebug
      }
    );
  };
}
async function w(t, e) {
  const r = await U("v1"), a = g(
    r.phpPort
  );
  return a.useFileLockManager(e), await a.bootWorker(t), {
    php: a,
    reap: () => {
      try {
        a.dispose();
      } catch {
      }
      try {
        r.worker.terminate();
      } catch {
      }
    }
  };
}
process.on("unhandledRejection", (t) => {
  B.error("Unhandled rejection:", t);
});
const i = new E(), [f, y] = S(
  new x(new W()),
  void 0,
  i.port1
);
F?.postMessage(
  {
    command: "worker-script-initialized",
    phpPort: i.port2
  },
  [i.port2]
);
export {
  x as PlaygroundCliBlueprintV1Worker
};
//# sourceMappingURL=worker-thread-v1.js.map
