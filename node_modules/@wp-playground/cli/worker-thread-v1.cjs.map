{"version":3,"file":"worker-thread-v1.cjs","sources":["../../../../packages/playground/cli/src/blueprints-v1/worker-thread-v1.ts"],"sourcesContent":["import type { FileLockManager } from '@php-wasm/node';\nimport { loadNodeRuntime } from '@php-wasm/node';\nimport { EmscriptenDownloadMonitor } from '@php-wasm/progress';\nimport type { RemoteAPI, SupportedPHPVersion } from '@php-wasm/universal';\nimport {\n\tPHPWorker,\n\tconsumeAPI,\n\tconsumeAPISync,\n\texposeAPI,\n\tsandboxedSpawnHandlerFactory,\n} from '@php-wasm/universal';\nimport { sprintf } from '@php-wasm/util';\nimport { RecommendedPHPVersion } from '@wp-playground/common';\nimport {\n\ttype WordPressInstallMode,\n\tbootRequestHandler,\n\tbootWordPressAndRequestHandler,\n} from '@wp-playground/wordpress';\nimport { rootCertificates } from 'tls';\nimport { jspi } from 'wasm-feature-detect';\nimport { MessageChannel, type MessagePort, parentPort } from 'worker_threads';\nimport { mountResources } from '../mounts';\nimport { logger } from '@php-wasm/logger';\nimport { spawnWorkerThread } from '../run-cli';\n\nimport type { Mount } from '@php-wasm/cli-util';\n\nexport type WorkerBootOptions = {\n\tphpVersion: SupportedPHPVersion;\n\tsiteUrl: string;\n\tmountsBeforeWpInstall: Array<Mount>;\n\tmountsAfterWpInstall: Array<Mount>;\n\tfirstProcessId: number;\n\tprocessIdSpaceLength: number;\n\tfollowSymlinks: boolean;\n\ttrace: boolean;\n\t/**\n\t * When true, Playground will not send cookies to the client but will manage\n\t * them internally. This can be useful in environments that can't store cookies,\n\t * e.g. VS Code WebView.\n\t *\n\t * Default: false.\n\t */\n\tinternalCookieStore?: boolean;\n\twithIntl?: boolean;\n\twithXdebug?: boolean;\n\tnativeInternalDirPath: string;\n};\n\nexport type PrimaryWorkerBootOptions = WorkerBootOptions & {\n\twordpressInstallMode: WordPressInstallMode;\n\twpVersion?: string;\n\twordPressZip?: ArrayBuffer;\n\tsqliteIntegrationPluginZip?: ArrayBuffer;\n\tdataSqlPath?: string;\n};\n\ninterface WorkerBootRequestHandlerOptions {\n\tsiteUrl: string;\n\tfollowSymlinks: boolean;\n\tphpVersion: SupportedPHPVersion;\n\tfirstProcessId: number;\n\tprocessIdSpaceLength: number;\n\ttrace: boolean;\n\tnativeInternalDirPath: string;\n\tmountsBeforeWpInstall: Array<Mount>;\n\tmountsAfterWpInstall: Array<Mount>;\n\twithIntl?: boolean;\n\twithXdebug?: boolean;\n}\n\n/**\n * Print trace messages from PHP-WASM.\n *\n * @param {number} processId - The process ID.\n * @param {string} format - The format string.\n * @param {...any} args - The arguments.\n */\nfunction tracePhpWasm(processId: number, format: string, ...args: any[]) {\n\t// eslint-disable-next-line no-console\n\tconsole.log(\n\t\tperformance.now().toFixed(6).padStart(15, '0'),\n\t\tprocessId.toString().padStart(16, '0'),\n\t\tsprintf(format, ...args)\n\t);\n}\n\nexport class PlaygroundCliBlueprintV1Worker extends PHPWorker {\n\tbooted = false;\n\tfileLockManager: RemoteAPI<FileLockManager> | FileLockManager | undefined;\n\n\tconstructor(monitor: EmscriptenDownloadMonitor) {\n\t\tsuper(undefined, monitor);\n\t}\n\n\t/**\n\t * Call this method before boot() to use file locking.\n\t *\n\t * This method is separate from boot() to simplify the related Comlink.transferHandlers\n\t * setup â€“ if an argument is a MessagePort, we're transferring it, not copying it.\n\t *\n\t * @see comlink-sync.ts\n\t * @see phpwasm-emscripten-library-file-locking-for-node.js\n\t */\n\tasync useFileLockManager(port: MessagePort) {\n\t\tif (await jspi()) {\n\t\t\t/**\n\t\t\t * If JSPI is available, php.js supports both synchronous and asynchronous locking syscalls.\n\t\t\t * Web browsers, however, only support asynchronous message passing so let's use the\n\t\t\t * asynchronous API. Every method call will return a promise.\n\t\t\t *\n\t\t\t * @see comlink-sync.ts\n\t\t\t * @see phpwasm-emscripten-library-file-locking-for-node.js\n\t\t\t */\n\t\t\tthis.fileLockManager = consumeAPI<FileLockManager>(port);\n\t\t} else {\n\t\t\t/**\n\t\t\t * If JSPI is not available, php.js only supports synchronous locking syscalls.\n\t\t\t * Let's use the synchronous API. Every method call will block this thread\n\t\t\t * until the result is available.\n\t\t\t *\n\t\t\t * @see comlink-sync.ts\n\t\t\t * @see phpwasm-emscripten-library-file-locking-for-node.js\n\t\t\t */\n\t\t\tthis.fileLockManager = await consumeAPISync<FileLockManager>(port);\n\t\t}\n\t}\n\n\tasync bootAndSetUpInitialWorker(options: PrimaryWorkerBootOptions) {\n\t\tconst {\n\t\t\tsiteUrl,\n\t\t\tmountsBeforeWpInstall,\n\t\t\tmountsAfterWpInstall,\n\t\t\twordpressInstallMode,\n\t\t\twordPressZip,\n\t\t\tsqliteIntegrationPluginZip,\n\t\t\tdataSqlPath,\n\t\t\tinternalCookieStore,\n\t\t} = options;\n\t\tif (this.booted) {\n\t\t\tthrow new Error('Playground already booted');\n\t\t}\n\t\tthis.booted = true;\n\n\t\ttry {\n\t\t\tconst constants: Record<string, string | number | boolean | null> =\n\t\t\t\t{\n\t\t\t\t\tWP_DEBUG: true,\n\t\t\t\t\tWP_DEBUG_LOG: true,\n\t\t\t\t\tWP_DEBUG_DISPLAY: false,\n\t\t\t\t};\n\t\t\tlet wordpressBooted = false;\n\t\t\tconst requestHandler = await bootWordPressAndRequestHandler({\n\t\t\t\tsiteUrl,\n\t\t\t\tcreatePhpRuntime: createPhpRuntimeFactory(\n\t\t\t\t\toptions,\n\t\t\t\t\tthis.fileLockManager!\n\t\t\t\t),\n\t\t\t\twordpressInstallMode,\n\t\t\t\twordPressZip:\n\t\t\t\t\twordPressZip !== undefined\n\t\t\t\t\t\t? new File([wordPressZip], 'wordpress.zip')\n\t\t\t\t\t\t: undefined,\n\t\t\t\tsqliteIntegrationPluginZip:\n\t\t\t\t\tsqliteIntegrationPluginZip !== undefined\n\t\t\t\t\t\t? new File(\n\t\t\t\t\t\t\t\t[sqliteIntegrationPluginZip],\n\t\t\t\t\t\t\t\t'sqlite-integration-plugin.zip'\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t: undefined,\n\t\t\t\tsapiName: 'cli',\n\t\t\t\tcreateFiles: {\n\t\t\t\t\t'/internal/shared/ca-bundle.crt':\n\t\t\t\t\t\trootCertificates.join('\\n'),\n\t\t\t\t},\n\t\t\t\tconstants,\n\t\t\t\tphpIniEntries: {\n\t\t\t\t\t'openssl.cafile': '/internal/shared/ca-bundle.crt',\n\t\t\t\t\tallow_url_fopen: '1',\n\t\t\t\t\tdisable_functions: '',\n\t\t\t\t},\n\t\t\t\tcookieStore: internalCookieStore ? undefined : false,\n\t\t\t\tdataSqlPath,\n\t\t\t\tspawnHandler: () =>\n\t\t\t\t\tsandboxedSpawnHandlerFactory(() =>\n\t\t\t\t\t\tcreatePHPWorker(options, this.fileLockManager!)\n\t\t\t\t\t),\n\t\t\t\tasync onPHPInstanceCreated(php) {\n\t\t\t\t\tawait mountResources(php, mountsBeforeWpInstall);\n\t\t\t\t\tif (wordpressBooted) {\n\t\t\t\t\t\tawait mountResources(php, mountsAfterWpInstall);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t});\n\t\t\tthis.__internal_setRequestHandler(requestHandler);\n\t\t\twordpressBooted = true;\n\n\t\t\tconst primaryPhp = await requestHandler.getPrimaryPhp();\n\t\t\tawait this.setPrimaryPHP(primaryPhp);\n\n\t\t\t// The primary PHP instance is persistent, so we need to apply\n\t\t\t// post-install mounts now that WordPress has been booted.\n\t\t\t// All secondary PHP instances created after WP boot will get\n\t\t\t// these mounts automatically.\n\t\t\tawait mountResources(primaryPhp, mountsAfterWpInstall);\n\n\t\t\tsetApiReady();\n\t\t} catch (e) {\n\t\t\tsetAPIError(e as Error);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\tasync hello() {\n\t\treturn 'hello';\n\t}\n\n\tasync bootWorker(args: WorkerBootOptions) {\n\t\tawait this.bootRequestHandler(args);\n\t}\n\n\tasync bootRequestHandler(options: WorkerBootRequestHandlerOptions) {\n\t\tif (this.booted) {\n\t\t\tthrow new Error('Playground already booted');\n\t\t}\n\t\tthis.booted = true;\n\n\t\ttry {\n\t\t\tconst requestHandler = await bootRequestHandler({\n\t\t\t\tsiteUrl: options.siteUrl,\n\t\t\t\tcreatePhpRuntime: createPhpRuntimeFactory(\n\t\t\t\t\toptions,\n\t\t\t\t\tthis.fileLockManager!\n\t\t\t\t),\n\t\t\t\tonPHPInstanceCreated: async (php) => {\n\t\t\t\t\tawait mountResources(php, options.mountsBeforeWpInstall);\n\t\t\t\t\tawait mountResources(php, options.mountsAfterWpInstall);\n\t\t\t\t},\n\t\t\t\tsapiName: 'cli',\n\t\t\t\tcookieStore: false,\n\t\t\t\tspawnHandler: () =>\n\t\t\t\t\tsandboxedSpawnHandlerFactory(() =>\n\t\t\t\t\t\tcreatePHPWorker(options, this.fileLockManager!)\n\t\t\t\t\t),\n\t\t\t});\n\t\t\tthis.__internal_setRequestHandler(requestHandler);\n\n\t\t\tconst primaryPhp = await requestHandler.getPrimaryPhp();\n\t\t\tawait this.setPrimaryPHP(primaryPhp);\n\n\t\t\tsetApiReady();\n\t\t} catch (e) {\n\t\t\tsetAPIError(e as Error);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\t// Provide a named disposal method that can be invoked via comlink.\n\tasync dispose() {\n\t\tawait this[Symbol.asyncDispose]();\n\t}\n}\n\n/**\n * Returns a factory function that starts a new PHP runtime in the currently\n * running process. This is used for rotating the PHP runtime periodically.\n */\nfunction createPhpRuntimeFactory(\n\toptions: WorkerBootRequestHandlerOptions,\n\tfileLockManager: FileLockManager | RemoteAPI<FileLockManager>\n) {\n\tlet nextProcessId = options.firstProcessId;\n\tconst lastProcessId =\n\t\toptions.firstProcessId + options.processIdSpaceLength - 1;\n\treturn async () => {\n\t\tconst processId = nextProcessId;\n\n\t\tif (nextProcessId < lastProcessId) {\n\t\t\tnextProcessId++;\n\t\t} else {\n\t\t\t// We've reached the end of the process ID space. Start over.\n\t\t\tnextProcessId = options.firstProcessId;\n\t\t}\n\n\t\treturn await loadNodeRuntime(\n\t\t\toptions.phpVersion || RecommendedPHPVersion,\n\t\t\t{\n\t\t\t\temscriptenOptions: {\n\t\t\t\t\tfileLockManager,\n\t\t\t\t\tprocessId,\n\t\t\t\t\ttrace: options.trace ? tracePhpWasm : undefined,\n\t\t\t\t\tphpWasmInitOptions: {\n\t\t\t\t\t\tnativeInternalDirPath: options.nativeInternalDirPath,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tfollowSymlinks: options.followSymlinks,\n\t\t\t\twithIntl: options.withIntl,\n\t\t\t\twithXdebug: options.withXdebug,\n\t\t\t}\n\t\t);\n\t};\n}\n\n/**\n * Spawns a new PHP process to be used in the PHP spawn handler (in proc_open() etc. calls).\n * It boots from this worker-thread-v1.ts file, but is a separate process.\n *\n * We explicitly avoid using PHPProcessManager.acquirePHPInstance() here.\n *\n * Why?\n *\n * Because each PHP instance acquires actual OS-level file locks via fcntl() and LockFileEx()\n * syscalls. Running multiple PHP instances from the same OS process would allow them to\n * acquire overlapping locks. Running every PHP instance in a separate OS process ensures\n * any locks that overlap between PHP instances conflict with each other as expected.\n *\n * @param options - The options for the worker.\n * @param fileLockManager - The file lock manager to use.\n * @returns A promise that resolves to the PHP worker.\n */\nasync function createPHPWorker(\n\toptions: WorkerBootRequestHandlerOptions,\n\tfileLockManager: FileLockManager | RemoteAPI<FileLockManager>\n) {\n\tconst spawnedWorker = await spawnWorkerThread('v1');\n\n\tconst handler = consumeAPI<PlaygroundCliBlueprintV1Worker>(\n\t\tspawnedWorker.phpPort\n\t);\n\thandler.useFileLockManager(fileLockManager as any);\n\tawait handler.bootWorker(options);\n\n\treturn {\n\t\tphp: handler,\n\t\treap: () => {\n\t\t\ttry {\n\t\t\t\thandler.dispose();\n\t\t\t} catch {\n\t\t\t\t/** */\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tspawnedWorker.worker.terminate();\n\t\t\t} catch {\n\t\t\t\t/** */\n\t\t\t}\n\t\t},\n\t};\n}\n\nprocess.on('unhandledRejection', (e: any) => {\n\tlogger.error('Unhandled rejection:', e);\n});\n\nconst phpChannel = new MessageChannel();\n\nconst [setApiReady, setAPIError] = exposeAPI(\n\tnew PlaygroundCliBlueprintV1Worker(new EmscriptenDownloadMonitor()),\n\tundefined,\n\tphpChannel.port1\n);\n\nparentPort?.postMessage(\n\t{\n\t\tcommand: 'worker-script-initialized',\n\t\tphpPort: phpChannel.port2,\n\t},\n\t[phpChannel.port2 as any]\n);\n"],"names":["tracePhpWasm","processId","format","args","sprintf","PlaygroundCliBlueprintV1Worker","PHPWorker","monitor","port","jspi","consumeAPI","consumeAPISync","options","siteUrl","mountsBeforeWpInstall","mountsAfterWpInstall","wordpressInstallMode","wordPressZip","sqliteIntegrationPluginZip","dataSqlPath","internalCookieStore","constants","wordpressBooted","requestHandler","bootWordPressAndRequestHandler","createPhpRuntimeFactory","rootCertificates","sandboxedSpawnHandlerFactory","createPHPWorker","php","mountResources","primaryPhp","setApiReady","e","setAPIError","bootRequestHandler","fileLockManager","nextProcessId","lastProcessId","loadNodeRuntime","RecommendedPHPVersion","spawnedWorker","spawnWorkerThread","handler","logger","phpChannel","MessageChannel","exposeAPI","EmscriptenDownloadMonitor","parentPort"],"mappings":"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"}