import { logger as v, errorLogPath as A } from "@php-wasm/logger";
import { createNodeFsMountHandler as x, loadNodeRuntime as $ } from "@php-wasm/node";
import { EmscriptenDownloadMonitor as M } from "@php-wasm/progress";
import { exposeAPI as _, PHPWorker as B, consumeAPI as T, consumeAPISync as S, sandboxedSpawnHandlerFactory as g, PHPResponse as E, PHPExecutionFailureError as F } from "@php-wasm/universal";
import { sprintf as L } from "@php-wasm/util";
import { runBlueprintV2 as q } from "@wp-playground/blueprints";
import { bootRequestHandler as C } from "@wp-playground/wordpress";
import { existsSync as O } from "fs";
import y from "path";
import { rootCertificates as D } from "tls";
import { MessageChannel as N, parentPort as j } from "worker_threads";
import { jspi as U } from "wasm-feature-detect";
import { s as V, a as G } from "./run-cli-pLJHMn5d.js";
async function m(s, e) {
  for (const r of e)
    try {
      s.mkdir(r.vfsPath), await s.mount(
        r.vfsPath,
        x(r.hostPath)
      );
    } catch {
      i.stderr(
        `\x1B[31m\x1B[1mError mounting path ${r.hostPath} at ${r.vfsPath}\x1B[0m
`
      ), process.exit(1);
    }
}
function Y(s, e, ...r) {
  console.log(
    performance.now().toFixed(6).padStart(15, "0"),
    s.toString().padStart(16, "0"),
    L(e, ...r)
  );
}
Object.defineProperty(process.stdout, "isTTY", { value: !0 });
Object.defineProperty(process.stderr, "isTTY", { value: !0 });
const i = {
  lastWriteWasProgress: !1,
  progress(s) {
    G(process.stdout) && (process.stdout.isTTY ? (i.lastWriteWasProgress || process.stdout.write(`
`), process.stdout.write("\r\x1B[K" + s), i.lastWriteWasProgress = !0) : console.log(s));
  },
  stdout(s) {
    process.stdout.write(`


`), i.lastWriteWasProgress && (i.lastWriteWasProgress = !1), process.stdout.write(s);
  },
  stderr(s) {
    process.stdout.write(`


`), i.lastWriteWasProgress && (i.lastWriteWasProgress = !1), process.stderr.write(s);
  }
};
class z extends B {
  constructor(e) {
    super(void 0, e), this.booted = !1, this.blueprintTargetResolved = !1, this.phpInstancesThatNeedMountsAfterTargetResolved = /* @__PURE__ */ new Set();
  }
  /**
   * Call this method before boot() to use file locking.
   *
   * This method is separate from boot() to simplify the related Comlink.transferHandlers
   * setup – if an argument is a MessagePort, we're transferring it, not copying it.
   *
   * @see comlink-sync.ts
   * @see phpwasm-emscripten-library-file-locking-for-node.js
   */
  async useFileLockManager(e) {
    await U() ? this.fileLockManager = T(e) : this.fileLockManager = await S(e);
  }
  async bootAndSetUpInitialWorker(e) {
    const r = {
      WP_DEBUG: !0,
      WP_DEBUG_LOG: !0,
      WP_DEBUG_DISPLAY: !1
    }, p = {
      ...e,
      createFiles: {
        "/internal/shared/ca-bundle.crt": D.join(`
`)
      },
      constants: r,
      phpIniEntries: {
        "openssl.cafile": "/internal/shared/ca-bundle.crt"
      },
      onPHPInstanceCreated: async (o) => {
        await m(o, e.mountsBeforeWpInstall || []), this.blueprintTargetResolved ? await m(o, e.mountsAfterWpInstall || []) : (this.phpInstancesThatNeedMountsAfterTargetResolved.add(o), o.addEventListener("runtime.beforeExit", () => {
          this.phpInstancesThatNeedMountsAfterTargetResolved.delete(
            o
          );
        }));
      },
      spawnHandler: () => g(
        () => k(e, this.fileLockManager)
      )
    };
    await this.bootRequestHandler(p);
    const u = this.__internal_getPHP();
    if (e.mode === "mount-only") {
      await m(u, e.mountsAfterWpInstall || []);
      return;
    }
    await this.runBlueprintV2({
      ...e,
      mountsAfterWpInstall: e.mountsAfterWpInstall || []
    });
  }
  async bootWorker(e) {
    await this.bootRequestHandler({
      ...e,
      onPHPInstanceCreated: async (r) => {
        await m(r, e.mountsBeforeWpInstall || []), await m(r, e.mountsAfterWpInstall || []), r.isDir("/wordpress/wp-content") || r.mkdir("/wordpress/wp-content"), r.isDir("/wordpress/wp-content/database") || r.mkdir("/wordpress/wp-content/database"), r.isFile("/wordpress/wp-content/database/.htaccess") || r.writeFile(
          "/wordpress/wp-content/database/.htaccess",
          "deny from all"
        ), r.isFile("/wordpress/wp-content/database/index.php") || r.writeFile(
          "/wordpress/wp-content/database/index.php",
          "deny from all"
        );
      },
      spawnHandler: () => g(
        () => k(e, this.fileLockManager)
      )
    });
  }
  async runBlueprintV2(e) {
    const r = this.__internal_getRequestHandler(), { php: p, reap: u } = await r.instanceManager.acquirePHPInstance({
      considerPrimary: !1
    }), o = this.__internal_getPHP();
    let w = () => {
    };
    if (typeof e.blueprint == "string") {
      const n = y.resolve(process.cwd(), e.blueprint);
      O(n) && (o.mkdir("/internal/shared/cwd"), w = await o.mount(
        "/internal/shared/cwd",
        x(y.dirname(n))
      ), e.blueprint = y.join(
        "/internal/shared/cwd",
        y.basename(e.blueprint)
      ));
    }
    try {
      const l = [
        "mode",
        "db-engine",
        "db-host",
        "db-user",
        "db-pass",
        "db-name",
        "db-path",
        "truncate-new-site-directory",
        "allow"
      ].filter((t) => t in e).map((t) => `--${t}=${e[t]}`);
      l.push(`--site-url=${e.siteUrl}`);
      const d = await q({
        php: p,
        blueprint: e.blueprint,
        blueprintOverrides: {
          additionalSteps: e["additional-blueprint-steps"],
          wordpressVersion: e.wp
        },
        cliArgs: l,
        onMessage: async (t) => {
          switch (t.type) {
            case "blueprint.target_resolved": {
              if (!this.blueprintTargetResolved) {
                this.blueprintTargetResolved = !0;
                for (const a of this.phpInstancesThatNeedMountsAfterTargetResolved)
                  this.phpInstancesThatNeedMountsAfterTargetResolved.delete(
                    a
                  ), await m(
                    a,
                    e.mountsAfterWpInstall || []
                  );
              }
              break;
            }
            case "blueprint.progress": {
              const a = `${t.caption.trim()} – ${t.progress.toFixed(
                2
              )}%`;
              i.progress(a);
              break;
            }
            case "blueprint.error": {
              const a = "\x1B[31m", f = "\x1B[1m", h = "\x1B[0m";
              e.debug && t.details ? i.stderr(
                `${a}${f}Fatal error:${h} Uncaught ${t.details.exception}: ${t.details.message}
  at ${t.details.file}:${t.details.line}
` + (t.details.trace ? t.details.trace + `
` : "")
              ) : i.stderr(
                `${a}${f}Error:${h} ${t.message}
`
              );
              break;
            }
          }
        }
      });
      if (e.debug && (d.stdout.pipeTo(
        new WritableStream({
          write(t) {
            process.stdout.write(t);
          }
        })
      ), d.stderr.pipeTo(
        new WritableStream({
          write(t) {
            process.stderr.write(t);
          }
        })
      )), await d.finished, await d.exitCode !== 0) {
        const t = await E.fromStreamedResponse(d);
        throw new F(
          `PHP.run() failed with exit code ${t.exitCode}. ${t.errors} ${t.text}`,
          t,
          "request"
        );
      }
    } catch (n) {
      let l = "";
      try {
        l = p.readFileAsText(A);
      } catch {
      }
      throw n.phpLogs = l, n;
    } finally {
      u(), w();
    }
  }
  async bootRequestHandler({
    siteUrl: e,
    allow: r,
    phpVersion: p,
    createFiles: u,
    constants: o,
    phpIniEntries: w,
    firstProcessId: n,
    processIdSpaceLength: l,
    trace: d,
    nativeInternalDirPath: t,
    withIntl: a,
    withXdebug: f,
    onPHPInstanceCreated: h,
    spawnHandler: b
  }) {
    if (this.booted)
      throw new Error("Playground already booted");
    this.booted = !0;
    let c = n;
    const I = n + l - 1;
    try {
      const P = await C({
        siteUrl: e,
        createPhpRuntime: async () => {
          const H = c;
          return c < I ? c++ : c = n, await $(p, {
            emscriptenOptions: {
              fileLockManager: this.fileLockManager,
              processId: H,
              trace: d ? Y : void 0,
              ENV: {
                DOCROOT: "/wordpress"
              },
              phpWasmInitOptions: { nativeInternalDirPath: t }
            },
            followSymlinks: r?.includes("follow-symlinks"),
            withIntl: a,
            withXdebug: f
          });
        },
        maxPhpInstances: 1,
        onPHPInstanceCreated: h,
        sapiName: "cli",
        createFiles: u,
        constants: o,
        phpIniEntries: w,
        cookieStore: !1,
        spawnHandler: b
      });
      this.__internal_setRequestHandler(P);
      const R = await P.getPrimaryPhp();
      await this.setPrimaryPHP(R), K();
    } catch (P) {
      throw J(P), P;
    }
  }
  // Provide a named disposal method that can be invoked via comlink.
  async dispose() {
    await this[Symbol.asyncDispose]();
  }
}
async function k({
  siteUrl: s,
  allow: e,
  phpVersion: r,
  createFiles: p,
  constants: u,
  phpIniEntries: o,
  firstProcessId: w,
  processIdSpaceLength: n,
  trace: l,
  nativeInternalDirPath: d,
  withXdebug: t,
  mountsBeforeWpInstall: a,
  mountsAfterWpInstall: f
}, h) {
  const b = await V("v2"), c = T(
    b.phpPort
  );
  return c.useFileLockManager(h), await c.bootWorker({
    siteUrl: s,
    allow: e,
    phpVersion: r,
    createFiles: p,
    constants: u,
    phpIniEntries: o,
    firstProcessId: w,
    processIdSpaceLength: n,
    trace: l,
    nativeInternalDirPath: d,
    withXdebug: t,
    mountsBeforeWpInstall: a,
    mountsAfterWpInstall: f
  }), {
    php: c,
    reap: () => {
      try {
        c.dispose();
      } catch {
      }
      try {
        b.worker.terminate();
      } catch {
      }
    }
  };
}
process.on("unhandledRejection", (s) => {
  v.error("Unhandled rejection:", s);
});
const W = new N(), [K, J] = _(
  new z(new M()),
  void 0,
  W.port1
);
j?.postMessage(
  {
    command: "worker-script-initialized",
    phpPort: W.port2
  },
  [W.port2]
);
export {
  z as PlaygroundCliBlueprintV2Worker
};
//# sourceMappingURL=worker-thread-v2.js.map
